[{"content":"编译原理知识汇总 编译原理 第一章 绪论 从面向机器的语言到面向人类的语言 汇编指令： 用符号表示的指令被称为汇编指令 汇编语言： 汇编指令的集合称为汇编语言\n语言之间的翻译 转换 (也被称为 预处理 )：高级语言之间的翻译\n编译： 高级语言可以直接翻译成机器语言，也可以翻译成汇编语言，这两个翻译过程称为编译 汇编： 从汇编语言到机器语言的翻译被称为汇编 交叉汇编： 将一个汇编语言程序汇编成为可在另一机器上运行的机器指令成为交叉汇编 反汇编： 把机器语言翻译成汇编语言 反编译： 把汇编语言翻译成高级语言\n课程内容 介绍设计和构造编译程序的基本原理和基本实现技术\n三种程序 翻译程序\n编译程序（compiler）：把某一种高级语言程序等价转换成另一种低级语言程序（如汇编或机器语言）的程序\n解释程序\n编译器与解释器 （1）语言翻译的两种基本形态\n解释器与编译器的主要区别: 运行目标程序时的控制权在 解释器而不在目标程序.\n（2）各自特点\n编译器:工作效率高,即时间快、空间省；交互性与动态性差,可移植性差. 解释器:工作效率低,即时间慢、空间费；交互性与动态性好,可移植性好. 共同点:均完成对 源程序的翻译. 差异:编译器采用先翻译后执行,解释器采用边翻译边执行.\n编译器的工作原理与基本组成 （1）以阶段划分编译器\n注：符号表管理器和出错处理贯穿编译器工作的各个阶段.\n（2）编译器各阶段工作\n1 \u0026gt; 词法分析： 词法分析的 输入 是 源程序, 输出 是识别出的 记号流. 目的 是 识别单词. 至少分以下几类：关键字(保留字)、标识符、字面量、特殊符号\n2 \u0026gt; 语法分析： 输入 是词法分析器返回的 记号流, 输出 是 语法树. 目的 是得到语言结构并以树的形式表示.对于声明性语句,进行符号表的查填,对于可执行语句,检查结构合理的表达式运算是否有意义.\n3 \u0026gt; 语义分析： 根据语义规则对语法树中的语法单元进行静态语义检查,如类型检查和转换等, 目的 在于保证语法正确的结构在语义分析上也是合法的.\n4 \u0026gt; 中间代码生成(可选)： 生成一种既接近目标语言,又与具体机器无关的表示,便于代码优化与代码生成.\n(到目前为止，编译器与解释器可以一致)\n5 \u0026gt; 中间代码优化(可选)： 局部优化、循环优化、全局优化等；优化实际上是一个等价变换，变换前后的指令序列完成同样的功能，但在占用的空间上和程序执行的时间上都更省、更有效\n6 \u0026gt; 目标代码生成： 不同形式的目标代码—汇编语言形式、可重定位二进制代码形式、内存形式\n7 \u0026gt; 符号表管理： 合理组织符号,便于各阶段查找\\填写等.\n8 \u0026gt; 出错处理： 动态错误：源程序中的逻辑错误，发生在程序运行的时候。也称为动态语义错误 静态错误：静态错误分为语法错误和静态语义错误. \u0026lt;1\u0026gt; 语法错误：有关语言结构上的错误，如单词拼写错误、表达式缺少操作数、begin和end不匹配 \u0026lt;2\u0026gt; 静态语义错误：分析源程序时可以发现的语言意义上的错误，如加法的两个操作数一个是整形变量，另一个是数组名\n（3）编译器的分析\\综合模式\n逻辑上把编译器分为 分析(前端)部分和 综合(后端)部分. 1\u0026gt; 分析(前端)：语言结构和意义的分析； 从词法分析到中间代码生成各阶段的工作 2\u0026gt; 综合(后端)：语言意义处理；从中间代码生成到目标代码生成的各阶段的工作 3\u0026gt; 编译器和解释器的区别往往是在形成中间代码之后开始的.\n编译器扫描的遍数 每个阶段将程序完整分析一遍的工作模式称为一遍扫描。 (将源程序或源程序的某种形式的中间表示完整分析一遍，亦称作一遍扫描)\n第二章 高级语言及语法描述 程序语言的定义 程序语言由 语法 和 语义 两方面定义\n语法 词法规则：单词符号的形成规则 描述工具：有限自动机 语法规则：语法单位的形成规则 描述工具：上下文无关文法 语义 程序语言的语法 程序语言的语法描述 概念 有穷 字母表（字符集） Σ 中每一个元素称为一个字符 Σ 上的字（也叫字符串） 是指由 Σ 中的 字符所构成的一个有穷序列 空字 ε ：不包含任何字符的序列 Σ* ：表示 Σ 上的所有字的全体，包含空字 ε Σ* 的子集 U 和 V 的**连接（积）**定义为 UV = { αβ| α∈U , β∈V } V*：闭包 V+：正规闭包 上下文无关文法 文法：描述语言的语法结构的形式规则 （或语法规则）\n上下文无关文法的定义：\n一个上下文无关文法 G 是一个四元式 G =(VT, VN, S, P)，其中:\n​\tVT: 终结符集合( 非空 )\n​\tVN: 非终结符集合( 非空 )\n​\tS: 文法的开始符号\n​\tP: 产生式集合\n产生式（文法的简化表示方法）\n$$ 例： G ( E ) : E \\rightarrow i | E + E | E * E | (E) $$\n上下文无关文法的中心思想： 从文法的开始符号出发，反复连续使用产生式，对非终结符实行替换和展开 句型 句子: 只含终结符的句型 文法 \u0026mdash;\u0026gt; 语言 构造某语言文法的方法 采用凑规则的方法来完成：\n找出语言的若干句子 分析句子的特点 根据句子的特点凑规则 形成文法 检验 $$ 构造生成 L = {a^n b^n c^i | n \\geq 1, i \\geq 0 }语言的文法: \\ G[ Z ]: Z \\rightarrow AB|A \\ A \\rightarrow aAb|ab \\ B \\rightarrow cB|c \\ $$\n最左推导 最右推导 语法树与二义性 用一张图表示一个句型的推导，称为语法树 语言二义性 文法二义性： 可以改造为无二义 形式语言鸟瞰 $$ 产生式: α \\rightarrow β $$\n0型文法: α 至少含有一个终结符\n1型文法( 上下文有关文法 ): |α | \u0026lt;= |β| ,表示长度\n2型文法( 上下文无关文法 ): α 只能是一个非终结符, 如 A\n3型文法( 正规文法，有限自动机 ): α 只能是一个非终结符, 且 β 只能是 αB( Bα ) 或 α\n​\t描述能力从上至下逐渐减弱，为包含关系\n第二章 词法分析 词法分析中的若干问题 (1) 记号、模式与单词\n单词的分类： 关键字(保留字)、标识符、字面量、特殊符号 模式（pattern） ：产生/识别单词的规则 记号（token） ：按照某个模式(或规则)识别出的元素(一组) 单词（lexeme） ：被识别出的元素的值(字符串本身) ，也称为词值\n(2) 词法分析器的作用与工作方式\n词法分析器的作用：\n识别记号并交给语法分析器(根据模式识别记号) 滤掉源程序中的无用成分,如注释、空格和回车等 处理与具体平台有关的输入(如文件结束符的不同表示等) 调用符号表管理器和出错处理器，进行相关处理 工作方式：\n单独一遍扫描 作为语法分析器的子程序 并行方式 模式的形式化描述 (1) 字符串与语言\n语言L 是有限字母表∑上有限长度字符串的集合. 定义中强调两个有限，因为计算机的表示能力有限 ： 1\u0026gt; 字母表是有限的，即字母表中元素是有限多个； 2\u0026gt; 字符串的长度是有限的，即字符串中字符个数是有限多个。\n(字符串与字符串集合相关的概念与运算,如前缀、后缀、子串、子序列等，字符串的并、交、连接、差、闭包)\n(2) 正规式与正规集\n令Σ是一个有限字母表，则Σ上的 正规式 及其表示的集合递归定义如下: 1. ε是正规式，它表示集合 L(ε) = {ε} 2. 若a是Σ上的字符，则a是正规式，它表示集合L(a)={a} 3. 若正规式r和s分别表示集合L(r)和L(s)，则 （a） r|s是正规式，表示集合L(r)∪L(s)， （b） rs是正规式，表示集合L(r)L(s)， （c） r*是正规式，表示集合(L(r))*， （d）(r)是正规式，表示的集合仍然是L(r)。 括弧用来改变运算的先后次序！ 可用正规式描述(其结构)的语言称为 正规语言 或 正规集 。\n若运算的优先级和结合性做下述约定: 1. 三种运算均具有左结合性质； 2. 优先级从高到低顺序排列为:闭包运算、连接运算、或运算。 则正规式中不必要的括号可以被省略。 若正规式P和Q表示了同一个正规集，则称P和Q是 等价 的，记为P=Q\n(3) 简化正规式描述(主要是简化书写上的复杂)\n(a) 正闭包 若r是表示L(r)的正规式，则r+是表示(L(r))+的正规式，且下述等式成立:r+ = rr* = rr，r = r+|ε;\t+与*具有相同的运算结合性和优先级 (b) 可缺省 若r是正规式，则r?是表示L(r)∪{ε}的正规式，且下述等式成立:r? = r|ε\t? 与 * 具有相同的运算结合性和优先级 (c) 串 若r是若干字符进行连接运算构成的正规式，则:串“r” = r ，且: ε= “”， a = “a”（a是Σ的任一字符） (d) 字符组 若r是若干字符进行|运算构成的正规式，则可改写为 [r’]，其中r’可以有如下两种书写形式： 枚举: 如 a|b|e|h，可写为 [abeh]： 分段: 如0|1|2|3|4|5|6|7|8|9|a|b|c|d|e , 可写为： [0-9a-e] (e) 非字符组 若[r]是一个字符组形式的正规式，则[^r]是表示∑- L([r])的正规式。 记号的识别——有限自动机 (1) 不确定的有限自动机（NondeterministicFinite Automaton, NFA）\nNFA是一个五元组（5-tuple）：M =（S，∑，move，s0，F），其中 （1） S是有限个状态（state）的集合； （2） ∑是有限个输入字符（包括ε）的集合； （3） move是一个状态转移函数，move(si，ch)=sj表示，当前状态si下若遇到输入字符ch，则转移到状态sj； （4） s0是唯一的初态（也称开始状态）； （5） F是终态集（也称接受状态集），它是S的子集，包含了所有的终态。 \u0026lt;1\u0026gt; 直观的表示方式\n① 状态转换图：用一个有向图来直观表示NFA ② 状态转换矩阵：用一个矩阵来直观表示NFA (矩阵中，状态对应行，字符对应列)\n\u0026lt;2\u0026gt; NFA(识别记号)的特点 NFA识别记号的最大特点是它的不确定性，即在当前状态下对同一字符有多于一个的下一状态转移。\n具体体现： 定义： move函数是1对多的； 状态转换图：从同一状态出发，可通过多于一条标记相同字符的边转移到不同的状态； 状态转换矩阵： M[si,a]是一个状态的集合 \u0026lt;3\u0026gt; NFA识别记号存在的问题\n1.只有尝试了全部可能的路径,才能确定一个输入序列不被接受,而这些路径的条数随着路径长度的增长成指数增长 2.识别过程中需要进行大量回朔，时间复杂度升高且算法复杂\n(2) 确定的有限自动机（Deterministic Finite Automaton, DFA）\n定义: DFA是NFA的一个特例，其中： （1）没有状态具有ε状态转移(ε-transition)，即状态转换图中没有标记ε的边； （2）对每个状态s和每个字符a，最多有一个下一状态。 特点：与NFA相比，DFA的特征：确定性 定义：move（si, a)函数都是 1对1 的； 转换图 从一个状态出发的任2条边上的标记均不同； 转换矩阵：M[si,a]是一个状态 且字母表不包括ε。 提示：正规式和有限自动机从两个侧面表示正规式。正规式是描述，自动机是识别。 从正规式到词法分析器 构造词法分析器的一般方法和步骤： 1. 用正规式描述模式（为记号设计正规式）； 2. 为每个正规式构造一个NFA，它识别正规式所表示的正规集； 3. 将构造的NFA转换成等价的DFA，这一过程也被称为确定化； 4. 优化DFA，使其状态数最少，这一过程也被称为最小化； 5. 根据优化后的DFA构造词法分析器。 (1) 从正规式到NFA\nThompson 算法\n(2) 从NFA到DFA\n- smove(S, a)：从状态集S出发，标记为a的下一状态全体。与move(s, a)的唯一区别：用状态集取代状态 - ε-闭包(T)：从状态集T出发，不经任何字符达到的状态全体 - “子集法”构造DFA (3) 最小化DFA\n① 对于任何两个状态t和s，若从一状态出发接受输入字符串ω，而从另一状态出发不接受ω.\n或者，② 从t出发和从s出发到达不同的接受状态，则称ω对状态t和s是可区分的.\n不可区分的状态位于一个组内，可以合并成一个状态.\n主要步骤： 1.初始划分：终态组 ， 非终态组； 2.利用可区分的概念，反复分裂划分中的组Gi，直到不可再分裂； 3.由最终划分构造D\u0026rsquo;，关键是选代表和修改状态转移； 4.消除可能的死状态和不可达状态。\n从DFA构造词法分析器 分类： 表驱动型的词法分析器；直接编码的词法分析器 比较：\n表驱动 直接编码 分析器的速度 慢 快 程序与模式的关系 无关 有关 适合的编写方法 工具生成 手工编写 分析器的规模 较大 较小 第三章 语法分析 词法分析： 记号的集合，字符串由字母组成，线性结构 语法分析： 句子的集合，句子由记号组成，非线性结构（树）\n语法分析的双重含义：\n语法规则：上下文无关文法（子集：LL文法或LR文法） 语法分析：下推自动机（LL或LR分析器）、自上而下分析、自下而上分析 1. 语法分析的若干问题 许多编译器，特别是由自动生成工具构造的编译器，往往其前端的中心部件就是语法分析器\n（1）语法分析器的作用\n根据词法分析器提供的记号流，为语法正确的输入构造分析树（或语法树） 检查输入中的语法（可能包括词法）错误，并调用出错处理器进行适 当处理 （2）语法错误的处理原则\n源程序中可能出现的错误\n语法(包括词法)错误和语义错误(静态语义错误和动态语义错误)\n注：跟第一章的分类角度不同，第一章是从静态错误(语法错误，静态语义错误)和动态错误(动态语义错误)分类的，但是殊途同归。\n词法错误： 指非法字符或拼写错关键字、标识符等 语法错误： 指语法结构出错，如少分号、括号不匹配、begin/end不配对等 静态语义错误： 如类型不一致、参数不匹配等 动态语义错误(逻辑错误)： 如死循环、变量为零时作除数等\n2. 上下文无关文法(CFG) （1）上下文无关文法(Context Free Grammar, CFG)\nCFG是一个四元组G =（N，T，P，S），其中 （1） N是非终结符（Nonterminals）的有限集合； （2） T是终结符（Terminals）的有限集合，且N∩T=Φ； （3） P是产生式（Productions）的有限集合，A→α，其中A∈N(左部),α∈(N∪T)*(右部),若α=ε，则称A→ε为空产生式(也可以记为A →); （4） S是非终结符，称为文法的开始符号（Start symbol） 注： S ∈ N , N可以出现在产生式左边和右边，T绝不出现在产生式左边. （2）CFG产生语言的基本方法－推导\nCFG（产生式）通过推导的方法产生语言，即（通俗地讲）从开始符号S开始，反复使用产生式：将产生式左部的非终结符替换为右部的文法符号序列(展开产生式，用=\u0026gt;表示)，直到得到一个终结符序列。\n**1 \u0026gt; 直接推导：**利用产生式产生句子的过程中，将用产生式A→γ的右部代替文法符号序列αAβ中的A得到αγβ的过程，称αAβ直接推导出αγβ，记作：αAβ=\u0026gt;αγβ\n**2 \u0026gt; 零步或多步推导：**若对于任意文法符号序列α1，α2，\u0026hellip;αn，有α1=\u0026gt;α2=\u0026gt;\u0026hellip;=\u0026gt;αn，则称此过程为零步或多步推导，记为：α1 =*=\u0026gt; αn，其中α1=αn的情况为零步推导。\n**3 \u0026gt; 至少一次推导：**若α1≠αn，即推导过程中至少使用一次产生式,则称此过程为至少一步推导，记为：α1 =+=\u0026gt; αn\n(推导具有自反性和传递性)\n4 \u0026gt; 由 CFGG 所产生的语言L(G)被定义为: L(G) = { ω┃S ωand ω∈T* }， L(G)称为上下文无关语言(Context Free Language, CFL)，ω称为句子。 若S =* \u0026gt; α，α∈(N∪T)*，则称α为G的一个句型。句子一定是句型，反之不是。\n5 \u0026gt; 在推导过程中，若每次直接推导均替换句型中最左边的非终结符，则称为 最左推导，由最左推导产生的句型被称为 左句型。 类似的可以定义最右推导与右句型，最右推导也被称为规范推导。\n（3）推导、分析树与语法树\n1、分析树既反映语言结构的实质，也反映推导过程。\n2、对CFGG的句型， 分析树 被定义为具有下述性质的一棵树。\n（1） 根由开始符号所标记； （2） 每个叶子由一个终结符、非终结符、或ε标记； （3） 每个内部结点由一个非终结符标记； （4） 若A是某内部节点的标记，且X1，X2，\u0026hellip;，Xn是该节点从左到右所有孩子的标记，则A→X1X2\u0026hellip;Xn是一个产生式。若A→ε，则标记为A的结点可以仅有一个标记为ε的孩子。\n注：分析树的叶子，从左到右构成G的一个句型。若叶子仅由终结符标记，则构成一个句子。\n3、对CFG G的句型，表达式的语法树被定义为具有下述性质的一棵树:\n（1） 根与内部节点由表达式中的操作符标记；（2） 叶子由表达式中的操作数标记；（3）用于改变运算优先级和结合性的括号，被隐含在语法树的结构中。\n语法树是表示表达式结构的最好形式 （4）二义性与二义性的消除\n二义性： 若文法G对 同 一句子产生不止一棵 分析树，则称G是二义的.\n结论： 1\u0026gt; 一个句子有多于一棵分析树，仅与文法和句子有关，与采用的推导方法无关； 2\u0026gt; 造成文法二义的根本原因：文法中缺少对文法符号优先级和结合性的规定\n二义性消除的方法： ① 改写二义文法为非二义文法； ② 规定二义文法中符号的优先级和结合性，使仅产生一棵分析树。\n3. 语法与文法简介 （1）正规式与上下文无关文法\n记号可以用正规式描述，正规式适合描述线性结构，如标识符、关键字、注释等. 句子可以用CFG描述，CFG适合描述具有嵌套(层次)性质的非线性结构，如不同结构的句子if-then-else\\while-do等 正规式所描述的语言结构均可以用CFG描述，反之不一定.\n（2）上下文有关文法CSG\n典型的这类语言结构包含：计数问题的抽象、变量的声明与引用、过程调用时形参与实参的一致性检查等.描述它们的文法被称为上下文有关文法(Context Sensitive Grammar，CSG).这些语言结构无法用上下文无关文法CSG来描述.\n（3）形式语言与自动机简介\n若文法G=(N，T，P，S)的每个产生式α→β中，均有α∈(N∪T) ，且至少含有一个非终结符，β∈(N∪T) ，则称G为0型文法.\n对0型文法施加以下第i条限制，即得到i型文法。\n1\u0026gt; G的任何产生式α→β（S→ε除外）满足|α|≤|β|； 2\u0026gt; G的任何产生式形如A→β，其中A∈N，β∈(N∪T)*； 3\u0026gt; G的任何产生式形如A→a或者A→aB(或者A→Ba)，其中A和B∈N，a∈T。\n文法 语言 自动机 短语文法(0型) 短语结构语言 图灵机 CSG(1型) CSL 线性界线自动机 CFG(2型) CFL 下推自动机 正规文法(3型) 正规集 有限自动机 4. 自上而下语法分析 分为：递归下降分析法、预测分析法\n基本思想： 对任何一个输入序列ω，从S开始进行最左推导，直到得到一个合法的句子或发现一个非法结构。整个自上而下分析是一个试探的过程，是反复使用不同产生式谋求与输入序列匹配的过程。\n提前准备—— 重写文法： 1.消除左递归，以避免陷入死循环； 2.提取左因子，以避免回溯.\n（1）消除左递归\n定义：若文法G中的非终结符A，对某个文法符号序列α存在推导A =+\u0026gt; Aα，则称G是左递归的。若G中有形如A→Aα的产生式，则称该产生式对A直接左递归。\n\u0026lt;1\u0026gt; 消除文法的直接左递归\nA→Aα|β 替换为 A →βA' A'→αA'|ε 首先，整理A产生式为如下形式：A→ Aα1|Aα2|\u0026hellip;|Aαm|β1|β2|\u0026hellip;|βn 然后用下述产生式代替A产生式：A→ β1 A\u0026rsquo;|β2 A\u0026rsquo;| \u0026hellip;|βn A' A\u0026rsquo;→ α1 A\u0026rsquo; | α2 A\u0026rsquo; | \u0026hellip; | αm A\u0026rsquo; |ε\n\u0026lt;2\u0026gt; 消除文法的左递归\n核心思想：将无直接左递归的非终结符展开到其他产生式,然后消除其他产生式中的直接左递归(如果有的话)\n若G产生句子的过程中出现A=+A的推导，则无法消除左递归(出现回路)\n（2）提取左因子\n\u0026lt;1\u0026gt; 提取文法的左因子\n左因子产生原因：公共前缀：A → αβ1|αβ2 方法：将 A → αβ1|αβ2|γ 替换为 A→αA\u0026rsquo;|γ A\u0026rsquo;→β1|β2\n（3）递归下降分析\n直接以程序代码（的方式）模拟产生式产生语言的过程:\n基本思想： 每个非终结符对应一个子程序（函数），过程体中：\n产生式右部的非终结符：对应子程序调用， 产生式右部的终结符： 与输入记号序列进行匹配。 特点： 1\u0026gt; 子程序是递归的（因为文法是递归的）； 2\u0026gt; 程序与文法相关； 3\u0026gt; 它对文法的限制是不能有公共左因子和左递归； 4\u0026gt; 它是一种非形式化的方法，只要能写出子程序，用什么样的方法和步骤均可。\n（4）预测分析器\n☆ 预测分析器由一张预测分析表、一个符号栈和一个驱动器组成，数学模型是下推自动机。 ☆ 对文法的限制是不能有公共左因子和左递归\n预测分析器的核心概念： 1\u0026gt; 分析方法：格局与格局变换 2\u0026gt; 分析表+驱动器（模拟算法） 3\u0026gt; 预测分析表的构造 4\u0026gt; LL（文法、语言、分析器）\n☆ 开始格局的剩余输入是全部输入序列，而接收格局中剩余输入应该为空，任何其他格局或出错格局中的剩余输入应该是全部输入序列的一个后缀.\n☆ 改变格局的动作：\n① 匹配终结符： 若top=ip(但≠#)，则pop且next(ip)； ② 展开非终结符：若top^= X且M[X,ip^]=α(X→α)，则pop且push(α)； ③ 报告分析成功： 若top ^= ip^ = #，则分析成功并结束； ④ 报告出错：其它情况，调用错误恢复例程.\n☆ 驱动器算法\n☆ 构造预测分析表\n步骤：1. 构造文法符号X的FIRST集合和非终结符的FOLLOW集合；2. 根据两个集合构造预测分析表.\n通俗地讲，α的FIRST集合就是从α开始可以导出的文法符号序列中的开头终结符。而A的FOLLOW集合，就是从开始符号可以导出的所有含A的文法符号序列中紧跟A之后的终结符.\n\u0026lt;1\u0026gt; 计算X的FIRST集合 \u0026mdash;\u0026ndash;自下而上计算 \u0026lt;2\u0026gt; 计算所有非终结符的FOLLOW集合 —— 自上而下计算 \u0026lt;3\u0026gt; 构造预测分析表 \u0026lt;4\u0026gt; LL(1)文法\n文法G被称为是LL(1)文法，当且仅当为它构造的 预测分析表中 不含多重定义的条目。由此分析表所组成的分析器被称为 LL(1)分析器，它所分析的语言被称为 LL(1)语言。\n☆ 第一个L代表从左到右扫描输入序列，第二个L表示产生最左推导，1表示在确定分析器的每一步动作时向前看一个终结符.\n推论3.2 G是LL(1)的，当且仅当G的任何两个产生式A→α|β满足: 1. 对任何终结符a，α和β不能同时推导出以a开始的串；即First(α) ∩ First(β) = ∅ 2. α和β最多有一个可以推导出ε； 3. 若β =*\u0026gt; ε,则α不能导出以FOLLOW(A)中终结符开始的任何串. 即First(α) ∩ Follow(A) = ∅ ☆ 无论是递归下降子程序法还是非递归的预测分析法，他们都只能处理LL(1)文法.\n构造 First 集和 Follow 集 5. 自下而上语法分析 ☆ 自上而下分析采用的是推导;自下而上分析采用的是归约(规范归约—剪句柄—移进/归约分析—SLR(1)分析器).\n（1）自下而上分析的基本方法\n☆ 基本思想： 最左归约.\n对于每个输入序列ω：从左到右扫描ω; 从ω开始,反复用产生式的左部替换产生式的右部(即当前句型中的句柄)、谋求对ω的匹配,最终得到文法的开始符号,或者发现一个错误。\n☆ 基本概念：\na) \u0026gt; 设αβδ是文法G的一个句型，若存在S=*\u0026gt;αAδ，A=+\u0026gt;β， 则称β是句型αβδ相对于A的\u0026quot;短语\u0026quot;. \u0026gt; 特别的，若 有A→β，则 称β是句型αβδ相对于产生式A→β的\u0026quot;直接短语\u0026quot;. \u0026gt; 一个句型的最左直接短语被称为\u0026quot;句柄\u0026quot;. 特征： 1. 短语：以非终结符为根子树中所有从左到右的叶子； 2. 直接短语：只有父子关系的子树中所有从左到右排列的叶子（树高为2）； 3. 句柄：最左边父子关系树中所有从左到右排列的叶子（句柄是唯一的） b)最左归约：若 α是文法G的句子且满足下述条件，则称序列αn，αn-1，...，α0是α的一个最左归约。 1) αn = α 2) α0 = S（S是G 的开始符号） 3) 对任何i(0\u0026lt;i\u0026lt;=n)，αi-1是将αi中句柄替换为相应产生式左部非终结符得到的 ☆ 最左归约的逆过程是一个最右推导，分别称最右推导和最左归约为规范推导和规范归约. c）移进-归约分析器 1. 工作方式：格局与格局变换 2. 分析表 3. 驱动器（模拟算法） 4. SLR分析表的构造 5. LR（文法、语言、分析器） ☆ 改变格局的动作： 1.移进(shift)：当前剩余输入的下一终结符进栈。 2.归约(reduce)：将栈顶句柄替换为对应非终结符(最左归约) 3.接受(accept)：宣告分析成功 4.报错(error)：发现语法错误，调用错误恢复例程 (2) LR分析\na) LR分析与LR文法 LR分析： 允许左递归，但不能有二义_\n定义3.15 若为文法G构造的移进-归约分析表中不含多重定义的条目，则称G为\u0026quot;LR(k)文法\u0026quot;，分析器被称为是\u0026quot;LR(k)分析器\u0026quot;，它所识别的语言被称为\u0026quot;LR(k)语言\u0026quot;。\u0026quot;L\u0026quot;表示从左到右扫描输入序列，\u0026quot;R\u0026quot;表示逆序的最右推导，\u0026quot;k\u0026quot;表示为确定下一动作向前看的终结符个数，一般情况下k\u0026lt;=1。当k=1时，简称\u0026quot;LR\u0026quot;。 构造SLR(1)分析器\n\u0026lt;1\u0026gt; 活前缀与LR(0)项目\n第1步 第2~N步 状态 词法\u0026ndash;DFA ε-closure(S) ε-closure(smove(S,a)) 状态集 语法\u0026ndash;DFA closure(I) closure(goto(I,x)) 项目集 出现在移进-归约分析器栈中的右句型的前缀，被称为文法G的 活前缀(viable prefix). LR(0)项目(简称项目) 是这样一个产生式，在它右边的某个位置有一个点\u0026quot;.\u0026quot;。对于A→ε，它仅有一个项目A→.。 项目A→α.β显示了分析过程中看到(移进)了产生式的多少。 β不为空的项目称为 可移进项目 ，β为空的项目称为 可归约项目.\n\u0026lt;2\u0026gt; 拓广文法与识别活前缀的DFA\nG\u0026rsquo; = G ∪ {S\u0026rsquo; → S} 其中：S\u0026rsquo; → S是识别S的初态，S\u0026rsquo; → S. 是识别S的终态. 目的是使最终构造的DFA状态集中具有唯一的初态和终态. ① closure(I)：从项目集I不经任何文法符号到达的项目全体；\n② goto(I，x)：所有从I经文法符号x能直接到达的项目全体。\n项目[S’→.S]和所有“.”不在产生式右部最左边的项目称为核心项目(kernel items)， 其它“.”在产生式右部最左边的项目(不包括[S’→.S])称为非核心项目(nonkernel items). 核心项目：J=goto(I，X)，S'→.S（作为项目集的代表） 非核心项目：closure(J)-J（特点：可由J某中某项目算得） \u0026lt;3\u0026gt; 识别活前缀\n定义3.21 若存在最右推导S’=*\u0026gt; αAω =\u0026gt; αβ1β2ω，则称项目[A→β1.β2] 对活前缀αβ1有效。 当一个项目集中同时存在： 1. A→β1.β2和B→β.：既可移进又可归约，移进/归约冲突 2.A→α.和B→β.：均可指导下一步分析，归约/归约冲突 解决方法：简单向前看一个终结符： 1. 移进/归约冲突：若FIRST(β2)∩FOLLOW(B)=Φ，冲突可解决 2. 归约/归约冲突：若FOLLOW(A)∩FOLLOW(B)=Φ，冲突可解决 若冲突可以解决，则称文法为SLR(1)文法，构造的分析表为SLR(1)分析表。 SLR(1)文法：简单向前看一个终结符即可解决冲突 ☆ 二义文法不是SLR(1)文法 第四章 静态语义分析 采用语法制导翻译生成中间代码\n1. 语法制导翻译简介 （1）语法与语义的关系\n语法是指语言的结构、即语言的“样子”； 语义是指附着于语言结构上的实际含意，即语言的“意义”. 一个语法上正确的句子，它所代表的意义并不一定正确.\n☆ 语义分析的作用\n• 检查结构正确的句子所表示的意思是否合法； • 执行规定的语义动作，如：表达式求值、符号表的查询/填写、中间代码生成等\n☆ 应用最广的 语义分析方法 是语法制导翻译，他的 基本思想 是将语言结构的语义以 属性 的形式赋予代表此结构的文法符号，而属性的计算以 语义规则 的形式赋予由文法符号组成的产生式.\n（2）属性/语义规则的定义\n定义4.1 对于产生式A→α，其中α是由文法符号X1X2...Xn组成的序列，它的语义规则可以表示为(4.1)所示关于属性的函数f： b := f(c1, c2, ..., ck) (4.1) 语义规则中的属性存在下述性质与关系： (1) 称(4.1)中属性b依赖于属性c1, c2, ..., ck。 (2) 若b是A的属性，c1, c2, ..., ck是α中文法符号的属性，或者A的其它属性，则称b是A的综合属性。 (3) 若b是α中某文法符号Xi的属性，c1, c2, ..., ck是A的属性，或者是α中其它文法符号的属性，则称b是Xi的继承属性。 (4) 若语义规则的形式如下述(4.2)，则可将其想像为产生式左部文法符号A的一个虚拟属性。属性之间的依赖关系，在虚拟属性上依然存在。 f(c1, c2, ..., ck) (4.2) ■ ☆ 继承属性从前辈和兄弟的属性计算得到,综合属性从子孙和自身的其他属性计算得到.\n即,继承属性\u0026ldquo;自上而下,包括兄弟\u0026rdquo;,综合属性\u0026ldquo;自下而上,包括自身\u0026rdquo;.\n（3）语义规则的两种形式\n☆ 语义规则的两种形式（忽略实现细节，二者作用等价）\n\u0026lt;1\u0026gt; 语法制导定义(Syntax Directed Definition)\n用抽象的属性和运算表示的语义规则；(公式，做什么) \u0026lt;2\u0026gt; 翻译方案(Translation Scheme)\n用具体的属性和运算表示的语义规则。(程序段，如何做) ☆ 继承属性是自上而下计算的，综合属性是自下而上计算的.\n（4）LR分析翻译方案的设计\n☆ LR分析中的语法制导翻译实质上是对LR语法分析的扩充：\n扩充LR分析器的功能 当执行 归约产生式的动作时，也执行相应产生式对应的 语义动作。由于是归约时执行语义动作，\n因此限制语义动作仅能放在产生式右部的 最右边；\n扩充分析栈 增加一个与 分析栈并列的 语义栈，用于存放分析栈中文法符号所对应的 属性值。\n☆ 扩充后的LR分析最适合对综合属性的计算，而对于继承属性的计算还需要进行适当的处理.\n2. 中间代码简介 ☆ 中间代码应具备的特性 1）便于语法制导翻译 2）既与机器指令的结构相近,又与具体机器无关.\n使用中间代码的好处:一是便于编译器程序的开发和移植,二是代码进行优化处理.\n☆ 中间代码的主要形式：后缀式、树、三地址码等.最基本的中间代码形式是树🌲；最常用的中间代码形式是三地址码，它的实现形式常采用四元式形式。\n☆ 符号表是帮助声明语句实现存储空间分配的重要数据结构。\n（1）后缀式\n操作数在前，操作符紧随其后，无需用括号限制运算的优先级和结合性；便于求值.\n（2）三地址码\n① 三元式 形式： (i) (op, arg1, arg2)\n三地址码：(i):= arg1 op arg2\n序号的双重含义：既代表此三元式，又代表三元式存放的结果\n存放方式：数组结构，三元式在数组中的位置由下标决定\n弱点：给代码的 优化带来困难\n② 四元式 形式： ( i ) (op，arg1，arg2，result)\n所表示的计算： result:= arg1 op arg2\n四元式与三元式的唯一区别：将由序号所表示的运算结果改为：用(临时)变量来表示。 此改变使得四元式的运算结果与其在四元式序列中的位置无关.为代码的优化提供了极大方便，因为这样可以删除或移动四元式而不会影响运算结果. ③ 树形表示\n1\u0026gt; 语法树真实反映句子结构，对语法树稍加修改（加入语义信息），即可以作为中间代码的一种形式(注释语法树) 2\u0026gt; 树的优化表示－DAG 3\u0026gt; 树与其他中间代码的关系\n☆ 树表示的中间代码与 后缀式和 三地址码之间有内在联系\n树 → 后缀式 方法：对树进行 深度优先后序遍历，得到的线性序列就是 后缀式，或者说后缀式是树的一个线性化序列；\n树 → 三元式/四元式 特点：树的每个非叶子节点和它的儿子 对应一个三元式或四元式；\n方法：对树的非叶子节点进行深度优先后序遍历，即得到一个三元式或四元式序列。\n3. 符号表简介 符号表的作用 ：连接声明与引用的桥梁，记住每个符号的相关信息，如作用域和类型等，帮助编译的各个阶段正确有效地工作。 符号表的基本目标： 有效记录信息、快速准确查找。 符号表设计的基本要求： 正确存储各类信息； 适应不同阶段的需求； 便于有效地进行查找、插入、删除和修改等操作； 空间可以动态扩充. （1）构成名字的字符串\n构成名字的字符串的存储方式： 直接存储\u0026mdash;定长数据(直接将构成名字的字符串放在符号表条目中)和间接存储\u0026mdash;变长数据(将构成名字的字符串统一存放在一个大的连续空间内，字符串与字符串之间采用特殊的分隔符隔开，符号表条目中仅存放指向该字符串首字符的指针).\n（2）名字的作用域\n☆ 程序语言范围的划分可以有两种划分范围的方式：并列和 嵌套\n☆ 名字的作用域规则： 规定一个名字在什么样的范围内应该表示什么意义.\n\u0026lt;1\u0026gt; 静态作用域规则（static-scope rule）：编译时就可以确定名字的作用域,即仅从静态读程序就可确定名字的作用域 \u0026lt;2\u0026gt; 最近嵌套规则（most closely nested）：名字的声明在离其最近的内层起作用 （3）线性表\n符号表以 栈(线性表) 的方式组织.\n线性表上的操作：查找、插入、删除、修改\n查找：从表头(栈顶)开始，遇到的第一个符合条件的名字；插入：先查找，再加入在表头（栈顶）；\n关键字 = 名字＋作用域；\n（4）散列表\n名字挂在两个链上(便于删除操作)：\n散列链(hash link)： 链接所有具有 相同hash值的元素，表头在表头数组中； 作用域链(scope link)：链接所有在 同一作用域中的元素，表头在作用域表中. ☆ 操作：查找、插入、删除\n4. 声明语句的翻译 （1）变量的声明\n☆ 一个变量的声明应该由两部分来完成：类型的定义和 变量的声明\n类型定义： 为编译器提供存储空间大小的信息 变量声明： 为变量分配存储空间 组合数据的类型定义和变量声明： 定义与声明在一起，定义与声明分离. 1\u0026gt; 简单数据类型的存储空间是预先确定的，如int可以占4个字节，double可以占8个字节，char可以占1个字节等\n2\u0026gt; 组合数据类型变量的存储空间，需要编译器根据程序员提供的信息计算而定.\n（2） 过程\n1．过程（procedure）：过程头(做什么) ＋ 过程体(怎么做)； - 函数: 有返回值的过程 - 主程序: 被操作系统调用的过程/函数 2．过程的三种形式：过程定义、过程声明和过程调用。 过程定义：过程头+过程体； 过程声明：过程头； 3. 左值与右值 1\u0026gt; 直观上，出现在赋值号左边和右边的量分别称为左值和右值； 2\u0026gt; 实质上，左值必须具有存储空间，右值可以仅是一个值，而没有存储空间. 3\u0026gt; 形象地讲，左值是容器，右值是内容. 4. 参数传递 1\u0026gt; 形参与实参 - 声明时的参数称为形参(parameter或formal parameter) - 引用时的参数称为实参(argument或actual parameter) 2\u0026gt; 常见的参数传递形式：（不同的语言提供不同的形式） - 值调用（call by value）---过程内部对参数的修改，不影响作为实参的变量原来的值. - 引用调用（call by reference）--- 过程内部对形参的修改，实质上是对实参的修改. - 复写－恢复（copy-in/copy-out）--- ① 过程内对参数的修改不直接影响实参，避免了副作用; ② 返回时将形参内容恢复给实参，实现参数值的返回. - 换名调用（call by name）--- 宏调换 3\u0026gt; 参数传递方法的本质区别： 实参是代表左值、右值、还是实参本身的正文. 5. 作用域信息的保存 ☆ 能够画出嵌套过程的嵌套关系树(P191 4.33),根据语法制导翻译(P193 4.35)画出分析树,写出推导步骤,构造的符号表 5. 简单算术表达式与赋值句 P197 例4.36 主要是变量类型的转换\n6. 数组元素的引用 （1）数组元素的地址计算\n注意是行主存储还是列主存储 （2）☆数组元素引用的语法制导翻译(考试热点之一)\nP201 例4.37 7. 布尔表达式 布尔表达式的计算有两种方法：数值表示的 直接计算和逻辑表示的 短路计算\n☆ 布尔表达式短路计算的翻译：短路计算的控制流，真出口与假出口，真出口链与假出口链，拉链回填技术(P207 例4.41)（考试热点之一）\n8. 控制语句 控制语句的分类： ①无条件转移、②条件转移、③循环语句、④分支语句\n无条件转移(goto)\\条件转移(if、while)\n条件转移的语法制导翻译：P213 例4.42\n多看课件PPT，多做题练手\n参考 简书博主 SnorlaxSE - 编译原理知识汇总 中国大学MOOC 考拉学姐 - 编译原理 《程序设计语言编译原理》 - 陈火旺，刘春林等 国防工业出版社\n","date":"2025-02-17T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-01/","title":"编译原理知识汇总-01"},{"content":"考研基本常识 考研届数 XX考研（ 研究生入学年份 ）\n报名条件 考前确定学校与专业\n报考条件 本科双证 （毕业证、学位证）（应届或毕业后均可）、专科不提\n考试时间 12月中下旬\n初试考试科目 500分 政治（马原、毛中特、习思想、史纲、思修、时政等）\t100分 外语（完形填空、阅读、翻译和写作，口语和听力部分在复试考察）100分 数学\t150分 专业课（408统考 or 自命题） 150分 复试考试科目 笔试 专业知识 面试 综合素质、专业素质（主要） 可能包括自我介绍、各类本科经历（科研、论文和项目）、英语口语听力测试、专业课程和科研知识问答 （部分情况）加试\t上机 复录比：常见 1.2 : 1 、 1.5 : 1 各类分数线 国家线 总分和单科达到一定分数才能参加复试 A类 湖南、湖北、重庆、广东、北京、上海、天津等（21） B类总分一般比A类低 10 分左右 广西、贵州、云南等（10） 院校专业线 自划线（985院校） 学硕与专硕 培养目标与毕业要求\n培养学制\n学硕 3 年（通常），专硕 2~3 年 学费\n学硕 8000/年（通常） 专硕比学硕多，部分情况差距很大 转博\n1.9 全日制与非全日制的差别 学习方式 双证区别 学费和其他支持 全日制有更多支持 考研信息源 官方信息源 中国研究生招生信息网 考研官方平台 报考院校研究生院官网 该校考研信息最直接、最权威的渠道 报考专业所在院系公众号 个性化信息和数据推送，学长学姐 非官方信息源 考研教育机构 信息二道贩子，注意信息交叉验证 社交媒体与论坛、已上岸的学长学姐 方便的一手经验 bilibili、知乎、小红书、抖音 实地考察 框框大学 考研时间线 大一大二 初步认知与目标设定 学业基础巩固 参与学术活动与社团 大三 考研目标院校与专业 最终/初步确定考研目标院校和专业 考研复习全面启动 关注考研资讯与报名准备 密切关注考研最新动态 考试大纲的发布 招生简章的更新等 及时了解目标招生院校的招生政策变化 招生人数是否变化 考试科目及参考书目是否变动等 大四 7~9月：各校陆续发布招生简章\n看考研院校\n9(10)月：考研政治，英语，数学大纲发布\n9(10)月：网上预报名\n考点选择\n10月：网上报名\n11月：网上/现场确认\n12月中旬（初试前十天）:打印准考证\n12月下旬：考研初试\n次年2月中下旬：公布初试成绩\n次年3月（上中下旬）：考研国家线，院校专业线，自划线（34所）公布\n次年3月中下旬~5月：考研复试，调剂\n次年4-6月：考研录取\n择校择专业 择校主要因素 学校综合实力 学校和学科排名、学科评估结果 学校地理位置 地区经济发展水平（实习与就业） 一/二区 招生情况 招生人数、报录比 复试分数线与复试情况 复录比 兴趣与规划 本科专业相关性 科研或对口专业 导师 / 课题组的最新科研 思考原则 跨考 院校（根据复习情况决定） 专业课考试不公布参考书目（谨慎） 招录人数少于 3 人以下（不考虑） 院校歧视，专业课压分传统（不考虑） 备考要点 备考原则 底层思维 为什么要考研 竞争对手 考前准备 考研真题 名师课程 考研博主 是否报班 具体科目 政治 大三暑假甚至 9 ~ 10 月开始都可以 使用最新资料！ 肖四肖八（肖秀荣四套卷、八套卷）是神器 外语 随时积累 词汇量积累要趁早 数学 打好基础（微积分、线性代数、概率论与数理统计） 大三越早开始越好 专业课 统考科目可以较早开始 自命题可以在择校择专业确定后开始 复试 初试后休息后就可以开始 多方求证，最重要！（上岸学长学姐） 积累有效履历 热门问题 性价比 导师选择 放养型导师 本科情况 方法论+材料 学硕与专硕对比（1.8） 考公专业推荐 查找导师信息 经验分享 参考 一个视频讲透考研的一切！时间线/信息源/初试/复试/政治/外语/数学/专业课/择校/择专业 ","date":"2025-02-15T00:00:00Z","image":"https://www.helloimg.com/i/2025/02/17/67b3141695089.png","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E8%80%83%E7%A0%94/","title":"考研-基本常识"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-02-08T00:00:00Z","image":"https://hongyun-yu.github.io/Hugo-dev/p/markdown-syntax-guide/cover_hu6307248181568134095.jpg","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"计算机网络与互联网络 什么是互联网络 从构成的角度来看： 互联网络由点和边构成。其中，点包括端系统（涵盖网络应用）以及路由器；边则是链路。简单来说，互联网络其实是网络的网络，众多不同的网络相互连接，形成了一个庞大复杂的体系。 从服务的角度来看： 互联网络是一种能够为应用提供通信服务的通信架构。在这个架构里，有连接且可靠的服务与无连接的不可靠服务相互配合，共同支撑各类应用开展通信服务。 协议：指对等层实体在通信过程中所遵循的规则的集合，这一集合可以从语法、语义及时序三个方面去理解。语法规定了数据与控制信息的结构或格式；语义说明了需要发出何种控制信息，完成何种动作以及做出何种响应；时序则明确了事件实现顺序的详细说明。 网络边缘 网络的结构： 网络整体结构分为网络边缘与网络核心两大部分，还涉及接入网络与通信链路。网络边缘包括运行应用的端系统，重点在于 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;端系统中的应用交互方式 \u0026lt;/font\u0026gt;；网络核心则由路由器组成。 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;网络边缘的应用交互方式 \u0026lt;/font\u0026gt; \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;：\u0026lt;/font\u0026gt; C/S 模式（客户端 / 服务器模式）：其特点在于，客户端向服务器发起请求，服务器响应请求并为客户端提供服务。服务器往往具备强大的处理能力与丰富的数据资源，客户端则相对轻量化，依赖服务器获取数据与执行复杂运算，常见于网页浏览、邮件收发等应用场景。 P2P 模式（对等模式）：这种模式下，各个端系统地位平等，既可以作为客户端向其他节点请求资源，也能充当服务器为其他节点提供资源。它无需依赖集中式服务器，有较强的扩展性与容错性，常用于文件共享、流媒体直播等应用。 网络的服务： 面向连接的服务：这类服务在通信前会先建立连接，整个通信过程数据传输稳定、可靠，能保证数据按序到达接收方，不过建立连接与拆除连接会带来额外开销。 无连接的服务：通信时无需事先建立连接，直接发送数据报，传输效率较高，但无法保证数据一定能可靠、有序地到达接收方。 网络核心 网络核心 组成：网络交换设备，如路由器 + 链路。 功能：数据交换。 数据交换方式及比较 分组交换：存储转发方式，统计复用。\u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;理解 \u0026lt;/font\u0026gt; VC（虚电路） Datagram（数据报） 线路交换 FDM（频分复用） TDM（时分复用） WDM（波分复用） 网络接入与物理介质 网络接入是指将端系统连接到边缘路由器的链路或网络。 住宅接入采用点到点接入方式，具体包括： ADSL（非对称数字用户线路） HFC（混合光纤同轴电缆） Cable Modem（电缆调制解调器） Home Networks（家庭网络） 机构接入：LAN 以太网 WLAN（无线网） 物理链路（第 0 层） 导向型介质（有型，光纤等） 非导向型介质（无形，电磁波、光信号等） 常用介质 TP 双绞线 同轴电缆 光纤 Radio（电磁波信号） 互联网络结构与 ISP 近似层次型结构 T - 1 ISP T - 2 ISP (Regional ISP) Local ISP ISP 之间的连接 对等连接 IXP（\u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.85);\u0026quot;\u0026gt;互联网交换点 \u0026lt;/font\u0026gt;） 内容提供商网络 在全球部署 DC（数据中心） 内容提供商网络在多处与各个 ISP 相联 内容提供商自己部署网络将全球的 DC 相联 内容提供商 DC 自己之间的访问，通过自己部署的专网 用户接入后通过离用户最近的 DC 为之服务 分组交换网络中的延迟与丢失 延迟的 4 个原因（计算）\u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt; - 掌握 \u0026lt;/font\u0026gt; 处理延迟 排队延迟 传输延迟 传播延迟 例如：n 段，分组 L，R，传播延迟 d 每段如何计算总体延迟；\n流量强度（0-1，与排队延迟正相关）：La/R \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;- 掌握 \u0026lt;/font\u0026gt; 排队延迟 依赖**\u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;流量强度的公式 \u0026lt;/font\u0026gt;**； 丢失原因： 缓冲区溢出 + 出错没通过校验 吞吐量 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt; -了解 \u0026lt;/font\u0026gt; 瞬间吞吐量 平均吞吐量 瓶颈链路决定了主机之间的吞吐量（从每段链路获得的大致带宽是 1/N，瓶颈链路是所有链路段中获得带宽最小的）。\n协议层次与服务模型 为什么要分层 网络比较复杂，分层实现比较容易设计、调试、实现。 分层：将复杂的网络功能划分成功能明确的层次，\u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;上层利用下层提供的服务来实现本层的协议，从而为上层提供更复杂的功能。\u0026lt;/font\u0026gt; 一些术语和概念 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;-理解 \u0026lt;/font\u0026gt; 服务、服务访问原语、服务访问点 面向连接的服务、无连接的服务 协议、协议数据单元 PDU 服务（垂直）和协议（水平）之间的关系（区别与联系） 服务利用了下层协议的实现，为上层提供服务 协议的实现依靠下层服务 互联网络分层模型及每一层的功能 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;-理解 \u0026lt;/font\u0026gt; 应用层 传输层 网络层（端到端，路由和转发） 链路层（点到点，帧为单位） 物理层（物理信号） 封装和解封 历史 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;-了解 \u0026lt;/font\u0026gt; ARPANET：美国军方资助的分组交换实验网，由于 TCP/IP 架构的包容性、免费使用、架构便于应用创新吸引更多的用户等原因，用户数量、节点数量和应用数量越来越多。 NSF 建立 ARPANET 的访问网。 民用网络从军用网络脱开，成为现在的互联网。 术语：IETF（互联网工程任务组）, ITU(国际电信联盟），IEEE（电气电子工程师协会 ），RFC（请求评论，是一系列关于互联网技术的文件）。\n应用层 原理 + 应用实例 + SOCKET 编程\n应用的开发只集中在端系统上，对路由器没有任何改变，这鼓励了互联网架构下的应用创新。\n网络应用原理 应用架构 C/S（客户端 / 服务器） P2P（对等网络） 混合架构 进程间通信 同主机：操作系统定义的通信方法 不同主机：利用网络提供的架构（Socket）交换报文 SOCKET 一个整数，OS 用于标示应用通信关系所采用的本地标示 **TCP：**连接的本地标示 **UDP：**端节点的本地标示 进程编址 IP + PORT（本质上在传输层应用了端口号，用于区分应用，TCP 和 UDP 使用端口号的方式不同） 应用所需要的服务需要考虑的因素（网络所提供服务的主要指标） 丢失率可靠性 延迟、延迟差（抖动） 带宽 安全性 传输层协议 TCP 提供的服务特性：可靠字节流服务，面向连接，流量控制，拥塞控制 UDP 提供的服务特性：无连接，不可靠的服务 都能够提供进程的标示，区分不同的进程\nWEB 和 HTTP WEB 应用包括 HTTP 协议 HTML CLIENT（客户端），SERVER（服务器） 术语 网页 对象 引用 URL \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;HTTP 协议 \u0026lt;/font\u0026gt; 定义了 C（客户端）和 S（服务器）之间通信的报文格式、解释和时序。 HTTP 连接 持续性连接 非持续性连接 往返延迟 RTT 和对象的抓取时间 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;HTTP 1.0 到 HTTP 1.1 再到 HTTP 2.0 的演变 \u0026lt;/font\u0026gt; HTTP 1.0 基本特点 无状态协议：每个请求都是独立的，服务器不会在不同请求之间保留状态信息。 简单的请求 - 响应模型：客户端发起请求，服务器响应请求，一次请求对应一次响应。 支持多种请求方法：如 GET、POST、HEAD 等。 局限性 连接管理效率低：每对请求 - 响应都需要建立一个新的 TCP 连接，这导致了较高的连接建立开销，特别是在请求大量小文件时。 缺乏对缓存的充分支持：缓存机制比较简单，没有很好地处理资源更新和验证的问题。 HTTP 1.1 改进之处 持久连接（Keep - Alive） 允许在一个 TCP 连接上进行多次请求 - 响应交互，减少了建立连接的开销。 客户端和服务器可以通过 Connection: keep - alive头字段来协商保持连接。 管道化（Pipelining） 允许客户端在等待第一个请求的响应时，发送第二个请求，进一步提高了性能。 增强的缓存机制 引入了更多的缓存控制头字段，如 Cache - Control、ETag和 If - Modified - Since等，使得缓存管理更加灵活和高效。 分块传输编码（Chunked Transfer Coding） 允许服务器在不知道内容长度的情况下，分块发送响应内容，适用于动态生成内容的情况。 局限性 头部信息冗余：每个请求和响应都携带完整的头部信息，在大量请求时，头部数据的传输会造成性能瓶颈。 队首阻塞（Head - of - line Blocking）：在管道化连接中，如果一个请求被阻塞，后续的请求都要等待，即使后续请求不需要依赖前面被阻塞的请求。 HTTP 2.0 主要特性 二进制分帧层（Binary Framing Layer） HTTP 2.0 将所有传输的信息分割为更小的帧，并对帧进行二进制编码。这使得协议更加紧凑和高效。 通过帧的形式，实现了在一个 TCP 连接上多路复用多个请求和响应，避免了 HTTP 1.1 中的队首阻塞问题。 头部压缩（Header Compression） 使用 HPACK 算法对头部信息进行压缩，减少了头部数据的传输量。 对于重复的头部字段，可以只传输差异部分，进一步提高了压缩效率。 服务器推送（Server Push） 服务器可以在客户端没有请求的情况下，主动向客户端推送资源。例如，当客户端请求 HTML 页面时，服务器可以同时推送页面所需的 CSS 和 JavaScript 文件，减少客户端的等待时间。 性能提升 HTTP 2.0 通过上述特性，在网络性能上有了显著提升，特别是在处理大量小资源和高并发请求时表现出色。 从 HTTP 1.0 到 HTTP 1.1 再到 HTTP 2.0，协议不断进化，旨在解决前一版本的性能瓶颈，提高网络传输效率和用户体验。\n从 SSL 到 HTTP/3.0（基于 UDP）的安全优化过程 SSL（Secure Sockets Layer，安全套接层） 基本原理 SSL 是一种早期的网络安全协议，用于在客户端和服务器之间建立加密连接，确保数据在传输过程中的保密性、完整性和身份验证。 它通过握手过程来协商加密算法、密钥交换和身份验证方法。 局限性 性能问题 SSL 的握手过程相对复杂，尤其是在早期版本中，这会导致较高的连接建立延迟。 对于每一个新的连接，都需要重新进行握手，这在高并发场景下会影响性能。 安全性逐渐减弱 随着技术的发展，SSL 的一些加密算法和协议漏洞被发现，安全性逐渐不能满足现代网络安全的需求。 TLS（Transport Layer Security，传输层安全） 与 SSL 的关系 TLS 是 SSL 的继任者，它在 SSL 的基础上进行了改进和扩展。TLS 的目标与 SSL 相同，即确保网络通信的安全，但在安全性和性能方面有了显著提升。 改进之处 增强的加密算法 TLS 采用了更强大和更安全的加密算法，如 AES（Advanced Encryption Standard）等，以应对不断出现的安全威胁。 优化的握手过程 TLS 对握手过程进行了优化，例如引入了会话恢复机制。当客户端和服务器之前已经建立过连接，在一定条件下可以复用之前的会话参数，减少握手时间。 HTTP/3.0（基于 UDP 的 QUIC 协议） QUIC（Quick UDP Internet Connections）协议 HTTP/3.0 是基于 QUIC 协议的，而 QUIC 是基于 UDP 的。QUIC 旨在解决 TCP 和 TLS 在性能和安全性方面的一些问题。 安全特性 集成加密 QUIC 将加密作为协议的核心部分，从一开始就对数据进行加密，避免了像 TCP + TLS 那样分两步进行加密的复杂性。 0 - RTT 连接建立（在某些情况下） QUIC 允许在某些条件下实现 0 - RTT（Round - Trip Time）连接建立。例如，当客户端和服务器之前已经建立过连接并且缓存了相关的加密参数时，客户端可以立即发送应用数据，无需等待握手过程完成，大大减少了连接建立延迟。 前向纠错（Forward Error Correction，FEC） QUIC 采用了 FEC 技术，通过在数据中添加冗余信息来恢复在传输过程中丢失的数据，减少了因丢包导致的数据重传，提高了传输效率和安全性。 从 SSL 到 HTTP/3.0（基于 UDP）的演变过程，是一个不断优化安全性能和网络传输效率的过程。HTTP/3.0 通过基于 UDP 的 QUIC 协议，在安全和性能方面都有了显著的提升。\n报文格式 Wireshark——抓包分析_wireshark抓包数据怎么看-CSDN博客\n请求报文 方法 响应报文 状态码 COOKIES（HTTP无状态-\u0026gt;有状态） WEB 缓存 作用：通过本地命中，减少这些对象的访问延迟；进一步减少接入链路的流量强度，从而降低派对延迟带来总体平均延迟的减少；减轻服务器的负担。 优点：通过一个实例，计算不要求。 FTP \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（不要求）\u0026lt;/font\u0026gt; 作用：在 CS 之间传输文件。 构成： C（客户端） S（服务器） FTP FTP 的连接 控制连接（带外传输） 数据连接 命令和响应 EMAIL 电子邮件应用的构成 用户代理 邮件服务器 SMTP（简单邮件传输协议） 邮件报文格式解析 报文头 报文体 MIME（多用途互联网邮件扩展）：邮件多媒体扩展，可以在邮件中编解码多媒体内容。 邮件存取协议 作用 常用 IMAP（互联网邮件访问协议） POP3（邮局协议版本 3） DNS DNS 作用 完成域名到 IP 地址的转换（还包括别名到正规名字、邮件服务器名字到正规名字转换等），是应用层面的互联网 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;基础设施 \u0026lt;/font\u0026gt;，其他应用使用。\n二、DNS 的概念 分布式、层次数据库 命名是分层的 域名信息存储和服务是分布式的，每个域名服务器担任一个区域 ZONE 的名字到 IP 地址的权威转换，也缓存名字 - IP 信息的转换。 三、DNS 的构成 解析器：本地应用 域名服务器 DNS 协议 报文：请求和应答格式相同 RR：资源记录 域名解析的过程 (解析器 -\u0026gt; 本地 DNS 服务器 -\u0026gt; 上层域名服务器 -\u0026gt;\u0026hellip;-\u0026gt; 权威名字服务器，返回)\n本地域名服务器、权限域名服务器、顶级域名服务器、根域名服务器\n递归解析：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 迭代解析：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。 DNS 缓存 作用 本地缓存 + 服务器缓存 P2P \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（了解P2P 的概念和优势即可）\u0026lt;/font\u0026gt; P2P 概念 每个对等体即是客户端又是服务器；P2P 网络是这些 peer 构成的应用层面的逻辑网络。\nP2P 网络比 C/S 方式分发内容快的原因 这些 peer 节点参与到内容的上载，流量和服务都是分布式的，可扩展性。\n典型 P2P 应用及其原理 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（不要求）\u0026lt;/font\u0026gt; Napster：知道名词 Gnutella：知道名词 KaZaA：知道名词 BT：知道名字 DHT： 视频流化服务和 CDN \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（了解）\u0026lt;/font\u0026gt; 服务器向客户端进行视频流化的方式 UDP 流化 http 流化 DASH（Dynamic, Adaptive Streaming over HTTP） DASH 流化的过程 客户端获取告示文件 客户端按照情况，向（可能是不同的）服务器请求不同视频质量的内容块，客户端智能 CDN 单个服务器，或者服务器群向客户端提供海量内容并发服务的问题：扩展性差 CDN 原理 应用层面的协作服务网络 在全网部署缓存节点，内容预先部署到 CDN 缓存节点上 用户请求通过域名解析重定向向离自己 “最近的节点” 请求内容 缓存节点放置的方式 Enter Deep Bring Home TCP 的 SOCKET 编程 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;理解 \u0026lt;/font\u0026gt; SOCKET 概念 TCP 连接的本地标示示，向这个 SOCKET 写就是发送给对方的进程；从 SOCKET 中读，就是读取对方发送过来的数据。 SOCKET API 创建 使用（读和写） 关闭 TCP SOCKET 数据传输的特点 面向连接，可靠字节流服务 TCP SOCKET 编程 建立 SOCKET 客户端 TCP 实体动作：和服务器端的 TCP 实体握手沟通。 服务器端的动作 三次握手 使用 SOCKET 关闭 SOCKET UDP 的 SOCKET 编程 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;理解 \u0026lt;/font\u0026gt; UDP SOCKET数据传输的特点 编程 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt; 不要求 \u0026lt;/font\u0026gt; 建立SOCKET（之前客户端 UDP 实体和服务器不用握手，不为之后的通信做准备） 使用 关闭 传输层 传输层服务 传输服务 能够使端系统应用之间进行逻辑通信。 传输协议：运行于端系统的 2 个对等传输层实体相互通信应该遵守的规则集合。 传输服务和网络服务的区别 网络服务：主机到主机的通信。 传输服务：进程到进程的通信。 互联网络传输层协议 TCP：有连接，可靠保序数传服务。 UDP：无连接，不可靠，不保序的数传服务。 复用与解复用 复用 源端多个上层应用收集数据：应用报文，封装报文。 解复用 接收端将数据按照端口号（结合 IP 地址）给相应的 SOCKET 对应的应用。 复用和解复用的工作原理：IP PORT TCP 有连接情况：SOCKETS 为 4 元组。 UDP 无连接情况：SOCKETS 为 2 元组。 无连接传输层协议 UDP UDP 的必要性：有些应用对实时性比较在乎，对可靠性要求不高。 UDP 报文（无连接的，因此叫做 UDP 数据报）格式。（头部 + 载荷） **UDP 报文校验和的计算（Check Sum） **\u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;理解 \u0026lt;/font\u0026gt; 可靠数据传输原理 协议演进的方式讲解如何进行 rdt 加入一些假设，简单的协议可以提供 rdt 服务。 去掉一些假设，需要协议实体做相应的变化从而能够进行 rdt。 **技术机制 ** \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt; \u0026lt;/font\u0026gt;\u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;理解 \u0026lt;/font\u0026gt; 校验和，正向确认，反向确认。 序号：检查重复。 只有正向确认的机制。 检错重发和超时重发：处理丢失。 滑动窗口 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;RDT（Reliable Data Transfer，可靠数据传输）1.0、2.0、3.0 的功能特点 \u0026lt;/font\u0026gt; 计算机网络（14）——可靠数据传输原理_rdt3.0接收方fsm-CSDN博客\nRDT 1.0 解决错误问题 基本原理 RDT 1.0 假设底层信道完全可靠，不会出现比特差错，也不会丢失分组。 在这种理想情况下，发送方只需将数据发送出去，接收方就能无误地接收到数据。 工作机制 发送方：简单地将数据发送给接收方，无需考虑数据是否丢失或损坏。 接收方：接收数据并进行处理，不需要反馈机制来确认数据是否正确接收。 RDT 2.0 解决序号 / 时序问题 基本原理 RDT 2.0 考虑到了底层信道可能出现比特差错的情况，但仍然假设分组不会丢失。 为了检测和纠正错误，引入了差错检测码（如校验和）和确认（ACK）与否认（NAK）机制。 工作机制 发送方： 发送带有差错检测码的数据分组。 等待接收方的 ACK 或 NAK 反馈。如果收到 ACK，则继续发送下一个分组；如果收到 NAK，则重发当前分组。 接收方： 接收数据分组并检查差错检测码。 如果数据无误，发送 ACK 给发送方；如果检测到错误，发送 NAK 给发送方。 RDT 3.0 解决超时 / 重复问题 基本原理 RDT 3.0 在 RDT 2.0 的基础上，进一步考虑了分组可能丢失的情况。 为了处理分组丢失问题，引入了定时器机制。 工作机制 发送方： 发送数据分组后启动定时器。 如果在定时器超时前收到 ACK，则取消定时器并发送下一个分组。 如果定时器超时，无论是否收到 NAK，都重发当前分组。 接收方： 与 RDT 2.0 类似，接收数据分组，检查差错检测码，发送 ACK 或 NAK。 如果收到重复的分组（由于发送方超时重发），仍然发送 ACK 给发送方，以避免发送方不断重发。 RDT 协议从 1.0 到 3.0 不断演进，逐步解决了可靠数据传输过程中的各种实际问题，从假设理想信道到考虑比特差错、分组丢失等情况，通过增加差错检测、确认机制、定时器等手段来确保数据的可靠传输。\n利用率计算 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt; 了解 \u0026lt;/font\u0026gt; 停止等待技术：链路带宽延迟积（容量）效率低。 管道技术：在未经对方确认的情况下，可以连续发送多个 PDU。 GBN：发送窗口大于 1，接收窗口 = 1（只能顺序接收；发送方只设置一个超时定时器，一旦出错，返回到出错的那一个 PDU 重发）。 SR：发送窗口大于 1，接收窗口大于 1（能够乱序接收；发送方为每个发送出去的 PDU 设置超时定时器，哪个超时重发哪个）。\n有连接传输层协议：TCP TCP 服务特性 点对点：可靠保序字节流；管道（在未加确认情况下一次次传多个未经确认的段）；缓冲；全双工；面向连接；流控制。 TCP 段结构 各个字段的作用。 连接建立时协商好双方的起始序号； 序号是首字节在字节流的偏移量； 确认：是对顺序收到的最后一个字节 + 1。 RTT 时间估计和重发超时时间估计 移动平均计算 平均往返延迟。 当前往返延迟采样值与平均值的偏差。 平均值 + 4 偏差。 TCP 的可靠数据传输原理 快速重传 在没有超时情况下，收到对方对于某一个段的重复三次（一共 4 个）ACK。 流量控制 流控目的 防止淹没接收方。 流控手段 将接收窗口大小捎带方式传递给发送端。 TCP 连接管理 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt; 理解 \u0026lt;/font\u0026gt; 连接建立 3 次握手技术，对双方选择的初始序号给予确认，准备好缓冲区。 第一次握手：SYN = 1，ACK = 0：发起端的序号。 第二次握手：syn = 1，ack = 1，被呼叫方的序号。 第三次握手：(syn = 0) ack = 1。 连接拆除 存在 2 军问题不完美（也不存在完美释放连接的方案，用定时器凑合解决）。 连接状态及其变迁。 拥塞控制原理 拥塞的概念 解释什么是拥塞，以及为什么会发生拥塞。 拥塞控制目的 拥塞控制手段**\u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt; 理解 \u0026lt;/font\u0026gt;** 端到端的拥塞控制：TCP 采用这种方式。 网络辅助的拥塞控制：ATM 网络标志和携带拥塞信息，反馈给主机 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（不要求）\u0026lt;/font\u0026gt;。 TCP 的拥塞控制原理 TCP 拥塞控制原理 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;（需掌握）\u0026lt;/font\u0026gt; 检测拥塞 超时（拥塞，存在误判的可能性，但概率比较低）。 三个冗余 ACK（轻微拥塞）。 拥塞控制机制 AIMD（加性增 \u0026lt;font style=\u0026quot;color:#F1A2AB;\u0026quot;\u0026gt;1 \u0026lt;/font\u0026gt;、乘性减 \u0026lt;font style=\u0026quot;color:#F1A2AB;\u0026quot;\u0026gt;半 \u0026lt;/font\u0026gt;）、慢启动 \u0026lt;font style=\u0026quot;color:#F1A2AB;\u0026quot;\u0026gt;（加倍）\u0026lt;/font\u0026gt;、超时之后的保守策略。 TCP 拥塞控制的 2 种算法 Tahoe 超时事件和 3 个冗余 ACK 处理一样的，不要求。 reno 算法 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;（需掌握）\u0026lt;/font\u0026gt; 超时事件发生和 3 个冗余 ACK 处理不一样。 平均延迟和超时定时器时间的设置 **JACSON 算法（具体初始化和迭代算法， ** \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;不要求 \u0026lt;/font\u0026gt; ） 平均往返延迟公式。 Dev 算法：第一个超时时间 = 延迟的 1/2，初值设置；后面按公式。 超时时间设置：es + 4dev。 TCP 公平性：\u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;了解 \u0026lt;/font\u0026gt; TCP 的吞吐量计算：\u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;不要求 \u0026lt;/font\u0026gt;。 网络层之数据平面 简介 网络层的主要服务和功能 服务 向传输层提供主机到主机的段传输服务。 功能 1—— 转发，数据平面功能 从路由器的一个端口流入，从另外一个端口流出。 功能 2—— 路由，控制平面的功能 决定从源到目的的路径。 两个功能相互配合将数据报从源传送到目标主机；关联是转发表、流表。 实现网络层功能的两种方式 传统方式 控制平面和数据平面功能垂直集成在每个设备上（路由器）。 控制平面功能：路由协议实体分布式地计算路由表。 数据平面的功能：IP 协议按照路由表进行分组的转发。 SDN 通用转发方式 控制平面和数据平面分离，在不同设备上实现。 SDN 控制器集中式计算、下发流表实现控制平面功能。 SDN 分组交换机按照流表对到来的分组进行转发，实现数据平面的功能。 网络层提供服务的一些重要指标 带宽 延迟、延迟差 丢包与否 丢包率 路由器结构和工作原理 路由器的 2 大功能 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（需理解）\u0026lt;/font\u0026gt; 路由协议 结果形成路由表（转发表）。 转发分组 使用转发表转发分组，交换。 构成 输入端口 线路终端实现物理层功能，链路协议实体实现链路层功能，网络层功能实现分布式分组转发。 最长前缀匹配。 交换结构 基于内存的，基于 bus 的，基于 CROSSBAR 的。 输出端口 网络层可以实现分组的调度：FIFO，RR，WFQ。 调度支持对多媒体分组等优先级分组的传输支持。 路由处理器 控制各部分协调工作。 互联网网络层协议 IP 网络提供的服务模型：尽力而为 包括含义：丢包、乱序、不可靠、（可能包括重复）。 网络层构成 协议 IP 协议、路由选择协议、ICMP 协议 转发表 IP 数据报格式 各个字段的作用 分片和重组 \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;- 掌握 \u0026lt;/font\u0026gt; 一个分组的总体大小超过了转发链路的 MTU，因此要切片。 到目标主机重组。 IP 编址 IP 地址：主机或路由器和网络接口的标识。 子网 在一个子网内的设备之间的通信有 2 个特点：1）通信无需借助路由器；2）子网前缀一样。 IP 地址分类：ABC（单步） D（多步） E（预留） 特殊 IP 地址（内网、全0、全1） 子网掩码和 CIDR **NAT ** \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;不要求 \u0026lt;/font\u0026gt; DHCP 协议：上网主机获得 IP、掩码、默认网关和 local name server。 路由聚集：连续的子网前缀的子网可达信息可以做聚集，减少向外部传输路由的数量，减少路由计算的负担。支持大概的路由聚集，与此对应的是最长前缀匹配的措施。 IPV 6： 格式（固定头部长度 40B ），地址：128 bits 变化（32-\u0026gt;128） IPV4 到 IPV6 的迁移 隧道 通用转发和 SDN SDN 方式控制平面和数据平面分离的优点 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（需理解）\u0026lt;/font\u0026gt; 集中在控制器上实现控制逻辑，网络可编程，可以实现各种复杂的网络功能、新功能（一次部署，持续升级）、方便管理。 形成开发生态（控制器、分组交换机、网络应用，在一个开放的框架下协作）。 SDN 分组交换机按照计算出的流表进行分组转发、通用、便于升级。 分组交换机工作原理 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（需理解）\u0026lt;/font\u0026gt; 模式匹配 + 行动（不仅仅是转发，还可以组播、泛洪、修改字段和阻塞等）。 进来分组，按照各级字段匹配流表，按照相应的行动动作分组。 按照优先权进行判断；之后，统计计数。 网络层之控制平面 概述 两种方式实现控制平面功能 传统方式：在每个路由器上分布式实现路由功能。 SDN 方式：在 SDN 控制器上由网络应用集中式计算、生成流表。 路由选择算法 路由目标 根据收集到的路由信息（拓扑、链路代价等）计算出源到目标较好的路径，代价比较低的路径。 主机 - 主机的路径 == 路由器到路由器的路径。 路由目标实际上是计算出节点的汇集树。 路由原则：完整正确、简单、健壮、稳定公平、最优（次优）。 路由分类 静态和动态（自适应）。 局部和全局的。 路由算法(Dijkstra, Bellman-Ford算法)_bellmanford算法和dijkstra-CSDN博客\nLS 算法（链路状态） （需掌握） 全局的路由选择算法，工作原理 每个节点收集邻居信息，生成 LS；LS 全网泛洪。 节点收集 LS 状态分组，形成网络拓扑。 按照最短路径算法算出到其他节点的最优路径。 DV 算法（距离矢量） （需掌握） 局部的路由选择算法，工作原理 每个节点维护到所有其他节点的下一跳和代价。 邻居节点之间定期交换 DV。 按照 Bellman-Ford 不断迭代生成到所有目标的代价和相应的下一跳 **层次路由 ** 理解 一个平面解决路由的问题：计算、传输和存储路由信息的量太大，不具备可扩展性，也不满足不同网络运营方不同的管理需求 分成 AS, AS 内部之间的节点路由由内部网关协议解决：AS 之间的路由，分层解决（路由到网关，由网关路由到目标网关（外部网关协议），到了目标 AS 内部，采用 AS 内部的路由解决） 优势：分层路由，解决了规模性问题，管理性问题 路由算法用于确定数据分组从源节点到目的节点的传输路径，其中静态路由与动态路由是两种重要的路由方式：\n静态路由 定义：静态路由是由网络管理员手动配置的路由信息。管理员依据网络拓扑结构，明确指定每个目的网络的下一跳路由器或出口接口。例如，在一个小型企业网中，仅有几条固定线路连接不同部门，管理员清楚各部门之间数据该如何流转，就可以手动设置静态路由。 优点： 安全性高：由于路由表是人工定制，外部攻击者较难篡改路由信息，能保障网络的基本架构安全。 低开销：不需要额外的路由协议进行路由信息交互，几乎不占用网络带宽与设备资源，适合简单网络拓扑。 可预测性强：数据传输路径固定，网络管理员能精准预估数据包走向，便于故障排查。 缺点： 缺乏灵活性：网络拓扑一旦变动，像新增节点、链路故障，静态路由无法自动调整，必须人工重新配置，在大型复杂网络里，工作量巨大。 配置繁琐：在大规模网络中，需要为众多目的网络逐个设置路由，容易出错且管理成本飙升。 动态路由 定义：动态路由依靠路由协议，让路由器之间自动交换网络拓扑和链路状态等信息，随后各自依据特定算法计算出最佳路由。常见的动态路由协议有 RIP、OSPF、BGP 等。例如，在互联网骨干网中，无数的路由器时刻在交互信息，动态更新路由表。 优点： 自适应网络变化：链路故障、网络扩容时，路由器能快速重新计算路由，保障网络畅通，无需人工干预。 配置简便：只需在路由器上启用相关路由协议，后续路由更新依靠协议自动完成，降低了管理员工作量。 缺点： 占用资源：路由协议持续交互信息，消耗网络带宽；路由器计算路由也占用自身的 CPU、内存资源。 存在安全风险：路由协议传输的信息如果被恶意篡改，会误导网络流量走向，引发网络安全事故。 静态路由和动态路由适用于不同的网络场景，简单、稳定的网络更适合静态路由，而复杂多变、规模较大的网络则要依靠动态路由来保障高效的数据传输。\n互联网的路由协议 路由协议分类 内部网关协议 IGP RIP OSPF：AS 内部支持分层路由，同时支持多种代价。 IGRP 外部网关协议 EGP BGP 网关路由器参与 AS 内部路由计算，收集 AS 内部子网可达信息 网关路由器通过 AS 间路由向其他 AS 网关通告子网可达信息。 网关路由器还转发 “过手” 子网可达信息，但是 AS 路径要加上它自己 AS 编号（防止形成环路）。 网关路由器通过 i - BGP 向 AS 内部所有路由节点通告收集到的子网可达信息。 内部路由器，通过 AS 内路由和 AS 间路由共同决定向 AS 外部子网的下一跳（内部网关协议决定如何去往网关，外部网关协议决定通过那个网关可到达 AS 外部子网）。 内部网关协议和外部网关协议的对比 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（了解）\u0026lt;/font\u0026gt; 内部网关协议重视效率，性能。 外部网关协议重视策略：经济策略和政治策略 SDN 控制平面 在控制器上集中实现控制功能。 控制器和 SDN 交换机按照 openflow等南向接口协议等下发流表，上报设备状态。 SDN 控制器按照北向接口和网络应用打交道。 ICMP 协议 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（了解）\u0026lt;/font\u0026gt; 作用：包括错误、echo请求和应答。 报文类型。 数据链路层与局域网 引论 链路层提供的服务 成帧、链路存取控制（链路访问控制）。 在相邻节点间进行可靠数据传递。 流量控制。 检错。 纠错。 全双工和半双工服务。 链路层网络节点的连接方式 点到点方式：比较适合广域。 多点连接的方式：比较适合局域、联网方便，但是需要解决 MAC 问题。 检错与纠错 检错原理 奇偶校验。 CRC（循环冗余校验）\u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt; - 掌握 \u0026lt;/font\u0026gt; 原理。 生成多项式。 冗余位计算方法以及验证方法。 多路访问协议 MAC 的必要性 MAP 信道划分 TDMA FDMA CDMA：删掉 RAP：随机访问协议 slotted ALOHA ALOHA CSMA，\u0026lt;font style=\u0026quot;background-color:#FBF5CB;\u0026quot;\u0026gt;CSMA/CD（至少 2t 长度帧），CSMA/CA \u0026lt;/font\u0026gt; 轮转协议：不要求 令牌协议 链路层编地址 MAC 地址（48位） 格式 分配 MAC 地址和网络层 IP 地址的区别 层次不同 MAC 地址平面的，用于标示一个物理网络的不同站点；IP 是可以聚集的，便于计算路由 ARP 协议 目的：物理网络范围内 IP 地址到 MAC 地址的转换 工作原理：广播查询，单播应答 以太网 IEEE802.3 标准，链路层和相应的物理层。 以太网的帧结构。 向上提供服务的特点。 无连接：以太网在传输数据时不需要事先建立连接。 不可靠：数据传输过程中不保证数据的可靠到达。 访问控制技术。 CSMA/CD \u0026lt;font style=\u0026quot;color:#DF2A3F;\u0026quot;\u0026gt;（需掌握）\u0026lt;/font\u0026gt;：载波侦听多路访问 / 冲突检测，用于解决以太网中的冲突问题。 指数后退：在发生冲突后，设备会采用指数后退算法等待一段时间后再尝试发送。 **CSMA/CA ** \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（需理解）\u0026lt;/font\u0026gt;：载波侦听多路访问 / 冲突避免，适用于无线网络。 编码。 Manchester 编码：一种常用的编码方式。 HUB 和交换机 HUB 连接方式的问题。 无法隔离冲突，在一个冲突域之中：使用 HUB 连接设备时，所有连接的设备处于同一个冲突域，容易产生冲突。 交换机的工作原理。 选择性转发：交换机可以根据目的地址有选择地转发数据。 自学习：交换机能够自动学习连接设备的 MAC 地址。 流量隔离：交换机可以隔离不同端口的流量，减少冲突。 专用接入：交换机提供专用的接入端口。 路由器和交换机的区别 \u0026lt;font style=\u0026quot;color:#74B602;\u0026quot;\u0026gt;（需理解）\u0026lt;/font\u0026gt; 参考 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程\n","date":"2025-01-22T00:00:00Z","image":"https://www.helloimg.com/i/2025/02/20/67b6e34cc4b6a.png","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E5%A4%8D%E4%B9%A0/","title":"计算机网络总复习"},{"content":"Hugo解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ├── archetypes │ └── default.md\t# hugo新建文章的默认模板 ├── config.yaml # 网站配置文件 ├── content # 站点内的内容都在这里 │ ├── categories # “分类”页面的首页 │ │ └── Test # “分类”页面下的一个具体分类页面 │ ├── page # 显示在网站主页左侧边栏菜单的选项（导航栏） │ │ ├── about # 左侧边栏菜单中的“关于”页面 │ │ ├── archives # 左侧边栏菜单中的“归档”页面 │ │ ├── links # 左侧边栏菜单中的“链接”页面 │ │ └── search # 左侧边栏菜单中的“搜索”页面 │ └── post # 用户写的帖子都放在这里，每个子文件夹对应一个帖子 │ ├── 2024 │ ├── 09 │ ├── 文章目录 │\t├── .md │\t├── .img │\t├── 10 │ ├── 文章目录 │\t├── .md ├── data ├── layouts ├── LICENSE ├── README.md ├── resources │ └── _gen │ ├── assets │ └── images ├── static # 放用户自定义字体、用户头像、网站小图标等 └── themes # 放各种主题 └── hugo-theme-stack # stack主题 ├── archetypes ├── assets ├── config.yaml ├── data ├── debug.sh ├── exampleSite ├── go.mod ├── i18n ├── images ├── layouts ├── LICENSE ├── netlify.toml ├── README.md └── theme.toml +++\n最后修改时间问题 记录hugo升级、hugo-theme-stack主题更新和修改、最后修改时间问题解决的相关内容\n","date":"0001-01-01T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/","title":""}]