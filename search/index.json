[{"content":" 编译原理-第四、五、六章-词法分析 第四章 词法分析（一） 词法分析概述 词法分析的任务 词法分析 的任务：从左至右逐个字符地对源程序进行扫描，产生一个个单词符号 词法分析器(Lexical Analyzer)又称 扫描器(Scanner) ：执行词法分析的程序 词法分析器的功能 功能：输入源程序、输出单词符号\n单词符号的种类：\n基本字 ：如begin，repeat，for，… 标识符 ：用来表示各种名字，如变量名、数组名和 过程名 常数 ：各种类型的常数 运算符 ：+，-，*，/，… 界符 ：逗号、分号、括号和空白 词法分析器的输出 输出的单词符号的表示形式： (单词种别，单词自身的值) 一个二元组\n单词种别通常用整数编码表示：\n若一个种别只有一个单词符号，则种别编码就代表该单 词符号。假定 基本字、运算符和界符 都是一符一种。 若一个种别有多个单词符号，则对于每个单词符号，给出种别 编码和自身的值 。 标识符 单列一种；标识符自身的值表示成按机器字节划分的内 部码 常数 按类型分种；常数的值则表示成标准的二进制形式 词法分析器作为一个独立子程序 词法分析作为一个独立的 阶段 ：结构简洁、清晰和条理化，有利于集中考虑词法分 析一些枝节问题 但不一定不作为单独的一 遍 ：而是将其处理为一个子程序， 由语法分析驱动词法分析 4.2 词法分析器的设计 词法分析器的结构 扫描缓冲区 这里的扫描缓冲区使用两个半区互补使用， 半区的长度即为单词的最大长度\n单词符号的识别:超前搜索 基本字 需要超前搜索才能确定哪些是基本字。 标识符 识别：字母开头的字母数字串，后跟界符或算符 常数 识别：识别出算术常数并将其转变为二进制内码表示 算符和界符 的识别：把多字符组成的算符和界符拼合成一个单词符号 几点限制——不必使用超前搜索 所有基本字都是保留字 ;用户不能用它们作自己 的标识符 基本字作为特殊的标识符来处理 ，使用保留字表 如果基本字、标识符和常数(或标号)之间没有确 定的运算符或界符作间隔，则 必须使用一个空白符作间隔 对程序编写者的一些限制也是简化词法分析程序的设计以及是程序的阅读性增加。\n状态转换图 状态转换图是一张有限方向图：\n结点 代表 状态 ，用圆圈表示 状态之间用 箭弧 连结，箭弧上的标记(字符)代表射出 结状态下可能出现的输入 字符或字符类 一张转换图只包含 有限个状态 ，其中有一个为 初态 （用双箭头表示）， 至少要有一个 终态 （用双圆圈表示） 状态转换图可用于识别(或接受)一定的字符串：\n若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所识别(接受) 词法分析器的设计示例 （理解即可） 例如这样的一个单词表对应这样的一个状态转换图：\n不含回路的分叉结点：可用一个 CASE 语句或一组 IF-THEN-ELSE 语句实现 含回路的状态结点：对应一段由 WHILE 结构和 IF 语句构成的程序 终态结点：表示识别出某种单词符号，对应 返回 语句（此处的返回值是一个二元组（种别，自身值）） 定义：\n对于其中一个分支就可以写出如下的代码：\n将状态图的代码一般化 变量 curState 用于保存现有的状态 用二维数组表示状态图：stateTrans[state][ch] 这样的一个一般化的框架就如下：\n这里的返回值要根据具体的处理过程进行细节的处理，如关键字的处理、单词的处理、标识符的处理等等。\n第五章 词法分析（二） 词法规则形式化-正规集和正规式 正规集和正规式 正规集 可以用 正规式 表示。 正规式 是表示 正规集 一种方法 一个字集合是 正规集 当且仅当它能用 正规式 表示 正规集是一类字的集合，程序语言的定义的合法单词的集合\n正规式和正规集的递归定义 对给定的字母表 Σ :\nε 和 ∅ 都是 Σ 上的正规式，它们所表示的正规集为 { ε } 和 ∅ ; 任何 a ∈ Σ ， a 是 Σ 上的正规式，它所表示的正规集为 { a } ; 假定 e1 和 e2 都是 Σ 上的正规式，它们所表示 的正规集为 L ( e1 )和 L ( e2 ) ，则 ( e1 ∣ e2 ) 为正规式，它所表示的正规集为 L ( e1 ) ∪ L ( e2 ) ( e1 · e2 ) 为正规式，它所表示的正规集为 L ( e1 ) L ( e2 ) ( e1 )*为正规式，它所表示的正规集为 ( L ( e1 ) ) * 仅由 有限次 使用上述三步骤而定义的表达式才是 Σ 上的正规式，仅由这些正规式表示的字 集才是 Σ上的正规集。\n由以上规则可得：\nε 是： 字 或 正规式 ∅ 是： 集合 或 正规式 a ( a ∈ Σ ) 是： 字符 或 字 或 正规式 正规式的等价性 若两个正规式所表示的正规集相同，则称这两 个正规式等价。如 b ( ab )* = ( ba )* b\n证明：\n利用正规式与正规集的对应关系，证明 ( a* b* ) * = ( a ∣ b )* = ( a* ∣ b* )* ：可以看出每一个正规式表示的都是由 ab组成的所有串的集合，所以是等价的\n正规式的性质 对正规式，下列等价成立：\ne1 ∣ e2 = e2 ∣ e1 交换律 e1 ∣ ( e2 ∣ e3 ) = ( e1 ∣ e2 ) ∣ e 3 结合律 e1 ( e2 e3 ) = ( e1 e2 ) e3 结合律 e1 ( e2 ∣ e3 ) = e1 e2 ∣ e1 e3 分配律 ( e2 ∣ e3 ) e1 = e2 e1 ∣ e3 e1 分配律 e ε = ε e = e **注意乘么的交换律 e1 e2 \u0026lt; \u0026gt; e2 e1 ** 证明过程：转化为集合运算来证明即可\n5.2 确定有限自动机(DFA) 对状态图进行形式化定义 确定有限自动机(DeterministicFiniteAutomata， DFA) M M M 是一个五元式 M = ( S , Σ , f , S0 , F ) , 其中：\nS :有穷 状态集 Σ ：输入 字母表 (有穷) f : 状态转换函数 ，为 S × Σ → S 的 单值部分映射 ， f ( s ， a ) = s ′ 表示：当现行状态为 s ，输入字符为 a 时，将状态转换到下一状态 s′ ，s′ 称为 s 的一个后继状态 S0 ∈ S 是唯一 的一个 初态 F ⊆ S ：终态集(可空) DFA表示为状态转换图 假定 DFA M 含有 m个状态 和 n个输入字符 ，则对应的状态转换图含有 m个状态结点 ，每个结点顶多含有 n条箭弧射出 ，且每条箭弧用 Σ 上的不同的输 入字符来作标记\nDFA识别字符串的定义 对于 Σ* 中的任何字 α ，若存在一条从初态到某一 终态的道路，且这条路上所有弧上的标记符连接成的字等于 α ，则称 α 为 DFA M 所 识别(接收) DFA M 所识别的字的全体记为 L ( M ) 例如一个识别以 00 结尾的字符串的DFA：\n将DFA中的各个状态函数写成矩阵的形式，也就是状态矩阵，这样就可以利用前面的词法分析程序：\n非确定有限自动机（NFA） 非确定有限自动机（NFA）的定义 一个简单的NFA状态图：\n（大部分定义与DFA一致）\n一个 非确定有限自动机 (Nondeterministic Finite Automata，NFA) M 是一个五元式 M = ( S , Σ , f , S0 , F ) ，其中：\nS :有穷 状态集 Σ ：输入 字母表 (有穷) f : 状态转换函数，为 S × Σ∗ → 2S 的部分映射。这里的 2S 指的是 S 的幂级，即 S 所有的子集的集合，这样就表明从一个状态出发可能有多个不同的状态，体现非确定这一特点 S0 ⊆ S 是非空的 初态集 ，这里与 DFA 不同，DFA处的 S0 的定义是 属于 某个状态集合，而这里是某一 些 集合作为自动机的初态，这也体现着非确定这一特点 F ⊆ S：终态集 (可空) （理解：可以将自动机看作一幅图（网络），每个节点代表一种状态，边权为符合某一值时表示联通， DFA 每个节点出发的边的限制条件不同，且为字符限制，而 NFA 的每一个节点出发的边的限制条件可以相同，即多个通路，而且是字符串的限制，并且前者仅有一个源点，后者可以有多个源点 ）\n从状态图看NFA和DFA的区别 NFA 可以有多个 初态 弧上的标记可以是 Σ* 中的一个 字 (甚至可以是一个 正规式 )，而不 一定是单个字符 同一个字 可能出现在同状态射出的 多条弧 上 DFA是NFA的特例\nNFA识别字符串的定义 对于 Σ* 中的任何字 α ，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记字连 接成的字等于 α (忽略那些标记为 ε 的弧)，则称 α 为 NFA M 所 识别(接收) NFA M 所识别的字的全体记为 L ( M ) 一个识别含有aa或bb的字符串的NFA：\n可以看出左图的DFA也可以完成相同的功能；\n一个识别特定语言的NFA：\nDFA和NFA 定义：对于任何两个有限自动机 M 和 M′ ，如果 L ( M ) = L ( M′ ) ，则称 M 与 M′ 等价 自动机理论中一个重要的结论：判定两个自动机等价性的算法是存在的 对于每个 NFA M 存在一个 DFA M′ ，使得 L ( M ) = L ( M′ ) DFA与NFA识别能力相同! （如上面的那个识别含有aa或bb字符串的自动机） 第六章 词法分析（三） 有限自动机的等价性 DFA与NFA的等价性 对于每个NFA M 存在一个DFA M′，使得 L ( M ) = L ( M ′ ) ，包括： 等价性证明 和 NFA的确定化\n可以从 **NFA 和DFA的差别 ** 入手：\n所以只要消除差别就可以实现两者的转化，也就是等价\nDFA与NFA的等价性证明 等价性证明 假定NFA M = \u0026lt; S , Σ , δ , S 0 , F \u0026gt; M=\u0026lt;S, Σ, δ, S_0, F\u0026gt; M=\u0026lt;S,Σ,δ,S0​,F\u0026gt; ，我们对M的状态转换图进行以下改造：\n引进新的初态结点 X X X 和终态结点 Y Y Y ， X , Y ∉ S X,Y∉S X,Y∈/​S ，从 X X X 到 S 0 S_0 S0​ 中任意状态结点连一条 ε ε ε 箭弧，从 F F F 中任意状态结点连一条 ε ε ε 箭弧到 Y Y Y （类似一个超级源点和超级汇点） 。 (解决初始状态唯一性) 对M的状态转换图进一步施行替换，其中k是新引入的状态。 (简化弧上的标记) 。 例如拆分的替代：\n对于我们现在的这个NFA：\n逐步把这个图转变为每条弧只标记为 Σ Σ Σ 上的一个字符或 ε ε ε ，后得到一个NFA M ′ M\u0026rsquo; M′ ，显然 L ( M ′ ) = L ( M ) L(M\u0026rsquo;)=L(M) L(M′)=L(M)\nNFA的确定化-子集法(解决ε弧和转换关系) ε − c l o s u r e ( I ) ε-closure(I) ε−closure(I) 的定义 设 I I I 是的状态集的一个子集，定义 I I I 的 ε − 闭 包 ε-闭包 ε−闭包 ε − c l o s u r e ( I ) ε-closure(I) ε−closure(I) 为:\n若 s ∈ I s∈I s∈I ，则 s ∈ ε − c l o s u r e ( I ) s∈ε-closure(I) s∈ε−closure(I) ； 若 s ∈ I s∈I s∈I ，则从s出发经过任意条ε弧而能到达的任何状态 s ′ s\u0026rsquo; s′ 都属于 ε − c l o s u r e ( I ) ε-closure(I) ε−closure(I) 即， ε − c l o s u r e ( I ) = I ∪ { s ′ ∣ 从 某 个 s ∈ I 出 发 经 过 任 意 条 ε 弧 能 到 达 s ′ } ε-closure(I)=I∪\\{s\u0026rsquo;|从某个s∈I出发经过任意条ε 弧能到达s\u0026rsquo;\\} ε−closure(I)=I∪{s′∣从某个s∈I出发经过任意条ε弧能到达s′}\nI a = ε − c l o s u r e ( J ) I_a= ε-closure(J) Ia​=ε−closure(J) 的定义 设a是Σ中的一个字符，定义 I a = ε − c l o s u r e ( J ) I_a= ε-closure(J) Ia​=ε−closure(J) 其中，J为I中的某个状态出发经过一条a弧而到达的状态集合。 eg:\nNFA的确定化 确定化：不失一般性，设字母表只 包含两个a 和b，我们构造一张计 算状态集的转换表:\n首先，置第1行第1列为εclosure({X})求出这一列的Ia，Ib； 然后，检查这两个Ia，Ib，看它 们是否已在表中的第一列中出 现，把未曾出现的填入后面的 空行的第1列上，求出每行第2， 3列上的集合… 重复上述过程，直到所有第2， 3列子集全部出现在第一列为止 注意，这里如果右边出现空集，左边I这列也要计算空集；此外，因为是有限自动机，故左边的计算出的项最多有 2 n 2^n 2n 个，所以一定会计算完\n例如：对于上面的 NFA M’ 的计算结果就是如下：\n把表看成状态转换矩阵，子集视为状态 转换表唯一刻划了一个确定 的有限自动机M，其中：初态是ε-closure({X}) 、终态是含有原终态Y的子集 并将集合进行一定的标号，即可得到一个新的状态转移矩阵，同样可以得到一个新的状态转换图：\n而这个状态转换图对应的显然是一个 DFA，不难看出，这个DFA M与M’ 等价 ，对于每个NFA M存在一个 DFA M’ ，使得L(M)=L(M’) ，也就是说，NFA和DFA等价 确定有限自动机的化简 DFA的化简(最小化) ：对于给定的DFA M，寻找一个状态数比M少的DFA M’，使得L(M)=L(M’) 状态的等价性： 假设s和t为M的两个状态，称s和t等价：如果从状态 s出发能读出某个字α而停止于终态，那么同样，从t 出发也能读出α而停止于终态；反之亦然 两个状态不等价，则称它们是可区别的 两个状态不等价是指： 存在一个字α ，要么s读出α停止于终态而t读出 α停止于非终态，要么t读出α停止于终态而s读 出α停止于非终态 化简的基本思想：把M的状态集划分为一些 不相交的子集 ，使得任何 两个不同子集的状态是可区别的 ，而 同一子集的任何两个状态是等价的 ，最后，让每个子集选出一个代表，同时消去其他状态。所以，对DFA的状态集合S进行第一次划分是 终态 和 非终态 。 化简的方法 首先，把S划分为 终态 和 非终态 两个子集，形成 基本划分 Π Π Π 。\n假定到某个时候， Π Π Π 已含 m m m 个子集，记为 Π = { I ( 1 ) ， I ( 2 ) ， … ， I ( m ) } Π=\\{I^{(1)}， I^{(2)}，…，I^{(m)}\\} Π={I(1)，I(2)，…，I(m)} ，检查 Π Π Π 中的每个子集看是否能进 一步划分： 对某个 I ( i ) I^{(i)} I(i) ，令 I ( i ) = { s 1 , s 2 , … , s k } I^{(i)}=\\{s_1,s_2, …,s_k\\} I(i)={s1​,s2​,…,sk​} ，若存在一个输入字符 a a a 使得 I a ( i ) I_a^{(i)} Ia(i)​ 不会包含在现行 Π Π Π 的某个子集 I ( j ) I^{(j)} I(j) 中，则至少应把 I ( i ) I^{(i)} I(i) 分为 两个部分。\n假定状态 s 1 s_1 s1​ 和 s 2 s_2 s2​ 是 I ( i ) = { s 1 , s 2 , … , s k } I^{(i)}=\\{s_1,s_2, …,s_k\\} I(i)={s1​,s2​,…,sk​} 中的两个状态， 它们经 a a a 弧分别到达 t 1 t_1 t1​ 和 t 2 t_2 t2​ ，而 t 1 t_1 t1​ 和 t 2 t_2 t2​ 属于现行 Π Π Π 中的两个不同子集（看图理解）\n说明有一个字 α α α ， t 1 t_1 t1​ 读出 α α α 后到达终态，而 t 2 t_2 t2​ 读出 α α α 后 不能到达终态，或者反之 那么对于字 a α aα aα ， s 1 s_1 s1​ 读出 a α aα aα 后到达终态，而 s 2 s_2 s2​ 读出 a α aα aα 不能到达终态，或者反之 所以 s 1 s_1 s1​ 和 s 2 s_2 s2​ 不等价 将 I ( i ) I^{(i)} I(i) 分成两半，一半含有 s 1 s_1 s1​ ，一半含有 s 2 s_2 s2​\nI ( i 1 ) I^{(i1)} I(i1) 含有 s 1 s_1 s1​ : I ( i 1 ) = { s ∣ s ∈ I ( i ) } I^{(i1)}=\\{s|s∈I^{(i)}\\} I(i1)={s∣s∈I(i)} 且s经a弧到达t, 且t与 t 1 t_1 t1​ 属于现行 Π Π Π 中的同一子集} I ( i 2 ) I^{(i2)} I(i2) 含有 s 2 s_2 s2​ : I ( i 2 ) = I ( i ) − I ( i 1 ) I^{(i2)}=I^{(i)}-I^{(i1)} I(i2)=I(i)−I(i1) 一般地，对某个 a a a 和 I ( i ) I^{(i)} I(i) ，若 I a ( i ) I_a^{(i)} Ia(i)​ 落入现行 Π Π Π 中N 个不同子集，则应把 I ( i ) I^{(i)} I(i) 划分成N个不相交的组， 使得每个组 J J J 的 J a J_a Ja​ 都落入的 Π Π Π 同一子集。\n重复上述过程，直到 Π Π Π 所含子集数不再增长\n对于上述后划分 Π Π Π 中的每个子集，我们选取 每个子集 I I I 中的一个状态代表其他状态，则可得 到化简后的DFA M ′ M\u0026rsquo; M′\n若 I I I 含有原来的 初态 ，则其代表为 新的初态 ，若 I I I 含有原来的 终态 ，则其代表为 新的终态 。\neg: 我们对上面的那个 DFA M’ 进行不断的化简，首先分成两个集合：终态和非终态集合： I ( 1 ) 和 I ( 2 ) I^{(1)} 和 I^{(2)} I(1)和I(2) ，对他们求子集。。。。（红蓝两色即为分解中出现某个集合出现在多个状态集中，需要分解的过程）：\n对最后化解后的集合重新标号，可以得到一个化解后的状态转换图：\n6.2 正规式与有限自动机的等价性 上面一节证明了 有限自动机间的等价性，表明 DFA 和 NFA 是可以相互转化的，其识别的字是相同的，而 NFA 对于设计人员来说更加友好，因为不用对转换关系考虑的更加细致，易于设计；而 DFA 对开发词法分析程序更加友好，因为更加的简单，清晰，这样我们可以由语言的 单词正规集 得到 正规式， 然后设计处 NFA ，最后利用 有限自动机的等价性来实现 NFA 向 DFA 的转化和化解，从而设计出此法分析程序。（也就是这个图)\n这节证明正规式与有限自动机之间的等价性。\n正规式与有限自动机的等价性（结论） 一个正规式r与一个有限自动机M等价： L ( r ) = L ( M ) L(r)=L(M) L(r)=L(M) FA -\u0026gt;正规式 ：对任何FA M，都存在一个正规式r，使得 L ( r ) = L ( M ) L(r)=L(M) L(r)=L(M) 。 正规式-\u0026gt; FA ：对任何正规式r，都存在一个FA M，使得 L ( M ) = L ( r ) L(M)=L(r) L(M)=L(r)。 为NFA构造正规式 对转换图概念拓广，令每条弧可用一个正规式作标记。\n证明 ：对 Σ Σ Σ 上任一NFA M M M ，都存在一个 Σ Σ Σ 上的 规式 r r r ，使得 L ( r ) = L ( M ) L(r)=L(M) L(r)=L(M) 。\n假定NFA M = \u0026lt; S , Σ , δ , S 0 , F \u0026gt; M=\u0026lt;S, Σ, δ, S_0, F\u0026gt; M=\u0026lt;S,Σ,δ,S0​,F\u0026gt;，我们对M的状 态转换图进行以下改造：\n在M的转换图上加进两个状态X和Y，从X用ε弧连接 到M的所有初态结点，从M的所有终态结点用ε弧连 接到Y，从而形成一个新的NFA，记为 M ’ M’ M’ ，它只有一 个初态X和一个终态Y，显然 L ( M ) = L ( M ’ ) L(M)=L(M’) L(M)=L(M’) 。 然后，反复使用下面的三条规则，逐步消去结点， 直到只剩下X和Y为止。 最后，X到Y的弧上标记的正规式即为所构造的 正规式r，显然 L ( r ) = L ( M ’ ) = L ( M ) L(r)=L(M’)=L(M) L(r)=L(M’)=L(M) ，得证：对 Σ Σ Σ 上任一NFA M M M ，都存在一个 Σ Σ Σ 上的正规式 r r r ，使得 L ( r ) = L ( M ) L(r)=L(M) L(r)=L(M) 。 为正规式构造NFA 定理：对任何正规式r，都存在一个FA M，使 得 L ( M ) = L ( r ) L(M)=L(r) L(M)=L(r) 。 定理: 对于 Σ Σ Σ 上的正规式r，都存在一个NFA M， 使 L ( M ) = L ( r ) L(M)=L(r) L(M)=L(r) ，并且M只有一个初态和一个终态， 而且没有从终态出发的箭弧。 证明： 对给定正规式r中的运算符数目进行归纳 * 验证r中的运算符数目为0时，结论成立。 * 假设结论对于运算符数目少于k(k≥1)的正规式成立 * 基于该假设，证明结论对于运算符数目为k的正规式 成立。 正规式向NFA的转化过程 上述证明过程实质上是一个将 正规表达式 转换为 有限自动机 的算法 ，如构造 Σ Σ Σ 上的NFA M ’ M’ M’ 使得 L ( r ) = L ( M ’ ) L(r)=L(M’) L(r)=L(M’) 首先，把r表示成一个初态为X、终态为Y并且转换条件是r的 NFA 然后按照如下规则不断地对 r 进行分裂 （就是上面 NFA向r转换的三条规则的逆过程） 逐步把这个图转变为每条弧只标记为 Σ Σ Σ 上的一个字符或 ε ε ε ，最后得到一个NFA M ’ M’ M’ ，显然 L ( M ’ ) = L ( r ) L(M’)=L(r) L(M’)=L(r) eg: 例如上面一直使用的一个 NFA/DFA 用 正规式r表示的情况：\n当我们得到一个想要的字的正规式r时，就可以将正规式转化为一个NFA，然后利用上一讲6.1的有限自动机的转化就可以将一个NFA利用子集法转化为一个DFA并化解，这样我们就清楚了整个词法分析程序生成的主要过程的理论。\n6.3 词法分析程序自动生成–LEX 利用LEX设计词法分析程序的整个流程如下\nLEX的源文件格式包括：辅助定义（紫色）和识别规则（正规式+一小段的程序代码）（蓝色）\nLEX的工作过程：\n下面的流程图就是词法分析的大致流程。每个箭头之间的内部转化一次证明都已经在前面几章、讲介绍了。\n习题 这14题我看傻了，，，\n(end)\n参考 学习所用，转自CSDN 《程序设计语言编译原理》 ","date":"2025-03-19T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","title":"编译原理-词法分析"},{"content":" 编译原理-第一章-第三章 第一章 引论 课程内容： 介绍程序设计语言 编译程序构造 的 基本原理 和 基本实现技术 。\n什么是编译程序 翻译程序(Translator) 把某一种语言程序（称为 源语言程序） 等价 的转换成另一种语言程序（称为 目标语言程序） 的程序。\n编译程序(Complier) 把某一种 高级语言程序 等价的转化成另一种 低级语言程序 （如汇编语言或机器语言程序）的程序。\n编译程序可分为： 诊断编译程序、优化编译程序、交叉编译程序、可变目标编译程序 。\n解释程序(Interpretor) 把 源语言 写的源程序作为输入，但不产生目标 程序，而是 边解释边执行 源程序。\n为什么学习编译原理 从计算机科学与技术可以学到什么： 理解计算系统 设计计算系统 训练计算思维(Computational Thinking) 计算思维是什么： 计算思维是运用计算集科学的基础概念去求解问题，设计系统和理解人类行为。\n计算思维的广泛方法： 抽象、自动化、问题分解、递归、权衡、保护、冗余、容错、纠错、和恢复、启发式等等。\n编译过程 编译程序工作的五个阶段： 词法分析 、 语法分析 、 中间代码生成 、 优化 、 目标代码产生 。\n词法分析 任务: 输入源程序，对构成源程序的字符串进行 扫描和分解，识别出单词符号 依循的原则：构词规则 描述工具：有限自动机 和 正规式 语法分析 任务：在词法分析的基础上，根据语法规则把 单词符号串分解成各类 语法单位(语法范畴) 依循的原则：语法规则 描述工具：上下文无关文法 中间代码产生 任务：对各类语法单位按语言的语义进行初步翻译 依循的原则：语义规则 描述工具：属性文法 中间代码：三元式，四元式，树，... 优化 任务：对前阶段产生的中间代码进行加工变换， 以期在最后阶段产生更高效的目标代码 依循的原则：程序的等价变换规则 目标代码产生 任务: 把中间代码变换成特定机器上的目标代码 依赖于硬件系统结构和机器指令的含义 目标代码三种形式\n汇编指令代码: 需要进行汇编 绝对指令代码: 可直接运行 可重新定位指令代码: 需要连接 可以直接运行的目标代码是绝对指令代码。\n编译程序的结构 编译程序总框 出错处理 出错处理程序：发现源程序中的错误，把有关错误信息报告给用户 语法错误： 源程序中不符合语法（或词法）规则的错误；非法字符、括号不匹配、缺少… 语义错误： 源程序中不符合语义规则的错误 ；说明错误、作用域错误、类型不一致… 遍(pass) 遍： 对源程序或源程序的中间表示 从头到尾扫描一次\n阶段与遍是不同的概念\n一遍可以由若干段组成（词法+语法+语义） 一个阶段也可以分若干遍来完成（优化） 编译前端与后端 编译前端：与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化\n编译后端：与目标机有关，与目标机有关的优化，目标代码产生\n带来的好处\n程序逻辑结构清晰 优化更充分，有利于移植 编译程序生成 以汇编语言和机器语言为工具 优点: 可以针对具体的机器，充分发挥计算机的系统功能；生成的程序效率高 缺点: 程序难读、难写、易出错、难维护、生产的效率低 高级语言书写 一个高级语言编写的编译器： 利用已有的某种语言的编译程序实现另一语言的编译程序 ​\tP1 是一个可以在 A 机器上运行的编译程序（类似 gcc.exe ）即 L1ToA.A ，可以将一个 L1 语言的代码编译成一个可以在 A 上运行的程序\n​\t这时我们用 L1 语言写一个编译 L2 语言的编译器 P2 ，即 L2ToA.L1 为了能够在 A 机器上运行，所以我们需要上面的编译器来编译这个代码，得到 L2ToA.A 这样就得到了一个 L2 语言的编译器（例如我们用 C++ 语言编写一个 Python 的编译器 python.cpp ，然后用 g++.exe 编译链接得到一个可以运行的 Python 的编译器 python.exe ）\n移植方法：把一种机器上的编译程序移植到另一种机器上 ​\t例如现在有一个在A平台（例如Windows）下的L语言（例如c++)的编译器，要移植这个编译器到B平台（Linux）下，我们拥有A平台下的一个L语言的编译器（例如g++.exe）即 LToA.A ，我们可以用L语言写一个针对B平台下的L语言的编译器（例如Linux中的g++.cpp）即 LToB.L ，在A平台下编译即可得到一个在A平台下运行并可以编译出在B平台的下运行的L语言的编译器(P2: LToB.A)，然后再用这个A平台下的编译器编译我们的代码（ LToB.L）就可以得到一个在B平台下运行的编译器 LToB.B\n打个比方：\n我们用c++ 编写一个 g++ForLinux.cpp 然后用 g++.exe 编译，得到 g++ForLinux.exe 然后用 g++ForLinux.exe 编译 g++ForLinux.cpp 就可以得到在Linux下运行的 g++ForLinux c++编译器了。\n自编译方式 就是编写L的编译器就用L的一小部分 L 1 L_1 L1​ 写一个编译器，然后编译 L 1 + L 2 L_1 + L_2 L1​+L2​ 得到一个较大的编译器，这样不断的重复下去，利用语言自己来写完整的编译器。\n编译程序自动产生 编译程序-编译程序，编译程序产生器，编译程序书 写系统\nLEX：词法分析程序产生器\nYACC：语法分析程序产生器\n第二章 高级程序设计语言概述 常用的高级程序设计语言 高级程序设计语言的优点 相对机器语言或汇编语言，高级程序设计语言\n更接近于数学语言和工程语言，更直观、自然和易 于理解 更容易验证其正确性、改错 编写程序的效率更高 更容易移植 程序设计语言的定义 标识符是语法概念，名字是语义概念\n程序语言的定义： **语法 、语义 **\n语法 程序本质上是一定字符集上的字符串\n语法 ：一组规则，用它可以形成和产生一个 合式(well-formed) 的程序。\n词法规则 ：单词符号的形成规则。\n单词符号是语言中具有独立意义的最基本结构 一般包括：常数、标识符、基本字、算符、界符等 描述工具：有限自动机 语法规则 ：语法单位的形成规则。\n语法单位通常包括：表达式、语句、分程序、过程、 函数、程序等; 描述工具：上下文无关文法 语法规则 和 词法规则 定义了程序的形式结构。\n定义语法单位的意义属于 语义 问题。\n语义 语义 ：一组规则，用它可以定义一个程序的意义 。\n描述方法 ：\n自然语言描述：二义性、隐藏错误和不完整性 形式描述： 操作语义 、指称语义 、代数语义 程序语言的基本功能和层次结构 程序，本质上说是描述一定数据的处理过程 。\n程序语言的基本功能 ： 描述数据 和 对数据的运算 。\n程序的层次结构 程序语言成分的逻辑和实现意义 抽象的逻辑的意义：数学意义 计算机实现的意义：具体实现 第三章 高级程序设计语言的语法描述 上下文无关文法 文法 文法 ：描述语言的语法结构的形式规则。\n以英文句子： He gave me a book 举例：\n语法描述的几个基本概念 有穷 字母表（字符集） Σ 中每一个元素称为一个字符 Σ 上的字（也叫字符串） 是指由 Σ 中的 字符所构成的一个有穷序列 空字 ε ：不包含任何字符的序列 Σ* ：表示 Σ 上的所有字的全体，包含空字 ε 例如: 设 ∑ = { a , b } ，则 Σ* = { ϵ , a , b , a a , a b , b a , b b , a a a , . . . }\nΣ* 的子集 U 和 V 的**连接（积）**定义为 UV = { αβ| α∈U , β∈V } V*：闭包 V+：正规闭包 eg: 设 U = { α , α α } ，显然 ：\nU*= { ϵ , a , a a , a a a , a a a a , … }\nU+ = { a , a a , a a a , a a a a , … }\n闭包与正规闭包的区别： V 若无空字， V* 中有空字，而 V+ 无空字。\n上下文无关文法 上下文无关文法 G 是一个四元组 G = ( VT ，VN, S ，P ) ，其中:\nVT：终结符(Terminal)集合 ( 非空 ) VN：非终结符(Noterminal) 集合 ( 非空 ) ，且 VT ⋂ VN = ∅ S：文法的 开始符号， S ∈ VN P：产生式 集合(有限)，每个产生式形式为 P 定 义 为 P→ α , P ∈ VN , α ∈ ( VT ⋃ VN ) * 开始符 S 至少必须在某个产生式的左部出现一次 eg: 定义只含 +, ∗ 的算术表达式的文法 G = \u0026lt; { i , + , ∗ , ( , ) } ， { E } ， E ， P \u0026gt; ，其中，P 由下列产生式组成：\nE → i E → E + E E → E ∗ E E → ( E ) 巴科斯范式（BNF） “ → ” 用 “ : : =” 表示。 约定 { P → α1 P → α2 … p → αn } 可 缩 写 为 ⟹ P → α1 ∣ α2 ∣ ⋯ ∣ αn , 其中 “ ∣ ” 读成 ”或“ ，称 α i为 P 的一个候选式， 故给出一个文法时将只给出 开始符号 和 产生式 , 如图： G ( E ) 里的 E 是指开始符号。\n3.2 文法与语言 推导 定义： 称 αAβ 直接推出 αγβ，即 αAβ ⟹ αγβ , 仅当 A → γ 是一个产生式，且α，β∈(VT ∪ VN)* 。\n如果 α1 ⟹ α2 ⟹ ⋯ ⟹ αn ，则我们称这个序列是 从 α1 到 αn 的一个 推导 。若存在一个从 α1 到 αn 的 推导，则称 α1 可以推导出 αn 。\n对文法 G ( E ) ： E → i ∣ E + E ∣ E ∗ E ∣ ( E )\nE ⟹ ( E ) ⟹ ( E + E ) ⟹ ( i + E ) ⟹ E ( i + i )\n句型、句子和语言 我们定义：α1 =∗⇒ αn , α1 出发，经过 0 步或若干步推出 αn ;\nα1 =+⇒ αn , α1 出发，经过 1 步或若干步推出 αn 。\n因此， α =∗⇒ β 即为 α = β 以及 α =+⇒ β (这里的 + 、* 都是在 ⇒ 的上面）\n由以上定义可以得出句型、句子和语言的定义：\n假定G是一个文法，S 是它的开始符号。\n如果 S=∗⇒ α，则称 α 是一个 句型 仅含终结符号的句型是一个 句子。 文法G所产生的句子的全体是一个 语言，记为 L ( G ) : L ( G ) = { α ∣ S =+⇒ α , α ∈ V T ∗ } 句型和句子练习 代换思想：\n从文法到语言 给定文法判断所产生的语言是什么，其实就是一个递归的思想：\n从语言到文法 请给出产生语言为 { an bn ∣ n ≥ 1 } 的文法:\nG 3 ( S ) ：\nS → a S b S → a b 3.3 语法树与二义性 推导与语法树 左推导和右推导 从一个句型到另一个句型的推导往往不唯一，从推导的方向看有两种：\n最左推导：任何一步 α ⇒ β 都是对 α 中的中的 左非终结符 进行替换 最右推导 ( 规范推导 ) ：任何一步 α ⇒ β 都是对 α 中的中的右非终结符进行替换 语法树 用一张图表示一个句型的推导, 称为 语法树 一棵语法树是不同推导过程的共性抽象 注意：\n树中间，父子结点 可以同名 语法树不反应结点的产生先后顺序，只反映语法符号的定义或者说是构成关系 二义性(ambiguity) 文法的二义性 ：如果一个 文法 存在 某个句子 对应 两棵不同的语法树 ，则说这个文法是二义的 G ( E ) ： E → i ∣ E + E ∣ E ∗ E ∣ ( E ) 是二义文法 语言的二义性 ：一个语言是二义的，如果（那么） 对它不存在无二义的文法 。对于语言L，可能存在G和G’，使得 L ( G ) = L ( G ’ ) = L ，有可能其中一个文法为二义的， 另一个为无二义的 二义性问题是 不可判定问题 ，即不存在一个算法，它能在有限步骤内，确切地判定一个文法\n对于是否是二义的 ，可以找到一组无二义文法的充分条件\n3.4 形式语言鸟瞰 乔姆斯基于1956年建立形式语言体系，他把文 法分成四种类型：0，1，2，3型 。\n0型(短语文法，图灵机)：产生式形如： α → β ，其中： α ∈ ( VT ∪ VN ) * 且 至少含有一个非终结符 ; β ∈ ( VT ∪ VN ) * 1型(上下文有关文法，线性界限自动机) ：产生式形如： α → β ，其中： ∣ α ∣ ≤ ∣ β ∣ ，仅 S → ε 例外 2型(上下文无关文法，非确定下推自动机) ： 产生式形如： A → β , 其中： A ∈ VN ； β ∈ ( VT ∪ VN ) * （可以利用栈分析） 3型(正规文法，有限自动机)： 产生式形如： A → αB 或 A → α （右线性文法）其中：α∈VT*；A，B∈VN ；（左线性文法：产生式形如： A → Bα 或 A → α ） 四种类型文法描述能力比较 上下文无关文法 （自嵌套语言仅能由上下文无关文法产生)\n上下文有关文法 0型语言 程序设计语言不是上下文无关语言，甚至不是上下文有关语言，只能由0型语言产生，如：\n对于无法利用上下文无关法分析的部分一般交由语义分析处理。\n习题 课后习题，题干和过程引用网上的资料了\n（end)\n参考 学习所用，转自CSDN pi31415926535x 《高级程序设计语言编译原理》 ","date":"2025-03-19T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%AF%BC%E5%AD%A6/","title":"编译原理-导学"},{"content":"编译原理-属性文法和语法制导翻译 属性文法和语法制导翻译1 属性文法 属性文法,也称属性翻译文法 Knuth在1968年提出 以上下文无关文法为基础 为每个文法符号（终结符或非终结符）配备若干相 关的“值”（称为 属性 ），代表与文法符号相关信 息，如类型、值、代码序列、符号表内容等 对于文法的每个产生式都配备了一组属性的 语义规则 ，对属性进行计算和传递 文法的属性分为 综合属性 和 继承属性 14.1.1 综合属性 自下而上传递信息 语法规则：根据右 部候选式中的符号的属性计算左部被定义符号的 综合属性 语法树：根据子结点的属性和父结点自身的属性计算父节点的 综合属性 如这样一个文法的，.val就是一个综合属性：每一个节点的综合属性val的值都由其一些子节点的值组成\n继承属性 自上而下传递信息 语法规则：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式中的符号的 继承属性 语法树：根据父结点和兄弟节点的属性计算子结点的 继承属性 如下面的文法的type属性，对于id的type的值是由其父节点继承而来的，这样描述了一个声明语句：\n14.1.3 属性依赖 对应于每个产生式 A → α，都有一套与之相关联的语义规则，每条规则的形式为（f 是一个函数）：\nb := f ( c_1, c_2, … , c_k ) 属性 b 依赖于属性 c_1, c_2, … , c_k\nb是A的一个 综合属性 并且 c_1, c_2, … , c_k 是产生式右边文法符号的属性，或者b是产生式右边某个文法符号的一个 继承属性 并且 c_1, c_2, … , c_k 是A或产生式右边任何文法符号的属性 终结符只有 综合属性 ，由词法分析器提供 非终结符既可有 综合属性 也可有 继承属性 ，文 法开始符号的所有继承属性作为属性计算前的 初始值 语义规则 对出现在 产生式右边的继承属性 和 出现在产生式左边的综合属性 都必须提供一个计算规则。 属性计算规则中只能使用相应产生式中的文法符号的属性。 出现在 产生式左边的继承属性 和 出现在产生式右边的综合属性 不由所给的产生式的属性计 算规则进行计算，由其它产生式的属性规则计算或者由属性计算器的参数提供。 语义规则所描述的工作可以包括属性计算、静态语义检查、符号表操作、代码生成等。 测试：\n带注释的语法树 在语法树中，一个结点的 综合属性 的值由 其子结点 和 它本身 的属性值确定 使用自底向上的方法在每一个结点处使用语义规则计算综合属性的值 仅使用综合属性的属性文法称S－属性文法 如：\n在语法树中，一个结点的 继承属性 由 其父结点、 其兄弟结点 和 其本身 的某些属性确定 用 继承属性 来表示程序设计语言结构中的上下 文依赖关系很方便 如\n属性计算 基于属性文法的处理方法 语义规则的计算：1、产生代码；2、在符号表中存放信息；3、给出错误信息；4、执行任何其它动作\n对输入串的 翻译 就是根据 语义规则 进行 计算\n由源程序的语法结构所驱动的处理办法就是 语法制导翻译法\n输 入 串 → 语 法 树 → 按 照 语 义 规 则 计 算 属 性 依赖图 、树遍历 、一遍扫描\n依赖图() 在一棵语法树中的结点的继承属性和综合属性 之间的相互依赖关系可以由依赖图(有向图)来描述。 为每一个包含过程调用的语义规则引入一个 虚综合属性b ，这样把每一个语义规则都写成 b : = f ( c 1 , c 2 , … , c k )的形式。 依赖图中为每一个属性设置一个结点，如果属 性b依赖于属性c，则从属性c的结点有一条有向 边连到属性b的结点。 依赖图的构建算法 依赖图示例 良定义的属性文法 如果一属性文法不存在属性之间的循环依赖关系，则称该文法为良定义的 一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序 属性的计算次序 基础文法用于建立输入符号串的语法分析树\n根据语义规则建立依赖图\n根据依赖图的拓扑排序，得到计算语义规则的顺序\n输 入 串 → 语 法 树 → 依 赖 图 → 语 义 规 则 计 算 次 序 树遍历() 树遍历的属性计算方法 通过树遍历的方法计算属性的值:\n假设语法树已建立，且树中已带有开始符号的继承 属性和终结符的综合属性 以某种次序遍历语法树，直至计算出所有属性 深度优先，从左到右的遍历: 输 入 串 → 语 法 树 → 遍 历 语 法 树 计 算 属 性 树遍历算法 树遍历算法示例 考虑属性的文法G(S)，其中:\nS有继承属性a，综合属性b X有继承属性c、综合属性d Y有继承属性e、综合属性f Z有继承属性h、综合属性g 树遍历示例 不断的用上一规则，检查每一个节点是否有为计算的属性：\n一遍扫描 一遍扫描的处理方法 在语法分析的同时计算属性值 ：所采用的语法分析方法 会影响 属性的计算次序 所谓 语法制导翻译法 ，直观上说就是为文法中每个 产生式配上一组语义规则，并且在语法分析的同时 执行这些语义规则 语义规则被计算的时机 自上而下分析，一个产生式匹配输入串成功时 自下而上分析，一个产生式被用于进行归约时 抽象语法树 抽象语法树(Abstract Syntax Tree，AST) ，在 语法树中去掉那些对翻译不必要的信息，从而 获得更有效的源程序中间表示\n建立表达式的抽象语法树 mknode(op,left,right) 建立一个运算符号结点，标号是op，两个域left和right分别指向左子树和右子树 mkleaf(id,entry) 建立一个标识符结点，标号为id，一个域entry指向标识符在符号表中的入口 mkleaf(num,val) 建立一个数结点，标号为 num，一个域val用于存放数的值 建立抽象语法树的语义规则 属性文法和语法制导翻译2 S-属性文法 S-属性文法的自下而上计算 S-属性文法 ：只含有综合属性\n在自下而上的分析器分析输入符号串的同时计算 综合属性\n分析栈中保存语法符号和有关的综合属性值 每当进行归约时，新的语法符号的属性值就由栈中正在归约的产生式右边符号的属性值来计算 在分析栈中增加附加域存放综合属性值\n假设产生式 A → XYZ 对应的语义规则为 a := f (X.x, Y.y, Z.z) 。分析栈的变化：\n一个例子：\nL-属性文法 一遍扫描的处理方法 S－属性文法适合一遍扫描的自下而上分析 L－属性文法适合一遍扫描的自上而下分析 L-属性文法和自顶向下翻译 按照深度优先遍历语法树，计算所有属性值 与LL(1) 自上而下分析方法结合 深度优先建立语法树 按照语义规则计算属性 15.2.3 L-属性文法 一个属性文法称为 L-属性文法 ，如果对于每个产生式 A → X 1 X 2 … X n​，其每个语义规则中的每个属性或者是 综合属性 ，或者是 X i ( 1 ≤ i ≤ n ) 的一个 继承属性 且这个继承属性仅依赖于：\n产生式中 X i 左边符号 X 1 ， X 2 ， … ， X i − 1 的属性 A的继承属性 S-属性文法一定是L-属性文法\n例如这样一个文法就不是L-属性文法：\n翻译模式 翻译模式 语义规则 ：给出了属性计算的定义，没有属性计算的次序等实现细节\n翻译模式 ：给出使用语义规则进行计算的次序，把实现细节表示出来\n在翻译模式中，和文法符号相关的属性和语义规则（也称 语义动作 ），用花括号{ }括起来，插入到产生式右部的合适位置上\n翻译模式示例 如把带加号和减号的中缀表达式翻译成相应的后缀表达式，对输入串使用上面的文法的处理：9-5+2\n分析如下：\n设计翻译模式的原则 设计翻译模式时，必须保证当某个动作引用一个属性时它必须是有定义的 L-属性文法 本身就能确保每个动作不会引用尚未计算出来的属性 建立翻译模式 当只需要 综合属性 时：为每一个语义规则建立 一个包含赋值的动作，并把 这个动作放在相应的产生式右边的末尾 如果既有 综合属性 又有 继承属性 ，在建立翻译模式时就必须保证： 1.产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来 2.一个动作不能引用这个动作右边的符号的综合属性 3.产生式左边非终结符的 综合属性 只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的 末尾\n(更多在CSDN pi31415926535x)\n参考 学习所用，转自CSDN pi31415926535x 《高级程序设计语言编译原理》 (end)\n","date":"2025-03-19T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/","title":"编译原理-属性文法和语法制导翻译"},{"content":"编译原理-语法分析-自上而下分析 第七章-自上而下分析1 自上而下分析的基本问题 语法分析的前提 对语言的语法结构进行描述 采用 正规式 和 有限自动机 描述和识别语言的 单词符号 用 上下文无关文法 来描述语法规则 上下文无关文法即第二章的内容：\n语法分析的任务 语法分析的任务 ：分析一个文法的句子的结构 语法分析器的功能 ：按照文法的产生式(语言的语法规则)，识别输入符号 串是否为一个句子(合式程序) 7.1.2语法分析器在编译器中的地位 语法分析的过程：\n7.1.3语法分析的方法 语法分析的方法有两种：自上而下 以及 自下而上 :\n自下而上(Bottom-up) 自上而下(Top-down) 从输入串开始，逐步进行归约，直到文法的开始符号 从文法的开始符号出发， 反复使用各种产生式，寻 找\u0026quot;匹配\u0026quot;的推导 归约：根据文法的产生式规则，把串中出现的产生 式的右部替换成左部符号 推导：根据文法的产生式 规则，把串中出现的产生 式的左部符号替换成右部 从树叶节点开始，构造语法树 从树的根开始，构造语法树 算符优先分析法、LR分析法 递归下降分析法、预测分析程序 7.1.4 自上而下分析面临的问题 自上而下分析的过程 基本思想：\n从文法的开始符号出发，向下推导，推出句子 针对输入串，试图用一切可能的办法，从文法开始 符号(根结点)出发，自上而下地为输入串建立一棵语法树 一个例子：\n从上面的例子可以看出：\n多个产生式候选带来的问题 回溯问题：分析过程中，当一个非终结符用某一个候选匹配成 功时，这种匹配可能是暂时的，出错时，不得不“回溯”（一个dfs的过程） 文法左递归问题：可能某个终结符可以不断的使用自身来扩展下去，这样在语法树中就是一个不断左递归的过程，一个文法是含有左递归的，如果存在非终结符 P : P → P a P:P \\to Pa P:P→Pa ，这样的，会导致死循环： 7.2 LL(1)文法——消除文法的左递归 因为直接自上而下分析会有 回溯 和 左递归 问题，所以要先进行 消除文法的左递归性 以及 消除回溯 ，以 构造不带回溯的自上而下分析算法\n7.2.1 直接左递归的消除 （看图吧，md排版不怎么好。。。）\n例如这样的一个文法的消除例子：\n7.2.2 间接左递归的消除 一个文法消除左递归的条件 ：\n不含以ε为右部的产生式 不含回路，就是不会出现一个非终结符推着推着出现了自己开头的 例如对这样一个文法S的间接左递归的消除：\n这个过程就是不断的用下层的替换前面出现的，这样一直替换下去最后第一层就只有一个非终结符组成的文法了，最后有直接左递归的就用上一个方法去掉就行了。\n这个间接左递归的具体消除算法如下：\n对于上面的那个例子的消除结果就是：\n{ S → a b c S ′ ∣ b c S ′ ∣ c S ′ S ′ → a b c S ′ ∣ ε \\begin{cases} S → abcS\u0026rsquo;| bcS\u0026rsquo;| cS\u0026rsquo; \\\\ S\u0026rsquo;→ abcS\u0026rsquo;| ε \\end{cases} {S→abcS′∣bcS′∣cS′S′→abcS′∣ε​\n注意，由于对非终结符排序的不同，后所得的文法在形式上可能不一样。但不难证明，它们都是等价的。 7.3 LL(1)文法——消除回溯 7.3.1 消除回溯的目的 为了消除回溯必须保证：对文法的任何非终结符，当要它去匹配输入串时， 能够根据它所面临的输入符号 准确地 指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的（将多种可能的搜索变成单一的匹配）。\n7.3.2 FIRST集合 令G是一个不含左递归的文法，对G的所有 非终结符 的每个候选α定义它的终结首符集FIRST(α) 为：\nF I R S T ( α ) = { a ∣ α ⇒ ∗ a . . . , a ∈ V T } 特 别 的 ， 若 α ⇒ ∗ ε ， 则 规 定 ε ∈ F I R S T ( α ) FIRST(\\alpha)=\\{a|\\alpha⇒^a\u0026hellip;, a \\in V_T\\} \\\\ 特别的，若 \\alpha ⇒^ ε，则规定 ε \\in FIRST(\\alpha) FIRST(α)={a∣α⇒∗a\u0026hellip;,a∈VT​}特别的，若α⇒∗ε，则规定ε∈FIRST(α)\n就是某个非终结符 α \\alpha α 其所有的可能推导出的句子的首字符组成的集合。\n如果非终结符A的所有候选首符集两两不相交， 即A的任何两个不同候选 α i α_i αi​ 和 α j α_j αj​ ： F I R S T ( α i ) ∩ F I R S T ( α j ) ＝ φ FIRST(α_i)∩FIRST(α_j)＝φ FIRST(αi​)∩FIRST(αj​)＝φ ， 当要求A匹配输入串时，A能根据它所面临的 第一个输入符号a，准确地指派某一个候选去执行任务。这个候选就是那个终结首符集含a的α。 （也就说，只要我们可以使得A下的产生式的First集合两两不相交，这样就可以唯一确定一个字符出现在那个First集合中，这样就可以从该产生式扩展下去，也就达到了消除回溯的目的：\n而达到这一目的（两两不相交）的方法就是 提取公共左因子\n7.3.3 提取公共左因子（通过大量引入非终结符的方法） 7.3.4 ε ε ε候选 这样的一个例子：\n在进行分析的过程中，对 T‘的推导中使用了 ε ε ε ,这里选用的原因之一就是 T’包含这样的一个句型，所以才使用 ε ε ε 来跳过：\n7.3.5 FOLLOW集合 假定S是文法G的开始符号，对于G的任何非终结符A，我们定义A的FOLLOW集合：\nF O L L O W ( A ) = { a ∣ S ⇒ ∗ . . . A a . . . , a ∈ V T } 特 别 是 ， 若 S ⇒ ∗ . . . A , 则 规 定 # ∈ F O L L O W ( A ) FOLLOW(A)=\\{a|S ⇒^* \u0026hellip;Aa\u0026hellip;, a \\in V_T\\} \\\\ 特别是，若 S ⇒^* \u0026hellip;A, 则规定 \\# \\in FOLLOW(A) FOLLOW(A)={a∣S⇒∗\u0026hellip;Aa\u0026hellip;,a∈VT​}特别是，若S⇒∗\u0026hellip;A,则规定#∈FOLLOW(A)\n（也就是指FOLLOW(A) 为所有可能跟在非终结符A后的终结符的集合）\n7.3.6 构造不带回溯的自上而下分析的文法条件 文法不含左递归 对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。即，若 A → α 1 ∣ α 2 ∣ … ∣ α n A→α_1|α_2|…|α_n A→α1​∣α2​∣…∣αn​ ，则 F I R S T ( α i ) ∩ F I R S T ( α j ) ＝ φ ( i ≠ j ) FIRST(α_i)∩FIRST(α_j)＝φ(i≠j) FIRST(αi​)∩FIRST(αj​)＝φ(i​=j) （保证了不回溯） 对文法中的每个非终结符A，若它存在某个候选首符集包含ε，则 F I R S T ( α i ) ∩ F O L L O W ( A ) = φ ， i = 1 , 2 , . . . , n FIRST(α_i)∩FOLLOW(A)=φ，i=1,2,\u0026hellip;,n FIRST(αi​)∩FOLLOW(A)=φ，i=1,2,\u0026hellip;,n （保证在选取ε时仅选择的是唯一一个产生式） 如果一个文法G满足以上条件，则称该文法G为LL(1)文法。 其中：\n第一个L： 从左到右扫描输入串 第二个L： 最左推导 1： 每一步只需向前查看一个符号 7.3.6 LL(1)分析法 对于经过处理后的满足上述条件的LL(1)文法，可以对其输入串进行 有效的 无回溯的 自上而下分析 ：\n假设要用非终结符A进行匹配，面临的 输入符号为a ，A 的所有产生式为 A → α 1 ∣ α 2 ∣ … ∣ α n A→α_1 | α_2 | … | α_n A→α1​∣α2​∣…∣αn​ 1.若 a ∈ F I R S T ( α i ) a∈FIRST(α_i) a∈FIRST(αi​) ，则指派 α i α_i αi​ 执行匹配任务； 2.若a不属于任何一个候选首符集，则： 若 ε ε ε 属于某个 F I R S T ( α i ) FIRST(α_ i) FIRST(αi​) 且 a ∈ F O L L O W ( A ) a∈FOLLOW(A) a∈FOLLOW(A) ，则让 A与 ε ε ε 自动匹配。 否则，a的出现是一种语法错误 7.4 FIRST和FOLLOW集合的构造 7.4.1 构造 F I R S T ( α ) FIRST(α) FIRST(α) F I R S T ( α ) = { a ∣ α ⇒ ∗ a . . . , a ∈ V T } FIRST(\\alpha)=\\{a|\\alpha ⇒^* a\u0026hellip;, a \\in V_T\\} FIRST(α)={a∣α⇒∗a\u0026hellip;,a∈VT​}\n对于First集合的构造，可以由易到难进行考虑，首先考虑 α α α 为单个字符的情况，然后推广到任意长度的串：\n{ α = X ， X ∈ V T ∪ V N (单个文法符号） α = X 1 X 2 … X n ， X i ∈ V T ∪ V N （任何符号串） \\begin{cases} α= X，X∈V_T∪V_N \u0026amp; \\text{(单个文法符号）}\\\\ α= X_1X_2…X_n，X_i∈V_T∪V_N \u0026amp; \\text{（任何符号串）} \\end{cases} {α=X，X∈VT​∪VN​α=X1​X2​…Xn​，Xi​∈VT​∪VN​​(单个文法符号）（任何符号串）​\n构造每个文法符号的FIRST集合 （思想：将无穷推导转化为对优先产生式的反复扫描）\n构造任何符号串的FIRST集合 这里的 F I R S T ( X i ) / { ε } FIRST(X_i) / \\{ε\\} FIRST(Xi​)/{ε} 表示的是除去空字集合。\n7.4.2 构造FOLLOW(A) F O L L O W ( A ) = { a ∣ S ⇒ ∗ . . . A a . . . , a ∈ V T } FOLLOW(A)=\\{a|S ⇒^* \u0026hellip;Aa\u0026hellip;, a \\in V_T\\} FOLLOW(A)={a∣S⇒∗\u0026hellip;Aa\u0026hellip;,a∈VT​}\n构造每个非终结符的FOLLOW集合 对于第2点：\n对于第3点：\n7.4.3 练习 对于上面的文法G(E):\nE → T E ′ E ′ → + T E ′ ∣ ε T → F T ′ T ′ → ∗ F T ′ ∣ ε F → ( E ) ∣ i \\begin{aligned} \u0026amp;E→TE\u0026rsquo; \\\\ \u0026amp;E\u0026rsquo;→+TE\u0026rsquo;| ε \\\\ \u0026amp;T→FT\u0026rsquo; \\\\ \u0026amp;T\u0026rsquo;→*FT\u0026rsquo;| ε \\\\ \u0026amp;F→(E) | i \\\\ \\end{aligned} ​E→TE′E′→+TE′∣εT→FT′T′→∗FT′∣εF→(E)∣i​\n构造每个非终结符的FIRST和FOLLOW集合 :\n根据前面构造FIRST集合的步骤：\nFIRST 第1步 第2步 第3步 第4步 F I R S T ( E ) = FIRST(E)= FIRST(E)= { ( , i \\{(,i {(,i { ( , i } \\{(,i\\} {(,i} F I R S T ( E ′ ) = FIRST(E\u0026rsquo;)= FIRST(E′)= { + , ε \\{+, ε {+,ε { + , ε \\{+, ε {+,ε { + , ε \\{+, ε {+,ε { + , ε } \\{+, ε\\} {+,ε} F I R S T ( T ) = FIRST(T)= FIRST(T)= { ( , i \\{(, i {(,i { ( , i \\{(, i {(,i { ( , i } \\{(, i\\} {(,i} F I R S T ( T ′ ) = FIRST(T\u0026rsquo;)= FIRST(T′)= { ∗ , ε \\{*, ε {∗,ε { ∗ , ε \\{*, ε {∗,ε { ∗ , ε \\{*, ε {∗,ε { ∗ , ε } \\{*, ε\\} {∗,ε} F I R S T ( F ) = FIRST(F)= FIRST(F)= { ( , i \\{(, i {(,i { ( , i \\{(, i {(,i { ( , i \\{(, i {(,i { ( , i } \\{(, i\\} {(,i} 有了FIRST集合，就可以构造FOLLOW集合（注意一个产生式可能有不同的匹配规则匹配）：\n第一次处理时加入 # \\# # 满足： A → α B β A\\to \\alpha B \\beta A→αBβ ，将 F I R S T ( β ) / { ε } FIRST(\\beta)/\\{ε\\} FIRST(β)/{ε} 加入到 F O L L O W ( B ) FOLLOW(B) FOLLOW(B) 满足： A → α B β A\\to \\alpha B \\beta A→αBβ ，且 β ⇒ ∗ ε \\beta ⇒^*ε β⇒∗ε 将 F O L L O W ( A ) FOLLOW(A) FOLLOW(A) 加入到 F O L L O W ( B ) FOLLOW(B) FOLLOW(B) 中 满足： A → α B A \\to \\alpha B A→αB ， 将 F O L L O W ( A ) FOLLOW(A) FOLLOW(A) 加入到 F O L L O W ( B ) FOLLOW(B) FOLLOW(B) 中 对于 ε ε ε 不处理 FOLLOW 第1步对E处理 第2步对E’处理 第3步对T处理 第4步对T’处理 第5步对F处理 第6步对E再处理 第7步对T再处理 之后继续几次直到发现各集合大小都不变 F O L L O W ( E ) = FOLLOW(E)= FOLLOW(E)= { # , \\{\\#, {#, { # , \\{\\#, {#, { # , \\{\\#, {#, { # , \\{\\#, {#, { # , ) , \\{\\#,), {#,), { # , ) , \\{\\#,), {#,), { # , ) , \\{\\#,), {#,), { # , ) } \\{\\#,)\\} {#,)} F O L L O W ( E ′ ) = FOLLOW(E\u0026rsquo;)= FOLLOW(E′)= { # , \\{\\#, {#, { # , \\{\\#, {#, { # , \\{\\#, {#, { # , \\{\\#, {#, { # , \\{\\#, {#, { # , ) , \\{\\#,), {#,), { # , ) , \\{\\#,), {#,), { # , ) } \\{\\#,)\\} {#,)} F O L L O W ( T ) = FOLLOW(T)= FOLLOW(T)= { + , # , \\{+, \\#, {+,#, { + , # , \\{+, \\#, {+,#, { + , # , \\{+, \\#, {+,#, { + , # , \\{+, \\#, {+,#, { + , # , \\{+, \\#, {+,#, { + , # , ) , \\{+, \\#,), {+,#,), { + , # , ) , \\{+, \\#,), {+,#,), { + , # , ) } \\{+, \\#,)\\} {+,#,)} F O L L O W ( T ′ ) = FOLLOW(T\u0026rsquo;)= FOLLOW(T′)= { + , # , \\{+, \\#, {+,#, { + , # , \\{+, \\#, {+,#, { + , # , \\{+, \\#, {+,#, { + , # , \\{+, \\#, {+,#, { + , # , ) \\{+, \\#,) {+,#,) { + , # , ) } \\{+, \\#,)\\} {+,#,)} F O L L O W ( F ) = FOLLOW(F)= FOLLOW(F)= { ∗ , + , # , \\{*,+,\\#, {∗,+,#, { ∗ , + , # , \\{*,+,\\#, {∗,+,#, { ∗ , + , # , \\{*,+,\\#, {∗,+,#, { ∗ , + , # , \\{*,+,\\#, {∗,+,#, { ∗ , + , # , ) , \\{*,+,\\#,), {∗,+,#,), { ∗ , + , # , ) } \\{*,+,\\#,)\\} {∗,+,#,)} 第8章-自上而下分析2 8.1 构造递归下降分析器 8.1.1 递归下降分析器 分析程序由一组子程序组成，对每一 语法单位 (非终结符)构造一个相应的 子程序 ，识别对应的 语法单位 通过子程序间的相互调用实现对输入串的识别，例如，A → B c D 就有三个处理A、B、D的子程序 文法的定义通常是递归的，通常具有递归结构 定义全局过程和变量 ADVANCE ，把输入串指示器IP指向下一个输入符号， 即读入一个单词符号 SYM ，IP当前所指的输入符号 ERROR ，出错处理子程序 每个非终结符有对应的子程序的定义，在分析 过程中，当需要从某个非终结符出发进行展开 (推导)时，就调用这个非终结符对应的子程序\n8.1.2 递归下降子程序设计 一个简单的子程序的设计 框内的代码不简化可以写成这样:\nELSE IF SYM ∈ FOLLOW(A) THEN BEGIN END ELSE ERROR 8.2 扩充的巴科斯范式和语法图 8.2.1 扩充的巴科斯范式 在元符号“→”或“::=”和“|”的基础上，扩 充几个元语言符号：\n用花括号 α {α} α 表示闭包运算 α ∗ α^* α∗ 。 用表示 α 0 n {α}_0^n α0n​ 可任意重复0次至n次。 用方括号 [ α ] [α] [α] 表示 { α } 0 1 \\{α\\}_0^1 {α}01​，即表示 α α α 的出现可有可无(等 价于 α ∣ ε α|ε α∣ε )。 例如，通常的“实数”可定义为：\nD e c i m a l → [ S i g n ] I n t e g e r . { d i g i t } [ E x p o n e n t ] E x p o n e n t → E [ S i g n ] I n t e g e r I n t e g e r → d i g i t { d i g i t } S i g n → + ∣ − \\begin{aligned} \u0026amp; Decimal→[Sign]Integer.\\{digit\\}[Exponent] \\\\ \u0026amp; Exponent→E[Sign]Integer \\\\ \u0026amp; Integer→digit\\{digit\\} \\\\ \u0026amp; Sign→ + |- \\\\ \\end{aligned} ​Decimal→[Sign]Integer.{digit}[Exponent]Exponent→E[Sign]IntegerInteger→digit{digit}Sign→+∣−​\n用扩充的巴科斯范式来描述语法，直观易懂， 便于表示左递归消去和因子提取。\n8.2.2 语法图 可以将最上面的文法转化为扩充巴科斯范式以及对应的语法图:\n这样转化后的文法对应的递归子程序可以写成:\n8.3 JavaCC简介 一个语法分析的小工具:\n第9讲 语法分析——自上而下分析3 9.1 预测分析程序 9.1.1 预测分析程序的工作原理 预测分析程序构成 总控程序，根据现行栈顶符号和当前输入符号， 执行动作 分析表M[A， a]矩阵 ， A ∈ V N ， a ∈ V T A ∈V_N，a ∈V_T A∈VN​，a∈VT​ 是终 结符或 ′ # ′ \u0026lsquo;\\#\u0026rsquo; ′#′ 分析栈STACK 用于存放文法符号 预测分析过程 总控程序根据当前栈顶符号X和输入符号a，执行下列三动作之一：\n若X＝a＝‘＃’，则宣布分析成功，停止分析。 若X＝a ≠‘＃’，则把X从STACK栈顶逐出，让a指向 下一个输入符号。 若X是一个非终结符，则查看分析表M。 若M[X，a]中存放着关于X的一个产生式，把X逐出 STACK栈顶，把产生式的右部符号串按反序一一推进 STACK栈(若右部符号为ε，则意味不推什么东西进栈)。 若M[X，a]中存放着“出错标志”，则调用出错诊察程序ERROR。 总控程序实现 预测分析示例 对于上面的文法的一个预测分析的过程，其中分析表的构造看下一讲：\n9.2 预测分析表的构造 9.2.1 分析表M[A，a]的构造 构造分析表前，首先要构造FIRST(α)和FOLLOW(A)\n分析表M[A，a]的构造算法 构造G的分析表 M [ A ， a ] M[A，a] M[A，a] ，确定每个产生式 A → α A→α A→α 在表中的位置：\n1 对文法G的每个产生式 A → α A→α A→α 执行第2步和第3步； 2 对每个终结符 a ∈ F I R S T ( α ) a ∈FIRST(α) a∈FIRST(α) ，把 A → α A→α A→α 加至 M [ A ， a ] M[A， a] M[A，a] 中； 3 若 ε ∈ F I R S T ( α ) ε∈FIRST(α) ε∈FIRST(α) ，则对任何 b ∈ F O L L O W ( A ) b∈FOLLOW(A) b∈FOLLOW(A) 把 A → α A→α A→α 加至 M [ A ， b ] M[A，b] M[A，b] 中。 4 把所有无定义的 M [ A ， a ] M[A，a] M[A，a] 标上“出错标志”。 9.2.2 LL(1)文法与二义性 如果G是左递归或二义的，那么，M至少含有 一个多重定义入口。因此，消除左递归和提取 左因子将有助于获得无多重定义的分析表M。 可以证明，一个文法G的预测分析表M不含多 重定义入口，当且仅当该文法为LL(1)的。 LL(1)文法不是二义的。 例如这样一个实现 ifelse 语句的文法就是二义性的，解决方法是人为的确定一个ifelse 语法，如就近匹配选择 S ′ → e S S\u0026rsquo;\\to eS S′→eS\n（end)\nhttps://blog.csdn.net/pi31415926535x/article/details/105163345\n","date":"2025-03-19T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90/","title":"编译原理-语法分析-自上而下分析"},{"content":"编译原理-语法分析-自下而上分析 自下而上分析 1 自下而上分析 自下而上分析的一个示例 可以看出自下而上分析的主要步骤是不断的用文法来“规约”，最后找到一种句型的表示\n自下而上分析的基本思想 采用 “移进－归约” 思想进行自下而上分析 基本思想: 用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号。 10.1.3 移进－归约分析示例 其中每一步的操作都可以构成语法树（分析树）的一部分。\n可归约串：短语\n短语与直接短语 短语 定义：令G是一个文法，S是文法的开始符号， 假定 α β δ 是文法G的一个句型，如果有 S =*=\u0026gt; α A δ 且 A =+=\u0026gt; β 则称 β 是句型 α β δ 相对于非终结符A的短语 如果有 A ⇒ β , 则称 β 是句型 α β δ 相对于规则 A → β 的 直接短语。 测试：短语和直接短语 10.3 分析过程描述 算符优先文法 算符优先文法 算符优先分析法:\n按照算符的优先关系和结合性质进行语法分析 适合分析表达式 LR分析法:\n规范归约：句柄作为可归约串 运算的优先级 四则运算的优先规则: 先乘除后加减, 同级从左到右\n考虑文法G’(E)： E → i| E + E | E - E | E * E | E / E | ( E ) : 句子 i+i-i*(i+i) 有几种不同的归约 :\n归约顺序不同，计算的顺序也不同，结果也不一样。\n句子 i + i - i * ( i + i ) 的归约过程：\n优先关系 任何两个可能相继出现的终结符a与b可能三种 优先关系 ：\na ⋖ b a的优先级低于b a ≐ b a的优先级等于b （这里的点是在等号中间） a ⋗ b a的优先级高于b 算符优先关系与数学上的 \u0026lt;\u0026gt;= 不同 :\n+ ⋖ + a ⋖ b 并不意味着 b ⋗ a 如 ( ⋖ + 和 + ⋖ ( 算符文法 一个文法，如果它的任一产生式的右部都不含两个相继(并列)的非终结符，即不含 … Q R … 形式的产生式右部，则我们称该文法为算符文法。\n约定：\na、b代表任意终结符 P、Q、R代表任意非终结符 ‘ … ’代表由终结符和非终结符组成的任意序列，包括空字 算符优先文法 示例：算符优先文法：\n对应的优先关系表：\n构造优先关系表 构造优先关系表的算法——FIRSTVT和LASTVT集合 根据FIRSTVT和LASTVT集合，检查每个产生式的候选式，确定满足关系 ⋖ 和 ⋗ 的所有终结符对 ：\n假定有个产生式的一个候选形为…aP…，那么，对 任何 b ∈ FIRSTVT( P ) ，有 a ⋖ b 假定有个产生式的一个候选形为…Pb…，那么，对 任何 a ∈ LASTVT ( P ) ，有 a ⋗ b 构造集合FIRSTVT的算法 反复使用下面两条规则构造集合 FIRSTVT( P ) :\n若有产生式 P → a … 或 P → Q a … ，则 a ∈ FIRSTVT( P ) 若 a ∈ FIRSTVT(Q) ，且有产生式 P → Q … ，则 a ∈ FIRSTVT( P ) 算法的一种实现:\n布尔数组F[P，a] ，使得F[P，a]为真的条件是，当且 仅当 a ∈ FIRSTVT。开始时，按上述的规则1对每个数组元素F[P，a]赋初值。 栈STACK ，把所有初值为真的数组元素F[P，a]的符 号对(P，a)全都放在STACK之中。 若栈STACK不空，就将栈顶项弹出，记此项为 (Q， a) 。对于每个形如 P → Q… 的产生式，若F[P，a]为假， 则变其值为真且将 (P， a) 推进STACK栈。 上述过程一直重复，直至栈STACK为空为止。 算法的工作结果得到一个二维数组F，从它可得 任何非终结符 P 的FIRSTVT FIRSTVT( P ) ＝ { a ∣ F[P，a] = TRUE }\n10.5.3 构造集合LASTVT的算法 同样的思想：\n反复使用下面两条规则构造集合LASTVT\n若有产生式 P → … a 或 P → … a Q ，则 a ∈ LASTVT( P ) 若 a ∈ LASTVT( Q ) ，且有产生式 P→…Q，则 a ∈ LASTVT( P ) FIRSTVT和LASTVT集合计算示例 构造优先关系表的算法 通过检查G的每个产生式的每个候选式，可找 出所有满足a ≐ b 的终结符对。 根据 FIRSTVT 和 LASTVT 集合，检查每个产生式 的候选式，确定满足关系 ⋖ 和 ⋗ 的所有终结符对 假定有个产生式的一个候选形为 … a P … ，那么，对任何 b ∈ FIRSTVT( P ) ，有 a⋖b 假定有个产生式的一个候选形为 … P b … ，那么，对任何 a ∈ LASTVT( P ) ，有 a ⋗ b 示例：构造优先关系表 对于#的判断可以通过句型： `#E#` 来判断。 没有任何两个终结符之间是有多个关系的，所以该文法是一个算符优先文法。\n算符优先分析算法 最左素短语 可归约串，句型，短语 一个文法G的句型的 素短语 是指这样一个短语， 它至少含有一个终结符，并且，除它自身之外不再含任何更小的素短语 最左素短语 是指处于句型左边的那个素短语\n最左素短语定理 算符优先文法句型(括在两个＃之间)的一般形式: # N1 a1 N2 a2 … Nn an Nn+1 # 其中，ai 都是终结符， Ni 是可有可无的非终结符。 定理：一个算符优先文法G的任何句型的左素短语是满足如下条件的左子串 Nj aj … Ni ai Ni+1 ，且： aj−1 ⋖ aj aj ≐ aj+1 , … , ai−1 ≐ ai ai ⋗ a i+1 算符优先分析算法 使用一个符号栈S，用它寄存终结符和非终结符， k代表符号栈S的使用深度 在正确的情况下，算法工作完毕时，符号栈S应 呈现：# N # 整个算法的执行如下：\n根据上面的规约那一部分的算法可知：对于文法的句子来说，它的算符优先分析的结果 不一定 就是语法树，所以语法树和分析树要分开指代，这章一开始便已强调：\n算符优先分析程序构成 总控程序 ，根据现行栈顶符号和当前输入符号， 执行动作 优先关系表 ，用于指导总控程序进行移进-归约 分析栈STACK ，用于存放文法符号 10.6.5 算符优先分析法 特点:\n优点: 简单，快速 缺点: 可能错误接受非法句子 使用广泛,用于分析各类表达式 如，ALGOL 60\n第11章 自下而上分析2 LR分析法概述 LR分析法 1965年由Knuth提出 L：从左到右扫描输入串 R：自下而上进行归约 工作框架 句柄和规范归约 短语、直接短语和句柄 短语 直接短语 句柄 :一个句型的左直接短语称为该句型的句柄。 用句柄归约 可用句柄来对句子进行归约:\n规范归约 定义：假定 α 是文法G的一个句子，我们称序列 αn​，αn−1​，…，α0 是 α 的一个规范归约，如果此序列满足：\nαn ​= α α0​ 为文法的开始符号，即 α0 ​= S 对任何 i ， 0 ≤ i ≤ n ， αi−1是从 αi​ 经把句柄替换成为相应产生式左部符号而得到的 算符优先分析vs. 规范归约 11.2.5 规范句型 规范归约 是最左归约 规范归约的逆过程就是右推导 S ⇒ aAcBe ⇒ aAcde ⇒ aAbcde ⇒ abbcde 右推导也称为 规范推导 由规范推导推出的句型称为 规范句型 LR分析法 规约的关键 规范归约的关键问题是寻找句柄.\n历史 ：已移入符号栈的内容 展望 ：根据产生式推测未来可能遇到的输入符号 现实 ：当前的输入符号 LR分析器的结构 LR分析方法：把 \u0026quot;历史\u0026quot; 及 \u0026quot;展望\u0026quot; 综合抽象成状态 ；由栈顶的 状态 和 现行的输入符号 唯一确定每一步工作:\nLR分析表 LR分析器的核心是一张分析表:\nACTION[s，a] ：当状态s面临输入符号a时，应采取什么动作. GOTO[s，X] ：状态s面对文法符号X时，下一状态是什么 11.3.4 LR分析过程 分析开始时： 状态栈 符号栈 输入串 ( s0​ , # , a1​ a2​ … an​ #) 以后每步的结果可以表示为: 状态栈 符号栈 输入串 ( s0 ​s1 ​… sm​, # X1 ​… Xm​ , ai ​ai+1 ​… an ​#) LR分析示例 LR分析器的性质 栈内的符号串和扫描剩下的输入符号串构成了一个规范句型 一旦栈的顶部出现可归约串(句柄)，则进行规约 对于句子，在规范归约过程中，栈内的符号串 和扫描剩下的输入符号串构成了一个规范句型， 下面哪种格局不会出现：\nLR文法 LR文法 定义：对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这 个文法就称为 LR文法 。 定义：一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器进行分析，则这 个文法就称为 LR(k)文法 。 LR文法与二义文法 LR文法不是二义的，二义文法肯定不会是LR的\nLR文法⊂无二义文法\n非LR结构:\n第12章 自下而上分析3 活前缀 字的前缀、活前缀 字的前缀 ：是指字的任意首部，如字 abc 的前缀有: ε， a ， ab ， abc 活前缀 ：是指 规范句型 的一个前缀，这种前缀不含 句柄 之后的任何符号。即，对于规范句型 α β δ ，β 为句柄，如果 αβ = u1 ​u2​ … ur​，则符号串 u1 ​u2 ​… ui ​(1≤i≤r) 是 α β δ 的 活前缀 。( δ 必为终结符串) 规范归约过程中，保证分析栈中总是 活前缀 ， 就说明分析采取的移进/归约动作是正确的 对于一个文法G, 可以构造一个DFA, 它能识别G 的所有活前缀。\n构造识别活前缀的DFA 文法的拓广 将文法G( S ) 拓广为 G′ ( S ) :\n构造文法 G′ ，它包含了整个 G ，并引进不出现在 G 中的非终结符 S′ 、以及产生式 S′ → S , S′ 是 G′ 的开始符号 称 G′ 是 G 的拓广文法 LR(0)项目 LR( 0 )项目: 在每个产生式的右部添加一个圆点，表示我们在分析过程中看到了产生式多大部分 例如： A → XYZ 有四个项目：A → •XYZ , A → X•YZ , A → XY•Z , A → XYZ• A → α• 称为 \u0026quot;归约项目\u0026quot; （把点看成识别的指针，识别到产生的末表示可以用这个产生式的左部代替） 归约项目 S′ → α• 称为 \u0026quot;接受项目\u0026quot;（表示识别到文法的拓广文法的开始，也就是当前读入的单词被识别到） A → α • a β ( a ∈ VT ) 称为 \u0026quot;移进项目\u0026quot; A → α • B β ( B ∈ VN ) 称为 \u0026quot;待约项目\u0026quot; 示例：\n构造识别文法所有活前缀的DFA 对于上面那个文法的一个 NFA 就是：\n然后按照前面的套路将 NFA 变为 DFA ：\nLR(0)项目集规范族 构成识别一个文法活前缀的 DFA 的项目集(状 态)的全体称为文法的 LR(0)项目集规范族 。\n如上图中的每一个状态中的一些项目组成的集合就是一个个项目集规范族：\n通过计算项目集规范族构造识别活前缀的DFA 有效项目 项目 A → β1 • β2 对活前缀 αβ1 是有效的，其条件是存在规范推导: S′=*=\u0026gt;R ​αAω=*=\u0026gt;R​αβ1​β2​ω\n在任何时候，分析栈中的活前缀 X1 ​X2 ​… Xm​ 的有效项目集正是从识别活前缀的 DFA 的初态出发，读出 X1 ​X2 ​… Xm​ 后到达的那个项目集(状态)。\n（应该可以理解为当一个活前缀的后缀是某个项目的前缀时，就称这个项目是这个活前缀的一个有效项目，因为只要当活前缀的后缀加上一定的后续的读入就可以规约到这个项目的左部）\n有效项目的性质 若项目 A→α•Bβ 对活前缀 η = δα 是有效的且 B→γ 是一个产生式，则项目 B→•γ 对 η = δα 也是有效的。\n证明：\nLR(0)项目集规范族的构造 将文法G(S)拓广为G′(S′)：\n构造文法G′ ，它包含了整个G，并引进不出现在G中的非终结符S′，以及产生式 S′→S ，S′ 是 G′ 的开始符号 G′ 唯一的“接受”态：仅含项目S′→S•的状态 项目集的闭包CLOSURE 状态转换函数 为了识别活前缀，我们定义一个状态转换函数GO。I 是一个项目集，X 是 一个文法符号。函数值 GO(I，X) 定义为：GO(I，X) ＝ CLOSURE( J ) 其中 J ＝ { 任 何 形 如 A → α X • β 的 项 目 ∣ A → α • X β 属 于 I } 。\n直观上说，若 I 是对某个活前缀 γ 有效的项目集， 那么，GO(I，X) 便是对 γX 有效的项目集\n示例：项目集的转移函数计算 LR(0)项目集规范族的构造算法 PROCEDURE ITEMSETS(G′)； BEGIN C:={CLOSURE({S′→•S})}； REPEAT FOR C中每个项目集I和G′的每个符号X DO IF GO(I，X)非空且不属于C THEN 把GO(I，X)放入C族中; UNTIL C不再增大 END 两种构造识别活前缀的DFA的方法 1.项目→ NFA → DFA 2.Closure → GO → DFA 构造LR(0)分析表 LR(0)分析表的构造 假若一个文法G的拓广文法G′的活前缀识别自动机中的每个状态(项目集)不存在下述情况：\n既含移进项目又含归约项目； 含有多个归约项目 则称G是一个LR(0)文法。\n构造LR(0)分析表的算法 令每个项目集 Ik​ 的下标 k 作为分析器的状态，包含项目 S′→•S 的集合 Ik​ 的下标 k 为分析器的初态。 构造 LR(0) 分析表的 ACTION 和 GOTO 子表 LR(0)分析表的ACTION和GOTO子表构造 若项目 A→α•aβ 属于 Ik ​且 GO( Ik ​, a ) ＝ Ij​ ，a为终结符，则置 ACTION[ k , a ] 为“ sj​ ”。\n若项目 A→α• 属于 Ik​ ，那么，对 任何终结符a(或结束符#) ， 置 ACTION[ k , a ] 为“rj​ ”(假定产生式A→α 是文法 G′ 的第 j 个产生式)。\n若项目 S′→S• 属于 Ik​ ，则置 ACTION[k,#] 为 “ acc ”。\n若 GO( Ik​ , A )＝ Ij ​，A 为非终结符，则置 GOTO[ k , A ] = j 。\n分析表中凡不能用规则 1 至 4 填入信息的空白格均置上 “报错标志”。\n示例：LR(0)分析表的构造 LR(0)分析示例 第13章 自下而上分析4 SLR(1)分析法 一个非LR(0)文法 从这个文法的DFA可以看出，某些状态既是规约态，也是移进态，这样就是一个非LR(0)文法：\nI1、I2和I9都含有“移进－归约”冲突，可以看出冲突的项目集中的项目的 FOLLOW集合是相交的。\n冲突解决办法 假定一个LR(0)规范族含有如下的一个项目集 (状态) I ＝ { X → α • b β ， A → α • ， B → α • } I＝\\{\\color{blue}{X→α•bβ}，\\color{red}{A→α•}，\\color{fuchsia}{B→α•}\\color{black}{\\}} I＝{X→α•bβ，A→α•，B→α•} F O L L O W ( A ) \\color{red}{FOLLOW(A)} FOLLOW(A) 和 F O L L O W ( B ) \\color{fuchsia}{FOLLOW(B)} FOLLOW(B) 的交集为 ∅ ∅ ∅ ，且不包含 b \\color{blue}{b} b 当状态 I I I 面临任何输入符号 a a a 时，可以: 1. 若 a = b ， 则 移 进 ； \\color{blue}{1.若a=b，则移进；} 1.若a=b，则移进； 2. 若 a ∈ F O L L O W ( A ) ， 用 产 生 式 A → α 进 行 归 约 ； \\color{red}{2.若a∈FOLLOW(A)，用产生式A→α进行归约； } 2.若a∈FOLLOW(A)，用产生式A→α进行归约； 3. 若 a ∈ F O L L O W ( B ) ， 用 产 生 式 B → α 进 行 归 约 ； \\color{fuchsia}{3.若a∈FOLLOW(B)，用产生式B→α进行归约； } 3.若a∈FOLLOW(B)，用产生式B→α进行归约； 4.此外，报错。 SLR(1)冲突解决办法 假定LR(0)规范族的一个项目集 I = { A 1 → α • a 1 β 1 ， A 2 → α • a 2 β 2 ， … ， A m → α • a m β m ， B 1 → α • ， B 2 → α • ， … ， B n → α • } I=\\{\\color{blue}{A_1→α•a_1β_1， A2→α•a_2β_2，…，A_m→α•a_mβ_m}，\\color{red}{B_1→α•，B_2→α•，…， B_n→α•} \\color{black}{\\}} I={A1​→α•a1​β1​，A2→α•a2​β2​，…，Am​→α•am​βm​，B1​→α•，B2​→α•，…，Bn​→α•} 如果集合 { a 1 ， … ， a m } \\color{blue}{\\{a_1，…，a_m}\\} {a1​，…，am​}， F O L L O W ( B 1 ) ， … ， F O L L O W ( B n ) \\color{red}{FOLLOW(B_1)，…， FOLLOW(B_n)} FOLLOW(B1​)，…，FOLLOW(Bn​)两两不相交(包括不得有两个FOLLOW集 合有#)，则当状态I面临任何输入符号a时：\n1. 若 a 是 某 个 a i ， i = 1 , 2 , … , m ， 则 移 进 ； \\color{blue}{1. 若a是某个ai，i=1,2,…,m，则移进；} 1.若a是某个ai，i=1,2,…,m，则移进； 2. 若 a ∈ F O L L O W ( B i ) ， i = 1 , 2 , … , n ， 则 用 产 生 式 B i → α 进 行 归 约 ； \\color{red}{2. 若a∈FOLLOW(B_i)，i=1,2,…,n，则用产生式Bi→α 进行归约； } 2.若a∈FOLLOW(Bi​)，i=1,2,…,n，则用产生式Bi→α进行归约； 3. 此 外 ， 报 错 。 \\color{black}{3. 此外，报错。 } 3.此外，报错。 SLR(1)解决办法：S-Simple，1-最多向前看一个单词\n构造SLR(1)分析表的方法 把G拓广为G′ 对G′构造 LR(0)项目集规范族C 活前缀识别自动机的状态转换函数GO 使用C和GO，构造SLR分析表 令每个项目集Ik的下标k作为分析器的状态，包含项 目S′→•S的集合Ik的下标k为分析器的初态。 构造分析表的ACTION和GOTO子表 SLR(1)分析表的ACTION和GOTO子表构造 1.若项目 A → α • a β A→α•aβ A→α•aβ 属于 I k I_k Ik​ 且 G O ( I k , a ) = I j GO(I_k,a)=I_j GO(Ik​,a)=Ij​ ， a a a 为终结符，则置\nA C T I O N [ k , a ] = s j ACTION[k,a] = s_j ACTION[k,a]=sj​； 2.若项目 A → α • A→α• A→α• 属于 I k I_k Ik​ ，那么，对任何终结符 a ∈ F O L L O W ( A ) \\color{red}{a∈FOLLOW(A)} a∈FOLLOW(A) ，置 A C T I O N [ k , a ] ACTION[k,a] ACTION[k,a] 为“ r j r_j rj​ ”；其中，假定 A → α A→α A→α 为文法 G ′ G\u0026rsquo; G′ 的第 j j j 个产生式； 3.若项目 S ′ → S • S\u0026rsquo;→S• S′→S• 属于 I k I_k Ik​ ，则置 A C T I O N [ k , # ] 为 “ a c c ” ACTION[k,\\#]为“acc” ACTION[k,#]为“acc”; 4.若 G O ( I k , A ) ＝ I j GO(I_k,A)＝I_j GO(Ik​,A)＝Ij​ ， A A A 为非终结符，则置 G O T O [ k , A ] = j GOTO[k,A]=j GOTO[k,A]=j； 5.分析表中凡不能用规则1至4填入信息的空白格均置上 “报错标志” 。 SLR(1)和LR(0)分析表构造方法的对比 可以看出，SLR处理冲突的解决方法就是将以前分析表中规约的一行缩小成为FOLLOW的字符，减少冲突的可能（显然这样也不是最优的，也可能产生冲突的）\nSLR(1)文法 按上述方法构造出的ACTION与GOTO表如果 不含多重入口，则称该文法为SLR(1)文法。 使用SLR表的分析器叫做一个SLR分析器。 每个SLR(1)文法都是无二义的。但也存在许多 无二义文法不是SLR(1)的。 L R ( 0 ) ⊂ S L R ( 1 ) ⊂ 无 二 义 文 法 LR(0) ⊂SLR(1) ⊂无二义文法 LR(0)⊂SLR(1)⊂无二义文法 SLR(1)分析表构造示例 对于上面那个会产生冲突的LR(0)文法，更改其中产生 规约 步骤的分析表产生规则，使用FOLLOW来代替：\n一个非SLR(1)文法 对于这样一个文法，它的SLR分析表是会产生冲突的：\nSLR冲突消解存在的问题 SLR在方法中，如果项目集 I i I_i Ii​ 含项目 A → α • \\color{#08f}{A→α•} A→α• 而且下一输入符号 a ∈ F O L L O W ( A ) \\color{#08f}{a∈FOLLOW(A)} a∈FOLLOW(A) ，则状态 i i i 面临 a a a 时，可选用“用 A → α A→α A→α 归约”动作 但在有些情况下，当状态i显现于栈顶时，当前单词是a， 栈里的 活前缀 β α \\color{#08f}{β}\\color{purple}{α} βα 未必允许把 α \\color{purple}{α} α 归约为 A \\color{purple}{A} A ，因为可能根本 就不存在一个形如“ β A a \\color{#08f}{β}\\color{purple}{A}\\color{#0f5}{a} βAa ”的规范句型 在这种情况下，用“A→α”归约不一定合适 原因是： FOLLOW集合提供的信息太泛 F O L L O W ( A ) = { α ∣ S ⇒ ∗ … A α … , α ∈ V T } FOLLOW(A)=\\{\\alpha|S⇒^*…A\\alpha \\dots, \\alpha∈V_T\\} FOLLOW(A)={α∣S⇒∗…Aα…,α∈VT​} LR(1)分析表的构造 构造LR(1)分析表的方法 把G拓广为G′ 对G′构造LR(1)项目集规范族C和活前缀识别自 动机的状态转换函数GO 使用C和GO，构造LR(1)分析表 LR(k)项目 LR(k)项目 ：扩展LR(0)项目，附带有k个终结符 [ A → α • β , a 1 a 2 … a k ] [A→α•β, a_1a_2…a_k] [A→α•β,a1​a2​…ak​] a 1 a 2 … a k a_1a_2…a_k a1​a2​…ak​ 称为 向前搜索符串(或展望串) 。 归约项目 [ A → α • ， a 1 a 2 … a k ] [A→α•，a_1a_2…a_k] [A→α•，a1​a2​…ak​] 的意义：当它所属的状态呈现在栈顶且后续的k个输入符号为 a 1 a 2 … a k a_1a_2…a_k a1​a2​…ak​ 时，才可以把栈顶上的α归约为A 对于任何 移进 或 待约项目 [ A → α • β , a 1 a 2 … a k ] , β ≠ ε [A→α•β, a_1a_2…a_k] , β≠ε [A→α•β,a1​a2​…ak​],β​=ε ，搜索符串 a 1 a 2 … a k a_1a_2…a_k a1​a2​…ak​ 没有直接作用 有效项目 形式上我们说一个LR(1)项目 [ A → α • β , a ] [\\color{red}{A}→\\color{#08f}{α}•\\color{#0f8}{β} \\color{black}{,} \\color{purple}{a}] [A→α•β,a] 对于活前缀 γ \\color{#08f}{γ} γ 是 有效的 ，如果存在规范推导 : S ′ ⇒ R ∗ δ A ω ⇒ R ∗ δ α β ω S\u0026rsquo;⇒^_R \\color{#08f}{\\delta} \\color{red}{A} \\color{purple}{\\omega} \\color{black}{⇒^_R} \\color{#08f}{\\delta} \\color{#08f}{α} \\color{#0f8}{β} \\color{purple}{\\omega} S′⇒R∗​δAω⇒R∗​δαβω\n其中，1) γ ＝ δ α \\color{#08f}{γ＝δα} γ＝δα ；2) a \\color{purple}{a} a 是 ω \\color{purple}{ω} ω 的第一个符号，或者 a \\color{purple}{a} a 为#而 ω \\color{purple}{ω} ω 为ε。\n有效项目的性质 LR(1)项目集规范族 闭包函数CLOSURE 转换函数GO 项目集的闭包CLOSURE 假定I是文法G′的任一项目集，定义和构造I的闭 包CLOSURE(I)如下：\n1.I的任何项目都属于 C L O S U R E ( I ) CLOSURE(I) CLOSURE(I) 。 2.若项目 [ A → α • B β , a ] [A→α•Bβ, a] [A→α•Bβ,a] 属于 C L O S U R E ( I ) CLOSURE(I) CLOSURE(I) ， B → ξ B→ξ B→ξ 是一个产生式，那么，对于 F I R S T ( β a ) FIRST(βa) FIRST(βa) 中的每个 终结符b，如果 [ B → • ξ , b ] [B→•ξ, b] [B→•ξ,b] 原来不在 C L O S U R E ( I ) CLOSURE(I) CLOSURE(I) 中，则把它加进去。 3.重复执行步骤2，直至 C L O S U R E ( I ) CLOSURE(I) CLOSURE(I) 不再增大为止。 项目集的转换函数GO 令I是一个项目集，X是一个文法符号，函数 GO(I，X)定义为： G O ( I ， X ) ＝ C L O S U R E ( J ) GO(I，X)＝CLOSURE(J) GO(I，X)＝CLOSURE(J) ,其中 J ＝ { 任 何 形 如 [ A → α X • β , a ] 的 项 目 ∣ [ A → α • X β , a ] ∈ I } J＝\\{ 任何形如[ A→αX•β, a]的项目 | [ A→α•Xβ, a]∈I \\} J＝{任何形如[A→αX•β,a]的项目∣[A→α•Xβ,a]∈I}\nLR(1)项目集规范族的构造算法 BEGIN C:={ CLOSURE( { [S′→•S，#] }) }; REPEAT FOR C中每个项目集I和G′的每个符号X DO IF GO(I，X)非空且不属于C，THEN 把GO(I，X)加入C中 UNTIL C不再增大 END LR(1)分析表的构造算法 把G拓广为G′ 对G′构造LR(1)项目集规范族C和活前缀识别自 动机的状态转换函数GO 使用C和GO，构造LR(1)分析表 令每个Ik的下标k为分析表的状态，令含有[S′→•S, #] 的Ik的k为分析器的初态 构造LR(1)分析表的ACTION和GOTO子表 LR(1)分析表的ACTION和GOTO子表构造 1.若项目[A→α•aβ, b]属于Ik且GO(Ik, a)＝Ij，a为 终结符，则置ACTION[k, a]为“sj”。 2.若项目[A→α•，a]属于Ik，则置ACTION[k, a]为 “rj”；其中假定A→α为文法G′的第j个产生式。 3.若项目[S′→S•, #]属于Ik，则置ACTION[k, #]为 “acc”。 4.若GO(Ik，A)＝Ij，则置GOTO[k, A]=j。 5.分析表中凡不能用规则1至4填入信息的空白栏 均填上“出错标志”。 LR(1)和SLR(1)分析表构造方法的对比 可以看出，与SLR相比，在规约中更加缩小了可规约的情况，使得冲突减小\nLR(1)分析表和LR(1)文法 按上述算法构造的分析表，若不存在多重定义 的入口(即，动作冲突)的情形，则称它是文法G 的一张规范的LR(1)分析表。 具有规范的LR(1)分析表的文法称为一个LR(1)文法。 使用LR(1)分析表的分析器叫做一个规范的LR分析器。 LR(1)状态比SLR(1)多 L R ( 0 ) ⊂ S L R ( 1 ) ⊂ L R ( 1 ) ⊂ 无 二 义 文 法 LR(0) ⊂SLR(1) ⊂LR(1) ⊂无二义文法 LR(0)⊂SLR(1)⊂LR(1)⊂无二义文法 LR(1)分析表构造示例 分析器产生工具 分析器产生器——YACC YACC——Yet AnotherCompiler Compiler\nLALR(1)分析 GNU Bison：基本兼容Yacc，与flex一起使用 The Lex \u0026amp; YaccPage http://dinosaur.compilertools.net/ 参考 学习所用，参考自[CSDN 博主 pi31415926535x ][https://blog.csdn.net/pi31415926535x/article/details/105299131]\n","date":"2025-03-19T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90/","title":"编译原理-语法分析-自下而上分析"},{"content":"《轮回乐园》(已完结) 作品简介 苏晓签订轮回契约，进入各个世界执行任务。 他曾目睹一个世界崩灭为尘粒，也曾与被遗忘的王者持刃而战。 暗鸦在低语，黑渊下巨兽咆哮。 欢迎来到，轮回乐园……\n起点 轮回乐园\n百度百科 ​\t《轮回乐园》是由作家那一只蚊子创作的网络无限流小说，于2017年6月23日连载于起点中文网，完结于2025年3月14日，连载共4175章，1444.2万字。\n​\t小说主要讲述了主角苏晓在轮回世界中逐渐变强的成长历程。苏晓签订轮回契约，进入各个世界执行任务。故事中，他目睹了一个世界的崩灭，与被遗忘的王者战斗，面对暗鸦的低语和黑渊下巨兽的咆哮。苏晓是一名独行侠，通过一步一步的努力，逐渐变得更加强大。\n2025-03-16\n​\t从初中开始看的小说也终于是完结了，一转眼已经大学了，感谢多年的陪伴。现在还依稀记得以前追小说的时光，那时候充不了钱，把小说下载在 mp4 上，自习课上一页一页慢慢读，因为是盗版，偶尔会有乱码，但这依旧让我喜欢，后面有条件了就在起点上看，可以说起点就是因为这本书下载的。\n《全球影帝》(未完结) 作品简介 “他是《拳王》中的铁血硬汉。” “也是《百年之恋》中的孤独老人。” “是《股市大亨》中花天酒地的金融巨鳄。” “还是《赎罪》中的疯狂且残忍的冷血杀手。” “是草根，也是现代体验派表演形式的国际公认大师。” “可退出戏外，他只是一个喜欢喝喝小酒的普通男人。” “草根亦可走向巨幕，这是一个有关于奋斗的故事。”\n起点 全球影帝\n2025-04-18\n已看到最新章节555《无可倾听》杀青\n","date":"2025-03-16T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E5%AE%8C%E7%BB%93%E4%B9%A6%E5%8D%95/","title":"完结书单"},{"content":"少女乐队的呐喊（Girls Band Cry） 剧情简介 高中二年级时退学，独自一人以上大学为目标前往东京的主角。\n被朋友背叛不知道该怎么办的少女。\n被父母抛弃，在大城市中独自打工维持生计的女孩。\n这个世界总是背叛我们。\n什么事情都不会按照我们的意愿发展。\n但是，因为我们有热爱着的事物。\n因为我们相信有属于自己的容身之处。\n所以、高歌着。\n以上来自萌娘百科\n2025-03-14\n义妹生活 剧情简介 “两人的距离日渐缩短，慢慢建立起兄妹以上却与家人有所不同的关系”\n由于父亲再婚，高中生浅村悠太和学年第一美少女绫濑沙季成为同住一个屋檐下的兄妹。 都见过双亲感情破裂的两人对男女之间的关系慎重看待，约好要保持适度的距离，既不接近也不对立。\n沙季渴望亲情而一直独自努力，因此不懂得如何依赖别人，悠太也不晓得该怎么以哥哥的身份与她相处。\n某些地方十分相似的两人，逐渐感受到与对方生活是多么惬意\u0026hellip;\u0026hellip;\n这是一个可能会发展成恋爱的故事。\n原本素昧平生的男女，一点一点地接近、彼此关系渐渐改变的——恋爱生活小说。\n以上来自萌娘百科\n2025-03-15\nBanG Dream! Ave_Mujica 背景 《BanG Dream! Ave_Mujica》（bilibili方面译名：《颂乐人偶》）是少女乐团企划《BanG Dream!》旗下的，以Ave Mujica为主角的TV动画。\n本动画为《BanG Dream! It\u0026rsquo;s MyGO!!!!!》的续篇。2023年9月14日，即前篇完结之日宣布制作决定，当日为新月。\n2024年1月6日，在“Bushiroad新春大发表会2024”上宣布动画于2025年1月播出。2024年10月17日，公开PV2，宣布动画于2025年1月2日播出，并从2024年12月1日起在全球多地举办先行上映会。\n剧情介绍 ​ **“ 我不是说了吗？请把你剩余的人生交给我 ” **\n由丰川祥子招募成员的乐队Ave Mujica， 通过现场演出和媒体曝光灯，取得了商业上的成功。\n她失去了发誓一生在一起的伙伴，和自己出生长大的家。 她究竟是为了什么而背负别人的一生，继续维系着乐队？\n她用面具掩盖过往和真实的自我，今晚也降临在完美的箱庭中。 ——接下来将为您呈现的是，怀揣着秘密的，她的故事。\n以上来自萌娘百科\n2025-03-28\n四月是你的谎言 故事简介 四月，与你相遇的四月，就要来了，再也没有你的四月，就要来了。 [有马公生]\n**“ 一个人借着黑白键的阶梯走出了地狱， 一个人凭着梵婀玲的琴弓攀上了天堂 ” **\n从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n初中三年级时，在青梅竹马椿的引见下，公生认识了与他同年级的小提琴手——宫园薰，并于一场比赛中被薰自由奔放的演奏风格所吸引。\n自此，公生的日常生活开始有了改变。\n以上来自萌娘百科\n2025-04-05\nEVA（新世纪福音战士）TV版 EVA（新世纪福音战士）剧场版 死与新生 EVA（新世纪福音战士）剧场版 真心为你 神作毋庸置疑！\n2025-04-11\nEVA（新世纪福音战士）新剧场版 序 EVA（新世纪福音战士）新剧场版 破 2025-04-19\nEVA（新世纪福音战士）新剧场版 Q EVA（新世纪福音战士）新剧场版 终 另一个方向的EVA，好看！\n2025-04-21\n","date":"2025-03-14T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E6%88%91%E7%9A%84%E7%9C%8B%E7%95%AA%E8%AE%B0%E5%BD%95/","title":"我的看番记录"},{"content":"2025 年 建国大业 1822.6万播放 · 13.5万弹幕 · 54.5万系列追剧\n剧情 / 历史 · 2009年09月16日上映 · BV1WW411v7qr\n出演演员：唐国强、张国立、陈坤、王学圻、李连杰、胡军、孙红雷、尤勇、陈凯歌、刘烨、吴刚、黎明、陈好、黄晓明、范伟、张涵予、姜文、冯小刚、成龙、佟大为、王宝强、葛优、陈道明、郭晓东、冯远征、甄子丹、邓超、冯巩、郭德纲、梁家辉、章子怡、刘德华、陈宝国\n简介：抗战结束后，各阶级、各党派、广大人民群众反战情绪高涨。在民主爱国人士张澜等人的斡旋下，毛泽东代表的共产党与蒋介石代表的国民党拉开了重庆谈判的序幕。为表诚意，共产党主动放弃了部分占领的解放区，然而，国民党却丝毫没有建立民主政府的意思，反而驱赶民主党派，逐渐走向了军政府独裁统治的灭亡之路。期间，以毛泽东为首的共产党人通过建立广泛的爱国统一战线，获得了全中国人民群众的支持，与此同时，垂死挣扎的国民党仍妄图借助阴谋暗杀等卑劣手段阻挠会议召开。一场为建立新中国的决战由此展开。\n以上来自 Bilibili\n03 月 13 日\n​\t《建国大业》虽然只有两个小时，却让我更加真切地了解了那段历史，毛泽东，周恩来等人赴重庆谈判拉开序幕，接下来依次向讲述了撕毁《双十协定》，校门口事件，辽沈战役，淮海战役，渡江战役，定都北平，政治协商会议，开国大典等一系列的重大历史事件。\n​\t《建国大业》有很多感动人心、令人动容的画面，最令我感动的镜头就是解放上海以后，宋庆龄夫人走出家门，看到一名名战士整齐睡在路边，怀里还抱着战斗的武器，这一刻，有轨电车缓缓驶来，动与静之间，在镜头与音乐的共同作用下，我感受到了一种安宁，眼泪不知道怎得夺眶而出。借用弹幕的一句话“ 我们今天的生活就是最大的彩蛋！ ”\n","date":"2025-03-14T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E5%BD%B1%E8%A7%86%E8%AE%B0%E5%BD%95/","title":"影视记录"},{"content":"\n「中文填词」被生命所厌恶 若以爱来维系生息啊\n尚能感受的温度是虚假\n我该说点什么开朗的话\n勉强欺瞒住自己呢\n若以死亡作为人生终点的话\n世界上怎么还有人悲伤啊\n春日责备我没有灵魂的躯壳\n将我厌弃了吧\n要生命疯狂爆发开出鲜花\n却被世界压抑沉默着融化\n他们施舍活着才有希望\n不过虚与委蛇的假话\n幕后隐去甚至听不见怜悯的欺诈\n囿于困惑中写不下绝笔的狠话\n如蝴蝶在风暴之中竭力挣扎\n能否来人给予回答\n音乐哽住咽喉意欲将爱谋杀\n妄图写下本就虚无的才华\n以此博得关注在诞生刹那\n将发声的初心一并腐化\n春天拽住神经意欲将它谋杀\n羸弱的翼羽该如何挽留它\n浑浊开辟前无足轻重的我\n理所当然的被地球憎恶着\n疲倦滋养着懒惰的借口\n心安理得沉睡却又焦虑的寂寞\n再多找补都标为哗众取宠\n固执反复扼杀向外界的祈求\n囚笼把月光不等割裂着\n即便是这样也能容忍着苟活吗\n沉醉夜晚才敢呼吸吧\n被爱的幻影看够了吗\n如此锈迹斑驳的盛夏\n该怎样告慰以腐朽的韶华\n反刍遮掩受之有愧的伤疤\n等无关痛痒就继续活吧\n若真有代替谁死去的童话\n也算奉献上唯一的用处吧\n生死选择间又会僵持不下\n怎配说出要像常人般活下去啊\n倾尽所有也跨不过那条鸿沟吧\n能否抓起刀在大雨中放肆奔跑\n被谁的文字感化\n画面中的人也会怕再次死去啊\n在蜡炬燃尽前撷下摇摆的枝丫\n想让宇宙听到高谈阔论的吉他\n在真空中也可抵达\n情感刺激味蕾意欲将胃谋杀\n吞吐最无知还顽劣的想法\n如此幼稚好似孩童学说话\n奢望幸福而无法触及它\n诗篇拖住灵魂意欲将梦谋杀\n偏偏远方荣光从未应许它\n残喘的每一天本就是刑罚\n顺理成章缝补生活的疮疤\n幸福吗 亲情吗 友情吗 爱情吗\n若是贩卖机之中的梦话\n在清醒前用碎银全部购买下\n即使明了终是徒劳也要做吗\n明知时间不会回馈给任何报答\n日升啊 月落啊 春秋来 夏冬去\n不变的是每天都有人死去的命题\n未来吗 当下吗 怎样才算尽头\n濒死前 却还想着能拉谁一把\n终于 找回了 遗落在途中那首孩子的歌\n生命掐住脐带将希冀谋杀\n窥见她的泪拥抱抢先作答\n我偏要 孤身继续 向着必死的绝路大胆迈进\n流言充斥屏幕也没办法将我谋杀\n倔强是人生完美的勋章\n腐朽前 总要\n挣扎\n尖叫\n奔跑\n大笑\n拥抱\n将残缺接纳\n转自：被生命所厌弃[中文填词]\n\u0026ldquo;音乐哽住咽喉意欲将爱谋杀”【翻唱】被生命所厌恶\n","date":"2025-03-13T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E8%A2%AB%E7%94%9F%E5%91%BD%E6%89%80%E5%8E%8C%E5%BC%83%E4%B8%AD%E6%96%87%E5%A1%AB%E8%AF%8D/","title":"被生命所厌弃（中文填词）"},{"content":"\n编译原理知识汇总 编译原理 绪论 从面向机器的语言到面向人类的语言 汇编指令： 用符号表示的指令被称为汇编指令 汇编语言： 汇编指令的集合称为汇编语言\n语言之间的翻译 转换 (也被称为 预处理 )：高级语言之间的翻译\n编译： 高级语言可以直接翻译成机器语言，也可以翻译成汇编语言，这两个翻译过程称为编译 汇编： 从汇编语言到机器语言的翻译被称为汇编 交叉汇编： 将一个汇编语言程序汇编成为可在另一机器上运行的机器指令成为交叉汇编 反汇编： 把机器语言翻译成汇编语言 反编译： 把汇编语言翻译成高级语言\n课程内容 介绍设计和构造编译程序的基本原理和基本实现技术\n三种程序 翻译程序\n编译程序（compiler）：把某一种高级语言程序等价转换成另一种低级语言程序（如汇编或机器语言）的程序\n解释程序\n编译器与解释器 （1）语言翻译的两种基本形态\n解释器与编译器的主要区别: 运行目标程序时的控制权在 解释器而不在目标程序.\n（2）各自特点\n编译器:工作效率高,即时间快、空间省；交互性与动态性差,可移植性差. 解释器:工作效率低,即时间慢、空间费；交互性与动态性好,可移植性好. 共同点:均完成对 源程序的翻译. 差异:编译器采用先翻译后执行,解释器采用边翻译边执行.\n编译器的工作原理与基本组成 （1）以阶段划分编译器\n注：符号表管理器和出错处理贯穿编译器工作的各个阶段.\n（2）编译器各阶段工作\n1 \u0026gt; 词法分析： 词法分析的 输入 是 源程序, 输出 是识别出的 记号流. 目的 是 识别单词. 至少分以下几类：关键字(保留字)、标识符、字面量、特殊符号\n2 \u0026gt; 语法分析： 输入 是词法分析器返回的 记号流, 输出 是 语法树. 目的 是得到语言结构并以树的形式表示.对于声明性语句,进行符号表的查填,对于可执行语句,检查结构合理的表达式运算是否有意义.\n3 \u0026gt; 语义分析： 根据语义规则对语法树中的语法单元进行静态语义检查,如类型检查和转换等, 目的 在于保证语法正确的结构在语义分析上也是合法的.\n4 \u0026gt; 中间代码生成(可选)： 生成一种既接近目标语言,又与具体机器无关的表示,便于代码优化与代码生成.\n(到目前为止，编译器与解释器可以一致)\n5 \u0026gt; 中间代码优化(可选)： 局部优化、循环优化、全局优化等；优化实际上是一个等价变换，变换前后的指令序列完成同样的功能，但在占用的空间上和程序执行的时间上都更省、更有效\n6 \u0026gt; 目标代码生成： 不同形式的目标代码—汇编语言形式、可重定位二进制代码形式、内存形式\n7 \u0026gt; 符号表管理： 合理组织符号,便于各阶段查找\\填写等.\n8 \u0026gt; 出错处理： 动态错误：源程序中的逻辑错误，发生在程序运行的时候。也称为动态语义错误 静态错误：静态错误分为语法错误和静态语义错误. \u0026lt;1\u0026gt; 语法错误：有关语言结构上的错误，如单词拼写错误、表达式缺少操作数、begin和end不匹配 \u0026lt;2\u0026gt; 静态语义错误：分析源程序时可以发现的语言意义上的错误，如加法的两个操作数一个是整形变量，另一个是数组名\n（3）编译器的分析\\综合模式\n逻辑上把编译器分为 分析(前端)部分和 综合(后端)部分. 1\u0026gt; 分析(前端)：语言结构和意义的分析； 从词法分析到中间代码生成各阶段的工作 2\u0026gt; 综合(后端)：语言意义处理；从中间代码生成到目标代码生成的各阶段的工作 3\u0026gt; 编译器和解释器的区别往往是在形成中间代码之后开始的.\n编译器扫描的遍数 每个阶段将程序完整分析一遍的工作模式称为一遍扫描。 (将源程序或源程序的某种形式的中间表示完整分析一遍，亦称作一遍扫描)\n高级语言及语法描述 程序语言的定义 程序语言由 语法 和 语义 两方面定义\n语法 词法规则：单词符号的形成规则 描述工具：有限自动机 语法规则：语法单位的形成规则 描述工具：上下文无关文法 语义 程序语言的语法 程序语言的语法描述 概念 有穷 字母表（字符集） Σ 中每一个元素称为一个字符 Σ 上的字（也叫字符串） 是指由 Σ 中的 字符所构成的一个有穷序列 空字 ε ：不包含任何字符的序列 Σ* ：表示 Σ 上的所有字的全体，包含空字 ε Σ* 的子集 U 和 V 的**连接（积）**定义为 UV = { αβ| α∈U , β∈V } V*：闭包 V+：正规闭包 上下文无关文法 文法：描述语言的语法结构的形式规则 （或语法规则）\n上下文无关文法的定义：\n一个上下文无关文法 G 是一个四元式 G =(VT, VN, S, P)，其中:\n​\tVT: 终结符集合( 非空 )\n​\tVN: 非终结符集合( 非空 )\n​\tS: 文法的开始符号\n​\tP: 产生式集合\n产生式（文法的简化表示方法）\n$$ 例： G ( E ) : E \\rightarrow i | E + E | E * E | (E) $$\n上下文无关文法的中心思想： 从文法的开始符号出发，反复连续使用产生式，对非终结符实行替换和展开 句型 句子: 只含终结符的句型 文法 \u0026mdash;\u0026gt; 语言 构造某语言文法的方法 采用凑规则的方法来完成：\n找出语言的若干句子 分析句子的特点 根据句子的特点凑规则 形成文法 检验 $$ 构造生成 L = {a^n b^n c^i | n \\geq 1, i \\geq 0 }语言的文法: \\ G[ Z ]: Z \\rightarrow AB|A \\ A \\rightarrow aAb|ab \\ B \\rightarrow cB|c \\ $$\n最左推导 最右推导 语法树与二义性 用一张图表示一个句型的推导，称为语法树 语言二义性 文法二义性： 可以改造为无二义 形式语言鸟瞰 $$ 产生式: α \\rightarrow β $$\n0型文法: α 至少含有一个终结符\n1型文法( 上下文有关文法 ): |α | \u0026lt;= |β| ,表示长度\n2型文法( 上下文无关文法 ): α 只能是一个非终结符, 如 A\n3型文法( 正规文法，有限自动机 ): α 只能是一个非终结符, 且 β 只能是 αB( Bα ) 或 α\n​\t描述能力从上至下逐渐减弱，为包含关系\n词法分析 词法分析中的若干问题 (1) 记号、模式与单词\n单词的分类： 关键字(保留字)、标识符、字面量、特殊符号 模式（pattern） ：产生/识别单词的规则 记号（token） ：按照某个模式(或规则)识别出的元素(一组) 单词（lexeme） ：被识别出的元素的值(字符串本身) ，也称为词值\n(2) 词法分析器的作用与工作方式\n词法分析器的作用：\n识别记号并交给语法分析器(根据模式识别记号) 滤掉源程序中的无用成分,如注释、空格和回车等 处理与具体平台有关的输入(如文件结束符的不同表示等) 调用符号表管理器和出错处理器，进行相关处理 工作方式：\n单独一遍扫描 作为语法分析器的子程序 并行方式 模式的形式化描述 (1) 字符串与语言\n语言L 是有限字母表∑上有限长度字符串的集合. 定义中强调两个有限，因为计算机的表示能力有限 ： 1\u0026gt; 字母表是有限的，即字母表中元素是有限多个； 2\u0026gt; 字符串的长度是有限的，即字符串中字符个数是有限多个。\n(字符串与字符串集合相关的概念与运算,如前缀、后缀、子串、子序列等，字符串的并、交、连接、差、闭包)\n(2) 正规式与正规集 令Σ是一个有限字母表，则Σ上的 正规式 及其表示的集合递归定义如下:\nε是正规式，它表示集合 L(ε) = {ε} 若a是Σ上的字符，则a是正规式，它表示集合L(a)={a} 若正规式r和s分别表示集合L(r)和L(s)，则 （a） r|s 是正规式，表示集合 L(r)∪L(s)， （b） rs 是正规式，表示集合 L(r)L(s)， （c） r* 是正规式，表示集合 (L(r))*， （d）( r ) 是正规式，表示的集合仍然是 L(r)。 括弧用来改变运算的先后次序！ 可用正规式描述(其结构)的语言称为 正规语言 或 正规集 。 若运算的优先级和结合性做下述约定:\n三种运算均具有左结合性质； 优先级从高到低顺序排列为:闭包运算、连接运算、或运算。 则正规式中不必要的括号可以被省略。 若正规式P和Q表示了同一个正规集，则称P和Q是 等价 的，记为P = Q (3) 简化正规式描述(主要是简化书写上的复杂) (a) 正闭包 若r是表示L(r)的正规式，则r+是表示(L(r))+的正规式，且下述等式成立:r+ = rr* = rr，r = r+|ε;\t+与*具有相同的运算结合性和优先级 (b) 可缺省 若r是正规式，则r?是表示L(r)∪{ε}的正规式，且下述等式成立:r? = r|ε\t? 与 * 具有相同的运算结合性和优先级 (c) 串 若r是若干字符进行连接运算构成的正规式，则:串“r” = r ，且: ε= “”， a = “a”（a是Σ的任一字符） (d) 字符组 若r是若干字符进行|运算构成的正规式，则可改写为 [r’]，其中r’可以有如下两种书写形式： 枚举: 如 a|b|e|h，可写为 [abeh]： 分段: 如0|1|2|3|4|5|6|7|8|9|a|b|c|d|e , 可写为： [0-9a-e] (e) 非字符组 若[r]是一个字符组形式的正规式，则[^r]是表示∑- L([r])的正规式。\n记号的识别——有限自动机 (1) 不确定的有限自动机（NondeterministicFinite Automaton, NFA）\nNFA是一个五元组（5-tuple）：M =（S，∑，move，s0，F），其中 （1） S是有限个状态（state）的集合； （2） ∑是有限个输入字符（包括ε）的集合； （3） move是一个状态转移函数，move(si，ch)=sj表示，当前状态si下若遇到输入字符ch，则转移到状态sj； （4） s0是唯一的初态（也称开始状态）； （5） F是终态集（也称接受状态集），它是S的子集，包含了所有的终态。\n\u0026lt;1\u0026gt; 直观的表示方式\n① 状态转换图：用一个有向图来直观表示NFA ② 状态转换矩阵：用一个矩阵来直观表示NFA (矩阵中，状态对应行，字符对应列)\n\u0026lt;2\u0026gt; NFA(识别记号)的特点 NFA识别记号的最大特点是它的不确定性，即在当前状态下对同一字符有多于一个的下一状态转移。 具体体现： 定义： move函数是1对多的； 状态转换图：从同一状态出发，可通过多于一条标记相同字符的边转移到不同的状态； 状态转换矩阵： M[si,a]是一个状态的集合\n\u0026lt;3\u0026gt; NFA识别记号存在的问题\n1.只有尝试了全部可能的路径,才能确定一个输入序列不被接受,而这些路径的条数随着路径长度的增长成指数增长 2.识别过程中需要进行大量回朔，时间复杂度升高且算法复杂\n(2) 确定的有限自动机（Deterministic Finite Automaton, DFA） 定义: DFA是NFA的一个特例，其中： （1）没有状态具有ε状态转移(ε-transition)，即状态转换图中没有标记ε的边； （2）对每个状态s和每个字符a，最多有一个下一状态。\n特点：与NFA相比，DFA的特征：确定性 定义：move（si, a)函数都是 1对1 的； 转换图 从一个状态出发的任2条边上的标记均不同； 转换矩阵：M[si,a]是一个状态 且字母表不包括ε。 提示：正规式和有限自动机从两个侧面表示正规式。正规式是描述，自动机是识别。\n从正规式到词法分析器 构造词法分析器的一般方法和步骤：\n用正规式描述模式（为记号设计正规式）； 为每个正规式构造一个NFA，它识别正规式所表示的正规集； 将构造的NFA转换成等价的DFA，这一过程也被称为确定化； 优化DFA，使其状态数最少，这一过程也被称为最小化； 根据优化后的DFA构造词法分析器。 (1) 从正规式到NFA Thompson 算法 (2) 从NFA到DFA\nsmove(S, a)：从状态集S出发，标记为a的下一状态全体。与move(s, a)的唯一区别：用状态集取代状态 ε-闭包(T)：从状态集T出发，不经任何字符达到的状态全体 “子集法”构造DFA (3) 最小化DFA\n① 对于任何两个状态t和s，若从一状态出发接受输入字符串ω，而从另一状态出发不接受ω.\n或者，② 从t出发和从s出发到达不同的接受状态，则称ω对状态t和s是可区分的.\n不可区分的状态位于一个组内，可以合并成一个状态.\n主要步骤： 1.初始划分：终态组 ， 非终态组； 2.利用可区分的概念，反复分裂划分中的组Gi，直到不可再分裂； 3.由最终划分构造D\u0026rsquo;，关键是选代表和修改状态转移； 4.消除可能的死状态和不可达状态。\n从DFA构造词法分析器 分类： 表驱动型的词法分析器；直接编码的词法分析器 比较：\n表驱动 直接编码 分析器的速度 慢 快 程序与模式的关系 无关 有关 适合的编写方法 工具生成 手工编写 分析器的规模 较大 较小 语法分析 词法分析： 记号的集合，字符串由字母组成，线性结构 语法分析： 句子的集合，句子由记号组成，非线性结构（树）\n语法分析的双重含义：\n语法规则：上下文无关文法（子集：LL文法或LR文法） 语法分析：下推自动机（LL或LR分析器）、自上而下分析、自下而上分析 语法分析的若干问题 许多编译器，特别是由自动生成工具构造的编译器，往往其前端的中心部件就是语法分析器\n（1）语法分析器的作用\n根据词法分析器提供的记号流，为语法正确的输入构造分析树（或语法树） 检查输入中的语法（可能包括词法）错误，并调用出错处理器进行适 当处理 （2）语法错误的处理原则\n源程序中可能出现的错误\n语法(包括词法)错误和语义错误(静态语义错误和动态语义错误)\n注：跟第一章的分类角度不同，第一章是从静态错误(语法错误，静态语义错误)和动态错误(动态语义错误)分类的，但是殊途同归。\n词法错误： 指非法字符或拼写错关键字、标识符等 语法错误： 指语法结构出错，如少分号、括号不匹配、begin/end不配对等 静态语义错误： 如类型不一致、参数不匹配等 动态语义错误(逻辑错误)： 如死循环、变量为零时作除数等\n上下文无关文法(CFG) （1）上下文无关文法(Context Free Grammar, CFG)\nCFG是一个四元组G =（N，T，P，S），其中 （1） N是非终结符（Nonterminals）的有限集合； （2） T是终结符（Terminals）的有限集合，且N∩T=Φ； （3） P是产生式（Productions）的有限集合，A→α，其中A∈N(左部),α∈(N∪T)*(右部),若α=ε，则称A→ε为空产生式(也可以记为A →); （4） S是非终结符，称为文法的开始符号（Start symbol） 注： S ∈ N , N可以出现在产生式左边和右边，T绝不出现在产生式左边. （2）CFG产生语言的基本方法－推导\nCFG（产生式）通过推导的方法产生语言，即（通俗地讲）从开始符号S开始，反复使用产生式：将产生式左部的非终结符替换为右部的文法符号序列(展开产生式，用=\u0026gt;表示)，直到得到一个终结符序列。\n**1 \u0026gt; 直接推导：**利用产生式产生句子的过程中，将用产生式A→γ的右部代替文法符号序列αAβ中的A得到αγβ的过程，称αAβ直接推导出αγβ，记作：αAβ=\u0026gt;αγβ\n**2 \u0026gt; 零步或多步推导：**若对于任意文法符号序列α1，α2，\u0026hellip;αn，有α1=\u0026gt;α2=\u0026gt;\u0026hellip;=\u0026gt;αn，则称此过程为零步或多步推导，记为：α1 =*=\u0026gt; αn，其中α1=αn的情况为零步推导。\n**3 \u0026gt; 至少一次推导：**若α1≠αn，即推导过程中至少使用一次产生式,则称此过程为至少一步推导，记为：α1 =+=\u0026gt; αn\n(推导具有自反性和传递性)\n4 \u0026gt; 由 CFGG 所产生的语言L(G)被定义为: L(G) = { ω┃S ωand ω∈T* }， L(G)称为上下文无关语言(Context Free Language, CFL)，ω称为句子。 若S =* \u0026gt; α，α∈(N∪T)*，则称α为G的一个句型。句子一定是句型，反之不是。\n5 \u0026gt; 在推导过程中，若每次直接推导均替换句型中最左边的非终结符，则称为 最左推导，由最左推导产生的句型被称为 左句型。 类似的可以定义最右推导与右句型，最右推导也被称为规范推导。\n（3）推导、分析树与语法树\n1、分析树既反映语言结构的实质，也反映推导过程。\n2、对CFGG的句型， 分析树 被定义为具有下述性质的一棵树。\n（1） 根由开始符号所标记； （2） 每个叶子由一个终结符、非终结符、或ε标记； （3） 每个内部结点由一个非终结符标记； （4） 若A是某内部节点的标记，且X1，X2，\u0026hellip;，Xn是该节点从左到右所有孩子的标记，则A→X1X2\u0026hellip;Xn是一个产生式。若A→ε，则标记为A的结点可以仅有一个标记为ε的孩子。\n注：分析树的叶子，从左到右构成G的一个句型。若叶子仅由终结符标记，则构成一个句子。\n3、对CFG G的句型，表达式的语法树被定义为具有下述性质的一棵树:\n（1） 根与内部节点由表达式中的操作符标记；（2） 叶子由表达式中的操作数标记；（3）用于改变运算优先级和结合性的括号，被隐含在语法树的结构中。\n语法树是表示表达式结构的最好形式 （4）二义性与二义性的消除\n二义性： 若文法G对 同 一句子产生不止一棵 分析树，则称G是二义的.\n结论： 1\u0026gt; 一个句子有多于一棵分析树，仅与文法和句子有关，与采用的推导方法无关； 2\u0026gt; 造成文法二义的根本原因：文法中缺少对文法符号优先级和结合性的规定\n二义性消除的方法： ① 改写二义文法为非二义文法； ② 规定二义文法中符号的优先级和结合性，使仅产生一棵分析树。\n语法与文法简介 （1）正规式与上下文无关文法\n记号可以用正规式描述，正规式适合描述线性结构，如标识符、关键字、注释等. 句子可以用CFG描述，CFG适合描述具有嵌套(层次)性质的非线性结构，如不同结构的句子if-then-else\\while-do等 正规式所描述的语言结构均可以用CFG描述，反之不一定.\n（2）上下文有关文法CSG\n典型的这类语言结构包含：计数问题的抽象、变量的声明与引用、过程调用时形参与实参的一致性检查等.描述它们的文法被称为上下文有关文法(Context Sensitive Grammar，CSG).这些语言结构无法用上下文无关文法CSG来描述.\n（3）形式语言与自动机简介\n若文法G=(N，T，P，S)的每个产生式α→β中，均有α∈(N∪T) ，且至少含有一个非终结符，β∈(N∪T) ，则称G为0型文法.\n对0型文法施加以下第i条限制，即得到i型文法。\n1\u0026gt; G的任何产生式α→β（S→ε除外）满足|α|≤|β|； 2\u0026gt; G的任何产生式形如A→β，其中A∈N，β∈(N∪T)*； 3\u0026gt; G的任何产生式形如A→a或者A→aB(或者A→Ba)，其中A和B∈N，a∈T。\n文法 语言 自动机 短语文法(0型) 短语结构语言 图灵机 CSG(1型) CSL 线性界线自动机 CFG(2型) CFL 下推自动机 正规文法(3型) 正规集 有限自动机 自上而下语法分析 分为：递归下降分析法、预测分析法\n基本思想： 对任何一个输入序列ω，从S开始进行最左推导，直到得到一个合法的句子或发现一个非法结构。整个自上而下分析是一个试探的过程，是反复使用不同产生式谋求与输入序列匹配的过程。\n提前准备—— 重写文法： 1.消除左递归，以避免陷入死循环； 2.提取左因子，以避免回溯.\n（1）消除左递归\n定义：若文法G中的非终结符A，对某个文法符号序列α存在推导A =+\u0026gt; Aα，则称G是左递归的。若G中有形如A→Aα的产生式，则称该产生式对A直接左递归。\n\u0026lt;1\u0026gt; 消除文法的直接左递归\nA→Aα|β 替换为 A →βA' A'→αA'|ε 首先，整理A产生式为如下形式：A → Aα1 | Aα2 | \u0026hellip; | Aαm | β1 | β2 | \u0026hellip; | βn 然后用下述产生式代替A产生式：A → β1 A\u0026rsquo; | β2 A\u0026rsquo; | \u0026hellip; | βn A' A\u0026rsquo;→ α1 A\u0026rsquo; | α2 A\u0026rsquo; | \u0026hellip; | αm A\u0026rsquo; |ε\n\u0026lt;2\u0026gt; 消除文法的左递归\n核心思想：将无直接左递归的非终结符展开到其他产生式,然后消除其他产生式中的直接左递归(如果有的话)\n若G产生句子的过程中出现A=+A的推导，则无法消除左递归(出现回路)\n（2）提取左因子\n\u0026lt;1\u0026gt; 提取文法的左因子\n左因子产生原因：公共前缀：A → αβ1|αβ2 方法：将 A → αβ1|αβ2|γ 替换为 A→αA\u0026rsquo;|γ A\u0026rsquo;→β1|β2\n（3）递归下降分析\n直接以程序代码（的方式）模拟产生式产生语言的过程:\n基本思想： 每个非终结符对应一个子程序（函数），过程体中：\n产生式右部的非终结符：对应子程序调用， 产生式右部的终结符： 与输入记号序列进行匹配。 特点： 1\u0026gt; 子程序是递归的（因为文法是递归的）； 2\u0026gt; 程序与文法相关； 3\u0026gt; 它对文法的限制是不能有公共左因子和左递归； 4\u0026gt; 它是一种非形式化的方法，只要能写出子程序，用什么样的方法和步骤均可。\n（4）预测分析器\n☆ 预测分析器由一张预测分析表、一个符号栈和一个驱动器组成，数学模型是下推自动机。 ☆ 对文法的限制是不能有公共左因子和左递归\n预测分析器的核心概念： 1\u0026gt; 分析方法：格局与格局变换 2\u0026gt; 分析表+驱动器（模拟算法） 3\u0026gt; 预测分析表的构造 4\u0026gt; LL（文法、语言、分析器）\n☆ 开始格局的剩余输入是全部输入序列，而接收格局中剩余输入应该为空，任何其他格局或出错格局中的剩余输入应该是全部输入序列的一个后缀.\n☆ 改变格局的动作：\n① 匹配终结符： 若top=ip(但≠#)，则pop且next(ip)； ② 展开非终结符：若top^= X且M[X,ip^]=α(X→α)，则pop且push(α)； ③ 报告分析成功： 若top ^= ip^ = #，则分析成功并结束； ④ 报告出错：其它情况，调用错误恢复例程.\n☆ 驱动器算法\n☆ 构造预测分析表\n步骤：1. 构造文法符号X的FIRST集合和非终结符的FOLLOW集合；2. 根据两个集合构造预测分析表.\n通俗地讲，α的FIRST集合就是从α开始可以导出的文法符号序列中的开头终结符。而A的FOLLOW集合，就是从开始符号可以导出的所有含A的文法符号序列中紧跟A之后的终结符.\n\u0026lt;1\u0026gt; 计算X的FIRST集合 \u0026mdash;\u0026ndash;自下而上计算 \u0026lt;2\u0026gt; 计算所有非终结符的FOLLOW集合 —— 自上而下计算 \u0026lt;3\u0026gt; 构造预测分析表 \u0026lt;4\u0026gt; LL(1)文法\n文法G被称为是LL(1)文法，当且仅当为它构造的 预测分析表中 不含多重定义的条目。由此分析表所组成的分析器被称为 LL(1)分析器，它所分析的语言被称为 LL(1)语言。\n☆ 第一个L代表从左到右扫描输入序列，第二个L表示产生最左推导，1表示在确定分析器的每一步动作时向前看一个终结符.\n推论3.2 G是LL(1)的，当且仅当G的任何两个产生式A→α|β满足: 1. 对任何终结符a，α和β不能同时推导出以a开始的串；即First(α) ∩ First(β) = ∅ 2. α和β最多有一个可以推导出ε； 3. 若β =*\u0026gt; ε,则α不能导出以FOLLOW(A)中终结符开始的任何串. 即First(α) ∩ Follow(A) = ∅ ☆ 无论是递归下降子程序法还是非递归的预测分析法，他们都只能处理LL(1)文法.\n构造 First 集和 Follow 集 本章要求 给定某个文法：\n会求文法的每个非终结符的 first集 和 follow集； 会判断文法是否为 LL(1) 文法； 会构造它的预测分析表； 会根据预测分析表做自上而下的语法分析（即会用预测分析法分析某个句子是否为文法的句子） 会构造预测分析程序（实验课） 自下而上语法分析 ☆ 自上而下分析采用的是推导;自下而上分析采用的是归约(规范归约—剪句柄—移进/归约分析—SLR(1)分析器).\n（1）自下而上分析的基本方法\n☆ 基本思想： 最左归约.\n对于每个输入序列ω：从左到右扫描ω; 从ω开始,反复用产生式的左部替换产生式的右部(即当前句型中的句柄)、谋求对ω的匹配,最终得到文法的开始符号,或者发现一个错误。\n☆ 基本概念：\na) \u0026gt; 设αβδ是文法G的一个句型，若存在S=*\u0026gt;αAδ，A=+\u0026gt;β， 则称β是句型αβδ相对于A的\u0026quot;短语\u0026quot;. \u0026gt; 特别的，若 有A→β，则 称β是句型αβδ相对于产生式A→β的\u0026quot;直接短语\u0026quot;. \u0026gt; 一个句型的最左直接短语被称为\u0026quot;句柄\u0026quot;. 特征： 1. 短语：以非终结符为根子树中所有从左到右的叶子； 2. 直接短语：只有父子关系的子树中所有从左到右排列的叶子（树高为2）； 3. 句柄：最左边父子关系树中所有从左到右排列的叶子（句柄是唯一的） b)最左归约：若 α是文法G的句子且满足下述条件，则称序列αn，αn-1，...，α0是α的一个最左归约。 1) αn = α 2) α0 = S（S是G 的开始符号） 3) 对任何i(0\u0026lt;i\u0026lt;=n)，αi-1是将αi中句柄替换为相应产生式左部非终结符得到的 ☆ 最左归约的逆过程是一个最右推导，分别称最右推导和最左归约为规范推导和规范归约. c）移进-归约分析器 1. 工作方式：格局与格局变换 2. 分析表 3. 驱动器（模拟算法） 4. SLR分析表的构造 5. LR（文法、语言、分析器） ☆ 改变格局的动作： 1.移进(shift)：当前剩余输入的下一终结符进栈。 2.归约(reduce)：将栈顶句柄替换为对应非终结符(最左归约) 3.接受(accept)：宣告分析成功 4.报错(error)：发现语法错误，调用错误恢复例程 (2) LR分析\na) LR分析与LR文法 LR分析： 允许左递归，但不能有二义_\n定义3.15 若为文法G构造的移进-归约分析表中不含多重定义的条目，则称G为\u0026quot;LR(k)文法\u0026quot;，分析器被称为是\u0026quot;LR(k)分析器\u0026quot;，它所识别的语言被称为\u0026quot;LR(k)语言\u0026quot;。\u0026quot;L\u0026quot;表示从左到右扫描输入序列，\u0026quot;R\u0026quot;表示逆序的最右推导，\u0026quot;k\u0026quot;表示为确定下一动作向前看的终结符个数，一般情况下k\u0026lt;=1。当k=1时，简称\u0026quot;LR\u0026quot;。 构造SLR(1)分析器\n\u0026lt;1\u0026gt; 活前缀与LR(0)项目\n第1步 第2~N步 状态 词法\u0026ndash;DFA ε-closure(S) ε-closure(smove(S,a)) 状态集 语法\u0026ndash;DFA closure(I) closure(goto(I,x)) 项目集 出现在移进-归约分析器栈中的右句型的前缀，被称为文法G的 活前缀(viable prefix). LR(0)项目(简称项目) 是这样一个产生式，在它右边的某个位置有一个点\u0026quot;.\u0026quot;。对于A→ε，它仅有一个项目A→.。 项目A→α.β显示了分析过程中看到(移进)了产生式的多少。 β不为空的项目称为 可移进项目 ，β为空的项目称为 可归约项目.\n\u0026lt;2\u0026gt; 拓广文法与识别活前缀的DFA\nG\u0026rsquo; = G ∪ {S\u0026rsquo; → S} 其中：S\u0026rsquo; → S是识别S的初态，S\u0026rsquo; → S. 是识别S的终态. 目的是使最终构造的DFA状态集中具有唯一的初态和终态. ① closure(I)：从项目集I不经任何文法符号到达的项目全体；\n② goto(I，x)：所有从I经文法符号x能直接到达的项目全体。\n项目[S’→.S]和所有“.”不在产生式右部最左边的项目称为核心项目(kernel items)， 其它“.”在产生式右部最左边的项目(不包括[S’→.S])称为非核心项目(nonkernel items). 核心项目：J=goto(I，X)，S'→.S（作为项目集的代表） 非核心项目：closure(J)-J（特点：可由J某中某项目算得） \u0026lt;3\u0026gt; 识别活前缀\n定义3.21 若存在最右推导S’=*\u0026gt; αAω =\u0026gt; αβ1β2ω，则称项目[A→β1.β2] 对活前缀αβ1有效。 当一个项目集中同时存在： 1. A→β1.β2和B→β.：既可移进又可归约，移进/归约冲突 2.A→α.和B→β.：均可指导下一步分析，归约/归约冲突 解决方法：简单向前看一个终结符： 1. 移进/归约冲突：若FIRST(β2)∩FOLLOW(B)=Φ，冲突可解决 2. 归约/归约冲突：若FOLLOW(A)∩FOLLOW(B)=Φ，冲突可解决 若冲突可以解决，则称文法为SLR(1)文法，构造的分析表为SLR(1)分析表。 SLR(1)文法：简单向前看一个终结符即可解决冲突 ☆ 二义文法不是SLR(1)文法 静态语义分析 采用语法制导翻译生成中间代码\n语法制导翻译简介 （1）语法与语义的关系\n语法是指语言的结构、即语言的“样子”； 语义是指附着于语言结构上的实际含意，即语言的“意义”. 一个语法上正确的句子，它所代表的意义并不一定正确.\n☆ 语义分析的作用\n• 检查结构正确的句子所表示的意思是否合法； • 执行规定的语义动作，如：表达式求值、符号表的查询/填写、中间代码生成等\n☆ 应用最广的 语义分析方法 是语法制导翻译，他的 基本思想 是将语言结构的语义以 属性 的形式赋予代表此结构的文法符号，而属性的计算以 语义规则 的形式赋予由文法符号组成的产生式.\n（2）属性/语义规则的定义\n定义4.1 对于产生式A→α，其中α是由文法符号X1X2...Xn组成的序列，它的语义规则可以表示为(4.1)所示关于属性的函数f： b := f(c1, c2, ..., ck) (4.1) 语义规则中的属性存在下述性质与关系： (1) 称(4.1)中属性b依赖于属性c1, c2, ..., ck。 (2) 若b是A的属性，c1, c2, ..., ck是α中文法符号的属性，或者A的其它属性，则称b是A的综合属性。 (3) 若b是α中某文法符号Xi的属性，c1, c2, ..., ck是A的属性，或者是α中其它文法符号的属性，则称b是Xi的继承属性。 (4) 若语义规则的形式如下述(4.2)，则可将其想像为产生式左部文法符号A的一个虚拟属性。属性之间的依赖关系，在虚拟属性上依然存在。 f(c1, c2, ..., ck) (4.2) ■ ☆ 继承属性从前辈和兄弟的属性计算得到,综合属性从子孙和自身的其他属性计算得到.\n即,继承属性\u0026ldquo;自上而下,包括兄弟\u0026rdquo;,综合属性\u0026ldquo;自下而上,包括自身\u0026rdquo;.\n（3）语义规则的两种形式\n☆ 语义规则的两种形式（忽略实现细节，二者作用等价）\n\u0026lt;1\u0026gt; 语法制导定义(Syntax Directed Definition)\n用抽象的属性和运算表示的语义规则；(公式，做什么) \u0026lt;2\u0026gt; 翻译方案(Translation Scheme)\n用具体的属性和运算表示的语义规则。(程序段，如何做) ☆ 继承属性是自上而下计算的，综合属性是自下而上计算的.\n（4）LR分析翻译方案的设计\n☆ LR分析中的语法制导翻译实质上是对LR语法分析的扩充：\n扩充LR分析器的功能 当执行 归约产生式的动作时，也执行相应产生式对应的 语义动作。由于是归约时执行语义动作，\n因此限制语义动作仅能放在产生式右部的 最右边；\n扩充分析栈 增加一个与 分析栈并列的 语义栈，用于存放分析栈中文法符号所对应的 属性值。\n☆ 扩充后的LR分析最适合对综合属性的计算，而对于继承属性的计算还需要进行适当的处理.\n中间代码简介 ☆ 中间代码应具备的特性 1）便于语法制导翻译 2）既与机器指令的结构相近,又与具体机器无关.\n使用中间代码的好处:一是便于编译器程序的开发和移植,二是代码进行优化处理.\n☆ 中间代码的主要形式：后缀式、树、三地址码等.最基本的中间代码形式是树🌲；最常用的中间代码形式是三地址码，它的实现形式常采用四元式形式。\n☆ 符号表是帮助声明语句实现存储空间分配的重要数据结构。\n（1）后缀式\n操作数在前，操作符紧随其后，无需用括号限制运算的优先级和结合性；便于求值.\n（2）三地址码\n① 三元式 形式： (i) (op, arg1, arg2)\n三地址码：(i):= arg1 op arg2\n序号的双重含义：既代表此三元式，又代表三元式存放的结果\n存放方式：数组结构，三元式在数组中的位置由下标决定\n弱点：给代码的 优化带来困难\n② 四元式 形式： ( i ) (op，arg1，arg2，result)\n所表示的计算： result:= arg1 op arg2\n四元式与三元式的唯一区别：将由序号所表示的运算结果改为：用(临时)变量来表示。 此改变使得四元式的运算结果与其在四元式序列中的位置无关.为代码的优化提供了极大方便，因为这样可以删除或移动四元式而不会影响运算结果. ③ 树形表示\n1\u0026gt; 语法树真实反映句子结构，对语法树稍加修改（加入语义信息），即可以作为中间代码的一种形式(注释语法树) 2\u0026gt; 树的优化表示－DAG 3\u0026gt; 树与其他中间代码的关系\n☆ 树表示的中间代码与 后缀式和 三地址码之间有内在联系\n树 → 后缀式 方法：对树进行 深度优先后序遍历，得到的线性序列就是 后缀式，或者说后缀式是树的一个线性化序列；\n树 → 三元式/四元式 特点：树的每个非叶子节点和它的儿子 对应一个三元式或四元式；\n方法：对树的非叶子节点进行深度优先后序遍历，即得到一个三元式或四元式序列。\n符号表简介 符号表的作用 ：连接声明与引用的桥梁，记住每个符号的相关信息，如作用域和类型等，帮助编译的各个阶段正确有效地工作。 符号表的基本目标： 有效记录信息、快速准确查找。 符号表设计的基本要求： 正确存储各类信息； 适应不同阶段的需求； 便于有效地进行查找、插入、删除和修改等操作； 空间可以动态扩充. （1）构成名字的字符串\n构成名字的字符串的存储方式： 直接存储\u0026mdash;定长数据(直接将构成名字的字符串放在符号表条目中)和间接存储\u0026mdash;变长数据(将构成名字的字符串统一存放在一个大的连续空间内，字符串与字符串之间采用特殊的分隔符隔开，符号表条目中仅存放指向该字符串首字符的指针).\n（2）名字的作用域\n☆ 程序语言范围的划分可以有两种划分范围的方式：并列和 嵌套\n☆ 名字的作用域规则： 规定一个名字在什么样的范围内应该表示什么意义.\n\u0026lt;1\u0026gt; 静态作用域规则（static-scope rule）：编译时就可以确定名字的作用域,即仅从静态读程序就可确定名字的作用域 \u0026lt;2\u0026gt; 最近嵌套规则（most closely nested）：名字的声明在离其最近的内层起作用 （3）线性表\n符号表以 栈(线性表) 的方式组织.\n线性表上的操作：查找、插入、删除、修改\n查找：从表头(栈顶)开始，遇到的第一个符合条件的名字；插入：先查找，再加入在表头（栈顶）；\n关键字 = 名字＋作用域；\n（4）散列表\n名字挂在两个链上(便于删除操作)：\n散列链(hash link)： 链接所有具有 相同hash值的元素，表头在表头数组中； 作用域链(scope link)：链接所有在 同一作用域中的元素，表头在作用域表中. ☆ 操作：查找、插入、删除\n声明语句的翻译 （1）变量的声明\n☆ 一个变量的声明应该由两部分来完成：类型的定义和 变量的声明\n类型定义： 为编译器提供存储空间大小的信息 变量声明： 为变量分配存储空间 组合数据的类型定义和变量声明： 定义与声明在一起，定义与声明分离. 1\u0026gt; 简单数据类型的存储空间是预先确定的，如int可以占4个字节，double可以占8个字节，char可以占1个字节等\n2\u0026gt; 组合数据类型变量的存储空间，需要编译器根据程序员提供的信息计算而定.\n（2） 过程\n1．过程（procedure）：过程头(做什么) ＋ 过程体(怎么做)； - 函数: 有返回值的过程 - 主程序: 被操作系统调用的过程/函数 2．过程的三种形式：过程定义、过程声明和过程调用。 过程定义：过程头+过程体； 过程声明：过程头； 3. 左值与右值 1\u0026gt; 直观上，出现在赋值号左边和右边的量分别称为左值和右值； 2\u0026gt; 实质上，左值必须具有存储空间，右值可以仅是一个值，而没有存储空间. 3\u0026gt; 形象地讲，左值是容器，右值是内容. 4. 参数传递 1\u0026gt; 形参与实参 - 声明时的参数称为形参(parameter或formal parameter) - 引用时的参数称为实参(argument或actual parameter) 2\u0026gt; 常见的参数传递形式：（不同的语言提供不同的形式） - 值调用（call by value）---过程内部对参数的修改，不影响作为实参的变量原来的值. - 引用调用（call by reference）--- 过程内部对形参的修改，实质上是对实参的修改. - 复写－恢复（copy-in/copy-out）--- ① 过程内对参数的修改不直接影响实参，避免了副作用; ② 返回时将形参内容恢复给实参，实现参数值的返回. - 换名调用（call by name）--- 宏调换 3\u0026gt; 参数传递方法的本质区别： 实参是代表左值、右值、还是实参本身的正文. 5. 作用域信息的保存 ☆ 能够画出嵌套过程的嵌套关系树(P191 4.33),根据语法制导翻译(P193 4.35)画出分析树,写出推导步骤,构造的符号表 简单算术表达式与赋值句 P197 例4.36 主要是变量类型的转换\n数组元素的引用 （1）数组元素的地址计算\n注意是行主存储还是列主存储 （2）☆数组元素引用的语法制导翻译(考试热点之一)\nP201 例4.37 布尔表达式 布尔表达式的计算有两种方法：数值表示的 直接计算和逻辑表示的 短路计算\n☆ 布尔表达式短路计算的翻译：短路计算的控制流，真出口与假出口，真出口链与假出口链，拉链回填技术(P207 例4.41)（考试热点之一）\n控制语句 控制语句的分类： ①无条件转移、②条件转移、③循环语句、④分支语句\n无条件转移(goto)\\条件转移(if、while)\n条件转移的语法制导翻译：P213 例4.42\n多看课件PPT，多做题练手\n参考 简书博主 SnorlaxSE - 编译原理知识汇总 中国大学MOOC 考拉学姐 - 编译原理 《程序设计语言编译原理》 - 陈火旺，刘春林等 国防工业出版社\n","date":"2025-02-17T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","title":"编译原理知识汇总"},{"content":"\n考研基本常识 考研届数 XX考研（ 研究生入学年份 ）\n报名条件 考前确定学校与专业\n报考条件 本科双证 （毕业证、学位证）（应届或毕业后均可）、专科不提\n考试时间 12月中下旬\n初试考试科目 500分 政治（马原、毛中特、习思想、史纲、思修、时政等）\t100分 外语（完形填空、阅读、翻译和写作，口语和听力部分在复试考察）100分 数学\t150分 专业课（408统考 or 自命题） 150分 复试考试科目 笔试 专业知识 面试 综合素质、专业素质（主要） 可能包括自我介绍、各类本科经历（科研、论文和项目）、英语口语听力测试、专业课程和科研知识问答 （部分情况）加试\t上机 复录比：常见 1.2 : 1 、 1.5 : 1 各类分数线 国家线 总分和单科达到一定分数才能参加复试 A类 湖南、湖北、重庆、广东、北京、上海、天津等（21） B类总分一般比A类低 10 分左右 广西、贵州、云南等（10） 院校专业线 自划线（985院校） 学硕与专硕 培养目标与毕业要求\n培养学制\n学硕 3 年（通常），专硕 2~3 年 学费\n学硕 8000/年（通常） 专硕比学硕多，部分情况差距很大 转博\n1.9 全日制与非全日制的差别 学习方式 双证区别 学费和其他支持 全日制有更多支持 考研信息源 官方信息源 中国研究生招生信息网 考研官方平台 报考院校研究生院官网 该校考研信息最直接、最权威的渠道 报考专业所在院系公众号 个性化信息和数据推送，学长学姐 非官方信息源 考研教育机构 信息二道贩子，注意信息交叉验证 社交媒体与论坛、已上岸的学长学姐 方便的一手经验 bilibili、知乎、小红书、抖音 实地考察 框框大学 考研时间线 大一大二 初步认知与目标设定 学业基础巩固 参与学术活动与社团 大三 考研目标院校与专业 最终/初步确定考研目标院校和专业 考研复习全面启动 关注考研资讯与报名准备 密切关注考研最新动态 考试大纲的发布 招生简章的更新等 及时了解目标招生院校的招生政策变化 招生人数是否变化 考试科目及参考书目是否变动等 大四 7~9月：各校陆续发布招生简章\n看考研院校\n9(10)月：考研政治，英语，数学大纲发布\n9(10)月：网上预报名\n考点选择\n10月：网上报名\n11月：网上/现场确认\n12月中旬（初试前十天）:打印准考证\n12月下旬：考研初试\n次年2月中下旬：公布初试成绩\n次年3月（上中下旬）：考研国家线，院校专业线，自划线（34所）公布\n次年3月中下旬~5月：考研复试，调剂\n次年4-6月：考研录取\n择校择专业 择校主要因素 学校综合实力 学校和学科排名、学科评估结果 学校地理位置 地区经济发展水平（实习与就业） 一/二区 招生情况 招生人数、报录比 复试分数线与复试情况 复录比 兴趣与规划 本科专业相关性 科研或对口专业 导师 / 课题组的最新科研 思考原则 跨考 院校（根据复习情况决定） 专业课考试不公布参考书目（谨慎） 招录人数少于 3 人以下（不考虑） 院校歧视，专业课压分传统（不考虑） 备考要点 备考原则 底层思维 为什么要考研 竞争对手 考前准备 考研真题 名师课程 考研博主 是否报班 具体科目 政治 大三暑假甚至 9 ~ 10 月开始都可以 使用最新资料！ 肖四肖八（肖秀荣四套卷、八套卷）是神器 外语 随时积累 词汇量积累要趁早 数学 打好基础（微积分、线性代数、概率论与数理统计） 大三越早开始越好 专业课 统考科目可以较早开始 自命题可以在择校择专业确定后开始 复试 初试后休息后就可以开始 多方求证，最重要！（上岸学长学姐） 积累有效履历 热门问题 性价比 导师选择 放养型导师 本科情况 方法论+材料 学硕与专硕对比（1.8） 考公专业推荐 查找导师信息 经验分享 参考 一个视频讲透考研的一切！时间线/信息源/初试/复试/政治/外语/数学/专业课/择校/择专业 ","date":"2025-02-15T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E8%80%83%E7%A0%94/","title":"考研-基本常识"},{"content":"\n计算机网络与互联网络 什么是互联网络 从构成的角度来看： 互联网络由点和边构成。其中，点包括端系统（涵盖网络应用）以及路由器；边则是链路。简单来说，互联网络其实是网络的网络，众多不同的网络相互连接，形成了一个庞大复杂的体系。 从服务的角度来看： 互联网络是一种能够为应用提供通信服务的通信架构。在这个架构里，有连接且可靠的服务与无连接的不可靠服务相互配合，共同支撑各类应用开展通信服务。 协议：指对等层实体在通信过程中所遵循的规则的集合，这一集合可以从语法、语义及时序三个方面去理解。语法规定了数据与控制信息的结构或格式；语义说明了需要发出何种控制信息，完成何种动作以及做出何种响应；时序则明确了事件实现顺序的详细说明。 网络边缘 网络的结构： 网络整体结构分为网络边缘与网络核心两大部分，还涉及接入网络与通信链路。网络边缘包括运行应用的端系统，重点在于 端系统中的应用交互方式 ；网络核心则由路由器组成。 **网络边缘的应用交互方式 ** C/S 模式（客户端 / 服务器模式）：其特点在于，客户端向服务器发起请求，服务器响应请求并为客户端提供服务。服务器往往具备强大的处理能力与丰富的数据资源，客户端则相对轻量化，依赖服务器获取数据与执行复杂运算，常见于网页浏览、邮件收发等应用场景。 P2P 模式（对等模式）：这种模式下，各个端系统地位平等，既可以作为客户端向其他节点请求资源，也能充当服务器为其他节点提供资源。它无需依赖集中式服务器，有较强的扩展性与容错性，常用于文件共享、流媒体直播等应用。 网络的服务： 面向连接的服务：这类服务在通信前会先建立连接，整个通信过程数据传输稳定、可靠，能保证数据按序到达接收方，不过建立连接与拆除连接会带来额外开销。 无连接的服务：通信时无需事先建立连接，直接发送数据报，传输效率较高，但无法保证数据一定能可靠、有序地到达接收方。 网络核心 网络核心 组成：网络交换设备，如路由器 + 链路。 功能：数据交换。 数据交换方式及比较 分组交换：存储转发方式，统计复用。 - 理解 VC（虚电路） Datagram（数据报） 线路交换 FDM（频分复用） TDM（时分复用） WDM（波分复用） 网络接入与物理介质 网络接入是指将端系统连接到边缘路由器的链路或网络。 住宅接入采用点到点接入方式，具体包括： ADSL（非对称数字用户线路） HFC（混合光纤同轴电缆） Cable Modem（电缆调制解调器） Home Networks（家庭网络） 机构接入：LAN 以太网 WLAN（无线网） 物理链路（第 0 层） 导向型介质（有型，光纤等） 非导向型介质（无形，电磁波、光信号等） 常用介质 TP 双绞线 同轴电缆 光纤 Radio（电磁波信号） 互联网络结构与 ISP 近似层次型结构 T - 1 ISP T - 2 ISP (Regional ISP) Local ISP ISP 之间的连接 对等连接 IXP（互联网交换点 ） 内容提供商网络 在全球部署 DC（数据中心） 内容提供商网络在多处与各个 ISP 相联 内容提供商自己部署网络将全球的 DC 相联 内容提供商 DC 自己之间的访问，通过自己部署的专网 用户接入后通过离用户最近的 DC 为之服务 分组交换网络中的延迟与丢失 延迟的 4 个原因（计算） - 掌握 处理延迟 排队延迟 传输延迟 传播延迟 例如：n 段，分组 L，R，传播延迟 d 每段如何计算总体延迟；\n流量强度（0-1，与排队延迟正相关）：La/R - 掌握 排队延迟 依赖**流量强度的公式 **； 丢失原因： 缓冲区溢出 + 出错没通过校验 吞吐量 -了解 瞬间吞吐量 平均吞吐量 瓶颈链路决定了主机之间的吞吐量（从每段链路获得的大致带宽是 1/N，瓶颈链路是所有链路段中获得带宽最小的）。\n协议层次与服务模型 为什么要分层 网络比较复杂，分层实现比较容易设计、调试、实现。 分层：将复杂的网络功能划分成功能明确的层次，上层利用下层提供的服务来实现本层的协议，从而为上层提供更复杂的功能。 一些术语和概念 -理解 服务、服务访问原语、服务访问点 面向连接的服务、无连接的服务 协议、协议数据单元 PDU 服务（垂直）和协议（水平）之间的关系（区别与联系） 服务利用了下层协议的实现，为上层提供服务 协议的实现依靠下层服务 互联网络分层模型及每一层的功能 -理解 应用层 传输层 网络层（端到端，路由和转发） 链路层（点到点，帧为单位） 物理层（物理信号） 封装和解封 历史 -了解 ARPANET：美国军方资助的分组交换实验网，由于 TCP/IP 架构的包容性、免费使用、架构便于应用创新吸引更多的用户等原因，用户数量、节点数量和应用数量越来越多。 NSF 建立 ARPANET 的访问网。 民用网络从军用网络脱开，成为现在的互联网。 术语：IETF（互联网工程任务组）, ITU(国际电信联盟），IEEE（电气电子工程师协会 ），RFC（请求评论，是一系列关于互联网技术的文件）。\n应用层 原理 + 应用实例 + SOCKET 编程\n应用的开发只集中在端系统上，对路由器没有任何改变，这鼓励了互联网架构下的应用创新。\n网络应用原理 应用架构 C/S（客户端 / 服务器） P2P（对等网络） 混合架构 进程间通信 同主机：操作系统定义的通信方法 不同主机：利用网络提供的架构（Socket）交换报文 SOCKET 一个整数，OS 用于标示应用通信关系所采用的本地标示 **TCP：**连接的本地标示 **UDP：**端节点的本地标示 进程编址 IP + PORT（本质上在传输层应用了端口号，用于区分应用，TCP 和 UDP 使用端口号的方式不同） 应用所需要的服务需要考虑的因素（网络所提供服务的主要指标） 丢失率可靠性 延迟、延迟差（抖动） 带宽 安全性 传输层协议 TCP 提供的服务特性：可靠字节流服务，面向连接，流量控制，拥塞控制 UDP 提供的服务特性：无连接，不可靠的服务 都能够提供进程的标示，区分不同的进程\nWEB 和 HTTP WEB 应用包括 HTTP 协议 HTML CLIENT（客户端），SERVER（服务器） 术语 网页 对象 引用 URL HTTP 协议 定义了 C（客户端）和 S（服务器）之间通信的报文格式、解释和时序。 HTTP 连接 持续性连接 非持续性连接 往返延迟 RTT 和对象的抓取时间 HTTP 1.0 到 HTTP 1.1 再到 HTTP 2.0 的演变 HTTP 1.0 基本特点 无状态协议：每个请求都是独立的，服务器不会在不同请求之间保留状态信息。 简单的请求 - 响应模型：客户端发起请求，服务器响应请求，一次请求对应一次响应。 支持多种请求方法：如 GET、POST、HEAD 等。 局限性 连接管理效率低：每对请求 - 响应都需要建立一个新的 TCP 连接，这导致了较高的连接建立开销，特别是在请求大量小文件时。 缺乏对缓存的充分支持：缓存机制比较简单，没有很好地处理资源更新和验证的问题。 HTTP 1.1 改进之处 持久连接（Keep - Alive） 允许在一个 TCP 连接上进行多次请求 - 响应交互，减少了建立连接的开销。 客户端和服务器可以通过 Connection: keep - alive头字段来协商保持连接。 管道化（Pipelining） 允许客户端在等待第一个请求的响应时，发送第二个请求，进一步提高了性能。 增强的缓存机制 引入了更多的缓存控制头字段，如 Cache - Control、ETag和 If - Modified - Since等，使得缓存管理更加灵活和高效。 分块传输编码（Chunked Transfer Coding） 允许服务器在不知道内容长度的情况下，分块发送响应内容，适用于动态生成内容的情况。 局限性 头部信息冗余：每个请求和响应都携带完整的头部信息，在大量请求时，头部数据的传输会造成性能瓶颈。 队首阻塞（Head - of - line Blocking）：在管道化连接中，如果一个请求被阻塞，后续的请求都要等待，即使后续请求不需要依赖前面被阻塞的请求。 HTTP 2.0 主要特性 二进制分帧层（Binary Framing Layer） HTTP 2.0 将所有传输的信息分割为更小的帧，并对帧进行二进制编码。这使得协议更加紧凑和高效。 通过帧的形式，实现了在一个 TCP 连接上多路复用多个请求和响应，避免了 HTTP 1.1 中的队首阻塞问题。 头部压缩（Header Compression） 使用 HPACK 算法对头部信息进行压缩，减少了头部数据的传输量。 对于重复的头部字段，可以只传输差异部分，进一步提高了压缩效率。 服务器推送（Server Push） 服务器可以在客户端没有请求的情况下，主动向客户端推送资源。例如，当客户端请求 HTML 页面时，服务器可以同时推送页面所需的 CSS 和 JavaScript 文件，减少客户端的等待时间。 性能提升 HTTP 2.0 通过上述特性，在网络性能上有了显著提升，特别是在处理大量小资源和高并发请求时表现出色。 从 HTTP 1.0 到 HTTP 1.1 再到 HTTP 2.0，协议不断进化，旨在解决前一版本的性能瓶颈，提高网络传输效率和用户体验。\n从 SSL 到 HTTP/3.0（基于 UDP）的安全优化过程 SSL（Secure Sockets Layer，安全套接层） 基本原理 SSL 是一种早期的网络安全协议，用于在客户端和服务器之间建立加密连接，确保数据在传输过程中的保密性、完整性和身份验证。 它通过握手过程来协商加密算法、密钥交换和身份验证方法。 局限性 性能问题 SSL 的握手过程相对复杂，尤其是在早期版本中，这会导致较高的连接建立延迟。 对于每一个新的连接，都需要重新进行握手，这在高并发场景下会影响性能。 安全性逐渐减弱 随着技术的发展，SSL 的一些加密算法和协议漏洞被发现，安全性逐渐不能满足现代网络安全的需求。 TLS（Transport Layer Security，传输层安全） 与 SSL 的关系 TLS 是 SSL 的继任者，它在 SSL 的基础上进行了改进和扩展。TLS 的目标与 SSL 相同，即确保网络通信的安全，但在安全性和性能方面有了显著提升。 改进之处 增强的加密算法 TLS 采用了更强大和更安全的加密算法，如 AES（Advanced Encryption Standard）等，以应对不断出现的安全威胁。 优化的握手过程 TLS 对握手过程进行了优化，例如引入了会话恢复机制。当客户端和服务器之前已经建立过连接，在一定条件下可以复用之前的会话参数，减少握手时间。 HTTP/3.0（基于 UDP 的 QUIC 协议） QUIC（Quick UDP Internet Connections）协议 HTTP/3.0 是基于 QUIC 协议的，而 QUIC 是基于 UDP 的。QUIC 旨在解决 TCP 和 TLS 在性能和安全性方面的一些问题。 安全特性 集成加密 QUIC 将加密作为协议的核心部分，从一开始就对数据进行加密，避免了像 TCP + TLS 那样分两步进行加密的复杂性。 0 - RTT 连接建立（在某些情况下） QUIC 允许在某些条件下实现 0 - RTT（Round - Trip Time）连接建立。例如，当客户端和服务器之前已经建立过连接并且缓存了相关的加密参数时，客户端可以立即发送应用数据，无需等待握手过程完成，大大减少了连接建立延迟。 前向纠错（Forward Error Correction，FEC） QUIC 采用了 FEC 技术，通过在数据中添加冗余信息来恢复在传输过程中丢失的数据，减少了因丢包导致的数据重传，提高了传输效率和安全性。 从 SSL 到 HTTP/3.0（基于 UDP）的演变过程，是一个不断优化安全性能和网络传输效率的过程。HTTP/3.0 通过基于 UDP 的 QUIC 协议，在安全和性能方面都有了显著的提升。\n报文格式 Wireshark——抓包分析_wireshark抓包数据怎么看-CSDN博客\n请求报文 方法 响应报文 状态码 COOKIES（HTTP无状态-\u0026gt;有状态） WEB 缓存 作用：通过本地命中，减少这些对象的访问延迟；进一步减少接入链路的流量强度，从而降低派对延迟带来总体平均延迟的减少；减轻服务器的负担。 优点：通过一个实例，计算不要求。 FTP （不要求） 作用：在 CS 之间传输文件。 构成： C（客户端） S（服务器） FTP FTP 的连接 控制连接（带外传输） 数据连接 命令和响应 EMAIL 电子邮件应用的构成 用户代理 邮件服务器 SMTP（简单邮件传输协议） 邮件报文格式解析 报文头 报文体 MIME（多用途互联网邮件扩展）：邮件多媒体扩展，可以在邮件中编解码多媒体内容。 邮件存取协议 作用 常用 IMAP（互联网邮件访问协议） POP3（邮局协议版本 3） DNS DNS 作用 完成域名到 IP 地址的转换（还包括别名到正规名字、邮件服务器名字到正规名字转换等），是应用层面的互联网 基础设施，其他应用使用。\n二、DNS 的概念 分布式、层次数据库 命名是分层的 域名信息存储和服务是分布式的，每个域名服务器担任一个区域 ZONE 的名字到 IP 地址的权威转换，也缓存名字 - IP 信息的转换。 三、DNS 的构成 解析器：本地应用 域名服务器 DNS 协议 报文：请求和应答格式相同 RR：资源记录 域名解析的过程 (解析器 -\u0026gt; 本地 DNS 服务器 -\u0026gt; 上层域名服务器 -\u0026gt;\u0026hellip;-\u0026gt; 权威名字服务器，返回)\n本地域名服务器、权限域名服务器、顶级域名服务器、根域名服务器\n递归解析：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 迭代解析：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。 DNS 缓存 作用 本地缓存 + 服务器缓存 P2P （了解P2P 的概念和优势即可） P2P 概念 每个对等体即是客户端又是服务器；P2P 网络是这些 peer 构成的应用层面的逻辑网络。\nP2P 网络比 C/S 方式分发内容快的原因 这些 peer 节点参与到内容的上载，流量和服务都是分布式的，可扩展性。\n典型 P2P 应用及其原理 （不要求） Napster：知道名词 Gnutella：知道名词 KaZaA：知道名词 BT：知道名字 DHT： 视频流化服务和 CDN（了解） 服务器向客户端进行视频流化的方式 UDP 流化 http 流化 DASH（Dynamic, Adaptive Streaming over HTTP） DASH 流化的过程 客户端获取告示文件 客户端按照情况，向（可能是不同的）服务器请求不同视频质量的内容块，客户端智能 CDN 单个服务器，或者服务器群向客户端提供海量内容并发服务的问题：扩展性差 CDN 原理 应用层面的协作服务网络 在全网部署缓存节点，内容预先部署到 CDN 缓存节点上 用户请求通过域名解析重定向向离自己 “最近的节点” 请求内容 缓存节点放置的方式 Enter Deep Bring Home TCP 的 SOCKET 编程 - 理解 SOCKET 概念 TCP 连接的本地标示示，向这个 SOCKET 写就是发送给对方的进程；从 SOCKET 中读，就是读取对方发送过来的数据。 SOCKET API 创建 使用（读和写） 关闭 TCP SOCKET 数据传输的特点 面向连接，可靠字节流服务 TCP SOCKET 编程 建立 SOCKET 客户端 TCP 实体动作：和服务器端的 TCP 实体握手沟通。 服务器端的动作 三次握手 使用 SOCKET 关闭 SOCKET UDP 的 SOCKET 编程 - 理解 UDP SOCKET数据传输的特点 编程 - 不要求 建立SOCKET（之前客户端 UDP 实体和服务器不用握手，不为之后的通信做准备） 使用 关闭 传输层 传输层服务 传输服务 能够使端系统应用之间进行逻辑通信。 传输协议：运行于端系统的 2 个对等传输层实体相互通信应该遵守的规则集合。 传输服务和网络服务的区别 网络服务：主机到主机的通信。 传输服务：进程到进程的通信。 互联网络传输层协议 TCP：有连接，可靠保序数传服务。 UDP：无连接，不可靠，不保序的数传服务。 复用与解复用 复用 源端多个上层应用收集数据：应用报文，封装报文。 解复用 接收端将数据按照端口号（结合 IP 地址）给相应的 SOCKET 对应的应用。 复用和解复用的工作原理：IP PORT TCP 有连接情况：SOCKETS 为 4 元组。 UDP 无连接情况：SOCKETS 为 2 元组。 无连接传输层协议 UDP UDP 的必要性：有些应用对实时性比较在乎，对可靠性要求不高。 UDP 报文（无连接的，因此叫做 UDP 数据报）格式。（头部 + 载荷） **UDP 报文校验和的计算（Check Sum） **理解 可靠数据传输原理 协议演进的方式讲解如何进行 rdt 加入一些假设，简单的协议可以提供 rdt 服务。 去掉一些假设，需要协议实体做相应的变化从而能够进行 rdt。 **技术机制 ** 理解 校验和，正向确认，反向确认。 序号：检查重复。 只有正向确认的机制。 检错重发和超时重发：处理丢失。 滑动窗口 RDT（Reliable Data Transfer，可靠数据传输）1.0、2.0、3.0 的功能特点 计算机网络（14）——可靠数据传输原理_rdt3.0接收方fsm-CSDN博客\nRDT 1.0 解决错误问题 基本原理 RDT 1.0 假设底层信道完全可靠，不会出现比特差错，也不会丢失分组。 在这种理想情况下，发送方只需将数据发送出去，接收方就能无误地接收到数据。 工作机制 发送方：简单地将数据发送给接收方，无需考虑数据是否丢失或损坏。 接收方：接收数据并进行处理，不需要反馈机制来确认数据是否正确接收。 RDT 2.0 解决序号 / 时序问题 基本原理 RDT 2.0 考虑到了底层信道可能出现比特差错的情况，但仍然假设分组不会丢失。 为了检测和纠正错误，引入了差错检测码（如校验和）和确认（ACK）与否认（NAK）机制。 工作机制 发送方： 发送带有差错检测码的数据分组。 等待接收方的 ACK 或 NAK 反馈。如果收到 ACK，则继续发送下一个分组；如果收到 NAK，则重发当前分组。 接收方： 接收数据分组并检查差错检测码。 如果数据无误，发送 ACK 给发送方；如果检测到错误，发送 NAK 给发送方。 RDT 3.0 解决超时 / 重复问题 基本原理 RDT 3.0 在 RDT 2.0 的基础上，进一步考虑了分组可能丢失的情况。 为了处理分组丢失问题，引入了定时器机制。 工作机制 发送方： 发送数据分组后启动定时器。 如果在定时器超时前收到 ACK，则取消定时器并发送下一个分组。 如果定时器超时，无论是否收到 NAK，都重发当前分组。 接收方： 与 RDT 2.0 类似，接收数据分组，检查差错检测码，发送 ACK 或 NAK。 如果收到重复的分组（由于发送方超时重发），仍然发送 ACK 给发送方，以避免发送方不断重发。 RDT 协议从 1.0 到 3.0 不断演进，逐步解决了可靠数据传输过程中的各种实际问题，从假设理想信道到考虑比特差错、分组丢失等情况，通过增加差错检测、确认机制、定时器等手段来确保数据的可靠传输。\n利用率计算 - 了解 停止等待技术：链路带宽延迟积（容量）效率低。 管道技术：在未经对方确认的情况下，可以连续发送多个 PDU。 GBN：发送窗口大于 1，接收窗口 = 1（只能顺序接收；发送方只设置一个超时定时器，一旦出错，返回到出错的那一个 PDU 重发）。 SR：发送窗口大于 1，接收窗口大于 1（能够乱序接收；发送方为每个发送出去的 PDU 设置超时定时器，哪个超时重发哪个）。\n有连接传输层协议：TCP TCP 服务特性 点对点：可靠保序字节流；管道（在未加确认情况下一次次传多个未经确认的段）；缓冲；全双工；面向连接；流控制。 TCP 段结构 各个字段的作用。 连接建立时协商好双方的起始序号； 序号是首字节在字节流的偏移量； 确认：是对顺序收到的最后一个字节 + 1。 RTT 时间估计和重发超时时间估计 移动平均计算 平均往返延迟。 当前往返延迟采样值与平均值的偏差。 平均值 + 4 偏差。 TCP 的可靠数据传输原理 快速重传 在没有超时情况下，收到对方对于某一个段的重复三次（一共 4 个）ACK。 流量控制 流控目的 防止淹没接收方。 流控手段 将接收窗口大小捎带方式传递给发送端。 TCP 连接管理 - 理解 连接建立 3 次握手技术，对双方选择的初始序号给予确认，准备好缓冲区。 第一次握手：SYN = 1，ACK = 0：发起端的序号。 第二次握手：syn = 1，ack = 1，被呼叫方的序号。 第三次握手：(syn = 0) ack = 1。 连接拆除 存在 2 军问题不完美（也不存在完美释放连接的方案，用定时器凑合解决）。 连接状态及其变迁。 拥塞控制原理 拥塞的概念 解释什么是拥塞，以及为什么会发生拥塞。 拥塞控制目的 **拥塞控制手段 ** 理解 端到端的拥塞控制：TCP 采用这种方式。 网络辅助的拥塞控制：ATM 网络标志和携带拥塞信息，反馈给主机（不要求）`。 TCP 的拥塞控制原理 TCP 拥塞控制原理 （需掌握） 检测拥塞 超时（拥塞，存在误判的可能性，但概率比较低）。 三个冗余 ACK（轻微拥塞）。 拥塞控制机制 AIMD（加性增 1 、乘性减 半 ）、慢启动 （加倍）、超时之后的保守策略。 TCP 拥塞控制的 2 种算法 Tahoe 超时事件和 3 个冗余 ACK 处理一样的，不要求。 reno 算法 （需掌握） 超时事件发生和 3 个冗余 ACK 处理不一样。 平均延迟和超时定时器时间的设置 **JACSON 算法（具体初始化和迭代算法， ** **不要求 ** ） 平均往返延迟公式。 Dev 算法：第一个超时时间 = 延迟的 1/2，初值设置；后面按公式。 超时时间设置：es + 4dev。 TCP 公平性：- 了解 TCP 的吞吐量计算：不要求 网络层之数据平面 简介 网络层的主要服务和功能 服务 向传输层提供主机到主机的段传输服务。 功能 1—— 转发，数据平面功能 从路由器的一个端口流入，从另外一个端口流出。 功能 2—— 路由，控制平面的功能 决定从源到目的的路径。 两个功能相互配合将数据报从源传送到目标主机；关联是转发表、流表。 实现网络层功能的两种方式 传统方式 控制平面和数据平面功能垂直集成在每个设备上（路由器）。 控制平面功能：路由协议实体分布式地计算路由表。 数据平面的功能：IP 协议按照路由表进行分组的转发。 SDN 通用转发方式 控制平面和数据平面分离，在不同设备上实现。 SDN 控制器集中式计算、下发流表实现控制平面功能。 SDN 分组交换机按照流表对到来的分组进行转发，实现数据平面的功能。 网络层提供服务的一些重要指标 带宽 延迟、延迟差 丢包与否 丢包率 路由器结构和工作原理 路由器的 2 大功能 （需理解） 路由协议 结果形成路由表（转发表）。 转发分组 使用转发表转发分组，交换。 构成 输入端口 线路终端实现物理层功能，链路协议实体实现链路层功能，网络层功能实现分布式分组转发。 最长前缀匹配。 交换结构 基于内存的，基于 bus 的，基于 CROSSBAR 的。 输出端口 网络层可以实现分组的调度：FIFO，RR，WFQ。 调度支持对多媒体分组等优先级分组的传输支持。 路由处理器 控制各部分协调工作。 互联网网络层协议 IP 网络提供的服务模型：尽力而为 包括含义：丢包、乱序、不可靠、（可能包括重复）。 网络层构成 协议 IP 协议、路由选择协议、ICMP 协议 转发表 IP 数据报格式 各个字段的作用 分片和重组 - 掌握 一个分组的总体大小超过了转发链路的 MTU，因此要切片。 到目标主机重组。 IP 编址 IP 地址：主机或路由器和网络接口的标识。 子网 在一个子网内的设备之间的通信有 2 个特点：1）通信无需借助路由器；2）子网前缀一样。 IP 地址分类：ABC（单步） D（多步） E（预留） 特殊 IP 地址（内网、全0、全1） 子网掩码和 CIDR **NAT ** **不要求 ** DHCP 协议：上网主机获得 IP、掩码、默认网关和 local name server。 路由聚集：连续的子网前缀的子网可达信息可以做聚集，减少向外部传输路由的数量，减少路由计算的负担。支持大概的路由聚集，与此对应的是最长前缀匹配的措施。 IPV 6： 格式（固定头部长度 40B ），地址：128 bits 变化（32-\u0026gt;128） IPV4 到 IPV6 的迁移 隧道 通用转发和 SDN SDN 方式控制平面和数据平面分离的优点 （需理解） 集中在控制器上实现控制逻辑，网络可编程，可以实现各种复杂的网络功能、新功能（一次部署，持续升级）、方便管理。 形成开发生态（控制器、分组交换机、网络应用，在一个开放的框架下协作）。 SDN 分组交换机按照计算出的流表进行分组转发、通用、便于升级。 分组交换机工作原理 （需理解） 模式匹配 + 行动（不仅仅是转发，还可以组播、泛洪、修改字段和阻塞等）。 进来分组，按照各级字段匹配流表，按照相应的行动动作分组。 按照优先权进行判断；之后，统计计数。 网络层之控制平面 概述 两种方式实现控制平面功能 传统方式：在每个路由器上分布式实现路由功能。 SDN 方式：在 SDN 控制器上由网络应用集中式计算、生成流表。 路由选择算法 路由目标 根据收集到的路由信息（拓扑、链路代价等）计算出源到目标较好的路径，代价比较低的路径。 主机 - 主机的路径 == 路由器到路由器的路径。 路由目标实际上是计算出节点的汇集树。 路由原则：完整正确、简单、健壮、稳定公平、最优（次优）。 路由分类 静态和动态（自适应）。 局部和全局的。 路由算法(Dijkstra, Bellman-Ford算法)_bellmanford算法和dijkstra-CSDN博客\nLS 算法（链路状态） （需掌握） 全局的路由选择算法，工作原理 每个节点收集邻居信息，生成 LS；LS 全网泛洪。 节点收集 LS 状态分组，形成网络拓扑。 按照最短路径算法算出到其他节点的最优路径。 DV 算法（距离矢量） （需掌握） 局部的路由选择算法，工作原理 每个节点维护到所有其他节点的下一跳和代价。 邻居节点之间定期交换 DV。 按照 Bellman-Ford 不断迭代生成到所有目标的代价和相应的下一跳 **层次路由 ** 理解 一个平面解决路由的问题：计算、传输和存储路由信息的量太大，不具备可扩展性，也不满足不同网络运营方不同的管理需求 分成 AS, AS 内部之间的节点路由由内部网关协议解决：AS 之间的路由，分层解决（路由到网关，由网关路由到目标网关（外部网关协议），到了目标 AS 内部，采用 AS 内部的路由解决） 优势：分层路由，解决了规模性问题，管理性问题 路由算法用于确定数据分组从源节点到目的节点的传输路径，其中静态路由与动态路由是两种重要的路由方式：\n静态路由 定义：静态路由是由网络管理员手动配置的路由信息。管理员依据网络拓扑结构，明确指定每个目的网络的下一跳路由器或出口接口。例如，在一个小型企业网中，仅有几条固定线路连接不同部门，管理员清楚各部门之间数据该如何流转，就可以手动设置静态路由。 优点： 安全性高：由于路由表是人工定制，外部攻击者较难篡改路由信息，能保障网络的基本架构安全。 低开销：不需要额外的路由协议进行路由信息交互，几乎不占用网络带宽与设备资源，适合简单网络拓扑。 可预测性强：数据传输路径固定，网络管理员能精准预估数据包走向，便于故障排查。 缺点： 缺乏灵活性：网络拓扑一旦变动，像新增节点、链路故障，静态路由无法自动调整，必须人工重新配置，在大型复杂网络里，工作量巨大。 配置繁琐：在大规模网络中，需要为众多目的网络逐个设置路由，容易出错且管理成本飙升。 动态路由 定义：动态路由依靠路由协议，让路由器之间自动交换网络拓扑和链路状态等信息，随后各自依据特定算法计算出最佳路由。常见的动态路由协议有 RIP、OSPF、BGP 等。例如，在互联网骨干网中，无数的路由器时刻在交互信息，动态更新路由表。 优点： 自适应网络变化：链路故障、网络扩容时，路由器能快速重新计算路由，保障网络畅通，无需人工干预。 配置简便：只需在路由器上启用相关路由协议，后续路由更新依靠协议自动完成，降低了管理员工作量。 缺点： 占用资源：路由协议持续交互信息，消耗网络带宽；路由器计算路由也占用自身的 CPU、内存资源。 存在安全风险：路由协议传输的信息如果被恶意篡改，会误导网络流量走向，引发网络安全事故。 静态路由和动态路由适用于不同的网络场景，简单、稳定的网络更适合静态路由，而复杂多变、规模较大的网络则要依靠动态路由来保障高效的数据传输。\n互联网的路由协议 路由协议分类 内部网关协议 IGP RIP OSPF：AS 内部支持分层路由，同时支持多种代价。 IGRP 外部网关协议 EGP BGP 网关路由器参与 AS 内部路由计算，收集 AS 内部子网可达信息 网关路由器通过 AS 间路由向其他 AS 网关通告子网可达信息。 网关路由器还转发 “过手” 子网可达信息，但是 AS 路径要加上它自己 AS 编号（防止形成环路）。 网关路由器通过 i - BGP 向 AS 内部所有路由节点通告收集到的子网可达信息。 内部路由器，通过 AS 内路由和 AS 间路由共同决定向 AS 外部子网的下一跳（内部网关协议决定如何去往网关，外部网关协议决定通过那个网关可到达 AS 外部子网）。 内部网关协议和外部网关协议的对比 （了解） 内部网关协议重视效率，性能。 外部网关协议重视策略：经济策略和政治策略 SDN 控制平面 在控制器上集中实现控制功能。 控制器和 SDN 交换机按照 openflow等南向接口协议等下发流表，上报设备状态。 SDN 控制器按照北向接口和网络应用打交道。 ICMP 协议 （了解） 作用：包括错误、echo请求和应答。 报文类型。 数据链路层与局域网 引论 链路层提供的服务 成帧、链路存取控制（链路访问控制）。 在相邻节点间进行可靠数据传递。 流量控制。 检错。 纠错。 全双工和半双工服务。 链路层网络节点的连接方式 点到点方式：比较适合广域。 多点连接的方式：比较适合局域、联网方便，但是需要解决 MAC 问题。 检错与纠错 检错原理 奇偶校验。 CRC（循环冗余校验） - 掌握 原理。 生成多项式。 冗余位计算方法以及验证方法。 多路访问协议 MAC 的必要性 MAP 信道划分 TDMA FDMA CDMA：删掉 RAP：随机访问协议 slotted ALOHA ALOHA CSMA，**CSMA/CD（至少 2t 长度帧），CSMA/CA ** 轮转协议：不要求 令牌协议 链路层编地址 MAC 地址（48位） 格式 分配 MAC 地址和网络层 IP 地址的区别 层次不同 MAC 地址平面的，用于标示一个物理网络的不同站点；IP 是可以聚集的，便于计算路由 ARP 协议 目的：物理网络范围内 IP 地址到 MAC 地址的转换 工作原理：广播查询，单播应答 以太网 IEEE802.3 标准，链路层和相应的物理层。 以太网的帧结构。 向上提供服务的特点。 无连接：以太网在传输数据时不需要事先建立连接。 不可靠：数据传输过程中不保证数据的可靠到达。 访问控制技术。 CSMA/CD （需掌握）：载波侦听多路访问 / 冲突检测，用于解决以太网中的冲突问题。 指数后退：在发生冲突后，设备会采用指数后退算法等待一段时间后再尝试发送。 **CSMA/CA ** （需理解）：载波侦听多路访问 / 冲突避免，适用于无线网络。 编码。 Manchester 编码：一种常用的编码方式。 HUB 和交换机 HUB 连接方式的问题。 无法隔离冲突，在一个冲突域之中：使用 HUB 连接设备时，所有连接的设备处于同一个冲突域，容易产生冲突。 交换机的工作原理。 选择性转发：交换机可以根据目的地址有选择地转发数据。 自学习：交换机能够自动学习连接设备的 MAC 地址。 流量隔离：交换机可以隔离不同端口的流量，减少冲突。 专用接入：交换机提供专用的接入端口。 路由器和交换机的区别 （需理解） 参考 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程\n","date":"2025-01-22T00:00:00Z","permalink":"https://hongyun-yu.github.io/Hugo-dev/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E5%A4%8D%E4%B9%A0/","title":"计算机网络总复习"}]