<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="计算机网络总复习，参考了B站视频中科大郑烇、杨坚老师的《计算机网络-自顶向下方法》给出的总复习，同时结合课程考核加入了一些内容">
<title>计算机网络总复习</title>

<link rel='canonical' href='https://hongyun-yu.github.io/Hugo-dev/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E5%A4%8D%E4%B9%A0/'>

<link rel="stylesheet" href="/Hugo-dev/scss/style.min.931ff95f801376156525fd9d531ff3120af79ead784dd3bd6ce58d23d430b394.css"><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script>
    
    $(window).scroll(function() {
    if ($(this).scrollTop()) {
        $('#back-to-top').fadeIn();
    } else {
        $('#back-to-top').fadeOut();
    }
    });

    
    $('#back-to-top').click(function() {
    $('html, body').animate({scrollTop: 0}, 1000);
    return false;
    });
</script>
<meta property='og:title' content="计算机网络总复习">
<meta property='og:description' content="计算机网络总复习，参考了B站视频中科大郑烇、杨坚老师的《计算机网络-自顶向下方法》给出的总复习，同时结合课程考核加入了一些内容">
<meta property='og:url' content='https://hongyun-yu.github.io/Hugo-dev/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E5%A4%8D%E4%B9%A0/'>
<meta property='og:site_name' content='羡余'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='计算机网络' /><meta property='article:published_time' content='2025-01-22T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-02-20T16:19:32&#43;08:00'/><meta property='og:image' content='https://www.helloimg.com/i/2025/02/20/67b6e34cc4b6a.png' />
<meta name="twitter:title" content="计算机网络总复习">
<meta name="twitter:description" content="计算机网络总复习，参考了B站视频中科大郑烇、杨坚老师的《计算机网络-自顶向下方法》给出的总复习，同时结合课程考核加入了一些内容"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://www.helloimg.com/i/2025/02/20/67b6e34cc4b6a.png' />
    <link rel="shortcut icon" href="/Hugo-dev/fish.svg" />

  


    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended">


        <div id="article-toolbar" style="position: sticky;top: 5px;z-index: 1000;">
            <a href="/Hugo-dev" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    

    

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#计算机网络与互联网络">计算机网络与互联网络</a>
      <ol>
        <li><a href="#什么是互联网络">什么是互联网络</a></li>
        <li><a href="#网络边缘">网络边缘</a></li>
        <li><a href="#网络核心">网络核心</a></li>
        <li><a href="#网络接入与物理介质">网络接入与物理介质</a></li>
        <li><a href="#互联网络结构与-isp">互联网络结构与 ISP</a>
          <ol>
            <li><a href="#近似层次型结构">近似层次型结构</a></li>
            <li><a href="#isp-之间的连接">ISP 之间的连接</a></li>
            <li><a href="#内容提供商网络">内容提供商网络</a></li>
          </ol>
        </li>
        <li><a href="#分组交换网络中的延迟与丢失">分组交换网络中的延迟与丢失</a>
          <ol>
            <li><a href="#延迟的-4-个原因计算font-stylecolordf2a3f---掌握-font">延迟的 4 个原因（计算）<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code> - 掌握 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#流量强度0-1与排队延迟正相关lar-font-stylecolordf2a3f--掌握-font">流量强度（0-1，与排队延迟正相关）：La/R <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>- 掌握 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#丢失原因">丢失原因：</a></li>
            <li><a href="#吞吐量-font-stylecolor74b602--了解-font">吞吐量 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> -了解 <code>&lt;/font&gt;</code></a></li>
          </ol>
        </li>
        <li><a href="#协议层次与服务模型">协议层次与服务模型</a>
          <ol>
            <li><a href="#为什么要分层">为什么要分层</a></li>
            <li><a href="#网络比较复杂分层实现比较容易设计调试实现">网络比较复杂，分层实现比较容易设计、调试、实现。</a></li>
            <li><a href="#一些术语和概念-font-stylecolor74b602-理解-font">一些术语和概念 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>-理解 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#互联网络分层模型及每一层的功能-font-stylecolor74b602-理解-font">互联网络分层模型及每一层的功能 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>-理解 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#封装和解封">封装和解封</a></li>
          </ol>
        </li>
        <li><a href="#历史-font-stylecolor74b602-了解-font">历史 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>-了解 <code>&lt;/font&gt;</code></a></li>
      </ol>
    </li>
    <li><a href="#应用层">应用层</a>
      <ol>
        <li><a href="#网络应用原理">网络应用原理</a></li>
        <li><a href="#web-和-http">WEB 和 HTTP</a>
          <ol>
            <li><a href="#web-应用包括">WEB 应用包括</a></li>
            <li><a href="#术语">术语</a></li>
            <li><a href="#font-stylecolordf2a3fhttp-协议-font"><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>HTTP 协议 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#font-stylecolordf2a3fhttp-10-到-http-11-再到-http-20-的演变-font"><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>HTTP 1.0 到 HTTP 1.1 再到 HTTP 2.0 的演变 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#从-ssl-到-http30基于-udp的安全优化过程">从 SSL 到 HTTP/3.0（基于 UDP）的安全优化过程</a></li>
            <li><a href="#报文格式">报文格式</a></li>
            <li><a href="#cookieshttp无状态-有状态">COOKIES（HTTP无状态-&gt;有状态）</a></li>
            <li><a href="#web-缓存">WEB 缓存</a></li>
          </ol>
        </li>
        <li><a href="#ftp-font-stylecolor74b602不要求font">FTP <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（不要求）<code>&lt;/font&gt;</code></a></li>
        <li><a href="#email">EMAIL</a>
          <ol>
            <li><a href="#电子邮件应用的构成">电子邮件应用的构成</a></li>
            <li><a href="#邮件报文格式解析">邮件报文格式解析</a></li>
            <li><a href="#邮件存取协议">邮件存取协议</a></li>
          </ol>
        </li>
        <li><a href="#dns">DNS</a>
          <ol>
            <li><a href="#dns-作用">DNS 作用</a></li>
            <li><a href="#二dns-的概念">二、DNS 的概念</a></li>
            <li><a href="#三dns-的构成">三、DNS 的构成</a></li>
            <li><a href="#域名解析的过程">域名解析的过程</a></li>
            <li><a href="#dns-缓存">DNS 缓存</a></li>
          </ol>
        </li>
        <li><a href="#p2p-font-stylecolor74b602了解p2p-的概念和优势即可font">P2P <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解P2P 的概念和优势即可）<code>&lt;/font&gt;</code></a>
          <ol>
            <li><a href="#p2p-概念">P2P 概念</a></li>
            <li><a href="#p2p-网络比-cs-方式分发内容快的原因">P2P 网络比 C/S 方式分发内容快的原因</a></li>
            <li><a href="#典型-p2p-应用及其原理-font-stylecolor74b602不要求font">典型 P2P 应用及其原理 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（不要求）<code>&lt;/font&gt;</code></a></li>
          </ol>
        </li>
        <li><a href="#视频流化服务和-cdn-font-stylecolor74b602了解font">视频流化服务和 CDN <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解）<code>&lt;/font&gt;</code></a>
          <ol>
            <li><a href="#服务器向客户端进行视频流化的方式">服务器向客户端进行视频流化的方式</a></li>
            <li><a href="#dash-流化的过程">DASH 流化的过程</a></li>
            <li><a href="#cdn">CDN</a></li>
          </ol>
        </li>
        <li><a href="#tcp-的-socket-编程-font-stylecolor74b602理解-font">TCP 的 SOCKET 编程 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>理解 <code>&lt;/font&gt;</code></a>
          <ol>
            <li><a href="#socket-概念">SOCKET 概念</a></li>
            <li><a href="#socket-api">SOCKET API</a></li>
            <li><a href="#tcp-socket-数据传输的特点">TCP SOCKET 数据传输的特点</a></li>
            <li><a href="#tcp-socket-编程">TCP SOCKET 编程</a></li>
          </ol>
        </li>
        <li><a href="#udp-的-socket-编程-font-stylecolor74b602理解-font">UDP 的 SOCKET 编程 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>理解 <code>&lt;/font&gt;</code></a></li>
      </ol>
    </li>
    <li><a href="#传输层">传输层</a>
      <ol>
        <li><a href="#传输层服务">传输层服务</a>
          <ol>
            <li><a href="#传输服务">传输服务</a></li>
            <li><a href="#互联网络传输层协议">互联网络传输层协议</a></li>
          </ol>
        </li>
        <li><a href="#复用与解复用">复用与解复用</a>
          <ol>
            <li><a href="#复用">复用</a></li>
            <li><a href="#解复用">解复用</a></li>
            <li><a href="#复用和解复用的工作原理ip-port">复用和解复用的工作原理：IP PORT</a></li>
          </ol>
        </li>
        <li><a href="#无连接传输层协议-udp">无连接传输层协议 UDP</a></li>
        <li><a href="#可靠数据传输原理">可靠数据传输原理</a>
          <ol>
            <li><a href="#font-stylecolordf2a3frdtreliable-data-transfer可靠数据传输102030-的功能特点-font"><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>RDT（Reliable Data Transfer，可靠数据传输）1.0、2.0、3.0 的功能特点 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#利用率计算-font-stylecolor74b602-了解-font">利用率计算 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> 了解 <code>&lt;/font&gt;</code></a></li>
          </ol>
        </li>
        <li><a href="#有连接传输层协议tcp">有连接传输层协议：TCP</a>
          <ol>
            <li><a href="#tcp-服务特性">TCP 服务特性</a></li>
            <li><a href="#tcp-段结构">TCP 段结构</a></li>
            <li><a href="#rtt-时间估计和重发超时时间估计">RTT 时间估计和重发超时时间估计</a></li>
            <li><a href="#tcp-的可靠数据传输原理">TCP 的可靠数据传输原理</a></li>
            <li><a href="#流量控制">流量控制</a></li>
            <li><a href="#tcp-连接管理-font-stylecolor74b602-理解-font">TCP 连接管理 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> 理解 <code>&lt;/font&gt;</code></a></li>
          </ol>
        </li>
        <li><a href="#拥塞控制原理">拥塞控制原理</a></li>
        <li><a href="#tcp-的拥塞控制原理">TCP 的拥塞控制原理</a>
          <ol>
            <li><a href="#tcp-拥塞控制原理-font-stylecolordf2a3f需掌握font">TCP 拥塞控制原理 <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>（需掌握）<code>&lt;/font&gt;</code></a></li>
            <li><a href="#tcp-拥塞控制的-2-种算法">TCP 拥塞控制的 2 种算法</a></li>
            <li><a href="#平均延迟和超时定时器时间的设置">平均延迟和超时定时器时间的设置</a></li>
            <li><a href="#tcp-公平性font-stylecolor74b602了解-font">TCP 公平性：<code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>了解 <code>&lt;/font&gt;</code></a></li>
            <li><a href="#tcp-的吞吐量计算font-stylecolor74b602不要求-font">TCP 的吞吐量计算：<code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>不要求 <code>&lt;/font&gt;</code>。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#网络层之数据平面">网络层之数据平面</a>
      <ol>
        <li><a href="#简介">简介</a>
          <ol>
            <li><a href="#网络层的主要服务和功能">网络层的主要服务和功能</a></li>
            <li><a href="#实现网络层功能的两种方式">实现网络层功能的两种方式</a></li>
            <li><a href="#网络层提供服务的一些重要指标">网络层提供服务的一些重要指标</a></li>
          </ol>
        </li>
        <li><a href="#路由器结构和工作原理">路由器结构和工作原理</a>
          <ol>
            <li><a href="#路由器的-2-大功能-font-stylecolor74b602需理解font">路由器的 2 大功能 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（需理解）<code>&lt;/font&gt;</code></a></li>
            <li><a href="#构成">构成</a></li>
          </ol>
        </li>
        <li><a href="#互联网网络层协议">互联网网络层协议</a>
          <ol>
            <li><a href="#ip-网络提供的服务模型尽力而为">IP 网络提供的服务模型：尽力而为</a></li>
            <li><a href="#网络层构成">网络层构成</a></li>
          </ol>
        </li>
        <li><a href="#通用转发和-sdn">通用转发和 SDN</a>
          <ol>
            <li><a href="#sdn-方式控制平面和数据平面分离的优点-font-stylecolor74b602需理解font">SDN 方式控制平面和数据平面分离的优点 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（需理解）<code>&lt;/font&gt;</code></a></li>
            <li><a href="#sdn-分组交换机按照计算出的流表进行分组转发通用便于升级">SDN 分组交换机按照计算出的流表进行分组转发、通用、便于升级。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#网络层之控制平面">网络层之控制平面</a>
      <ol>
        <li><a href="#概述">概述</a></li>
        <li><a href="#路由选择算法">路由选择算法</a></li>
        <li><a href="#互联网的路由协议">互联网的路由协议</a>
          <ol>
            <li><a href="#路由协议分类">路由协议分类</a></li>
            <li><a href="#网关路由器参与-as-内部路由计算收集-as-内部子网可达信息">网关路由器参与 AS 内部路由计算，收集 AS 内部子网可达信息</a></li>
            <li><a href="#内部网关协议和外部网关协议的对比-font-stylecolor74b602了解font">内部网关协议和外部网关协议的对比 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解）<code>&lt;/font&gt;</code></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#sdn-控制平面">SDN 控制平面</a>
      <ol>
        <li><a href="#icmp-协议-font-stylecolor74b602了解font">ICMP 协议 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解）<code>&lt;/font&gt;</code></a></li>
      </ol>
    </li>
    <li><a href="#数据链路层与局域网">数据链路层与局域网</a>
      <ol>
        <li><a href="#引论">引论</a></li>
        <li><a href="#检错与纠错">检错与纠错</a></li>
        <li><a href="#多路访问协议">多路访问协议</a></li>
        <li><a href="#链路层编地址">链路层编地址</a></li>
        <li><a href="#以太网">以太网</a></li>
        <li><a href="#hub-和交换机">HUB 和交换机</a></li>
      </ol>
    </li>
    <li><a href="#参考">参考</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/Hugo-dev/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E5%A4%8D%E4%B9%A0/">
                
                    <img src="https://www.helloimg.com/i/2025/02/20/67b6e34cc4b6a.png" loading="lazy" alt="Featured image of post 计算机网络总复习" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/Hugo-dev/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" >
                计算机网络
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/Hugo-dev/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E5%A4%8D%E4%B9%A0/">计算机网络总复习</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            计算机网络总复习，参考了B站视频中科大郑烇、杨坚老师的《计算机网络-自顶向下方法》给出的总复习，同时结合课程考核加入了一些内容
        </h3>
        
    </div>

    
        <footer class="article-time">
            
                <div>
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                    <time class="article-time--published">2025-01-22</time>
                </div>
            

            
            
                        最后修改:
                        <time class="article-time--updated" datetime="2025-02-20 16:19:32 &#43;0800 CST" title="2025-02-20 16:19:32 &#43;0800 CST">
                            2025-02-20
                        </time>

            
        </footer>
    


    
</div>


</header>

    <section class="article-content">
    
    
    <h2 id="计算机网络与互联网络">计算机网络与互联网络
</h2><h3 id="什么是互联网络">什么是互联网络
</h3><ul>
<li><strong>从构成的角度来看</strong>：
<ul>
<li>互联网络由点和边构成。其中，点包括端系统（涵盖网络应用）以及路由器；边则是链路。简单来说，互联网络其实是网络的网络，众多不同的网络相互连接，形成了一个庞大复杂的体系。</li>
</ul>
</li>
<li><strong>从服务的角度来看</strong>：
<ul>
<li>互联网络是一种能够为应用提供通信服务的通信架构。在这个架构里，有连接且可靠的服务与无连接的不可靠服务相互配合，共同支撑各类应用开展通信服务。</li>
<li><strong>协议</strong>：指对等层实体在通信过程中所遵循的规则的集合，这一集合可以从<strong>语法、语义及时序</strong>三个方面去理解。<strong>语法</strong>规定了数据与控制信息的结构或格式；<strong>语义</strong>说明了需要发出何种控制信息，完成何种动作以及做出何种响应；<strong>时序</strong>则明确了事件实现顺序的详细说明。</li>
</ul>
</li>
</ul>
<h3 id="网络边缘">网络边缘
</h3><ul>
<li><strong>网络的结构</strong>：
<ul>
<li>网络整体结构分为网络边缘与网络核心两大部分，还涉及接入网络与通信链路。网络边缘包括运行应用的端系统，重点在于 <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>端系统中的应用交互方式 <code>&lt;/font&gt;</code>；网络核心则由路由器组成。</li>
</ul>
</li>
<li><strong><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>网络边缘的应用交互方式 <code>&lt;/font&gt;</code></strong> <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>：<code>&lt;/font&gt;</code>
<ul>
<li><strong>C/S 模式（客户端 / 服务器模式）</strong>：其特点在于，客户端向服务器发起请求，服务器响应请求并为客户端提供服务。服务器往往具备强大的处理能力与丰富的数据资源，客户端则相对轻量化，依赖服务器获取数据与执行复杂运算，常见于网页浏览、邮件收发等应用场景。</li>
<li><strong>P2P 模式（对等模式）</strong>：这种模式下，各个端系统地位平等，既可以作为客户端向其他节点请求资源，也能充当服务器为其他节点提供资源。它无需依赖集中式服务器，有较强的扩展性与容错性，常用于文件共享、流媒体直播等应用。</li>
</ul>
</li>
<li><strong>网络的服务</strong>：
<ul>
<li><strong>面向连接的服务</strong>：这类服务在通信前会先建立连接，整个通信过程数据传输稳定、可靠，能保证数据按序到达接收方，不过建立连接与拆除连接会带来额外开销。</li>
<li><strong>无连接的服务</strong>：通信时无需事先建立连接，直接发送数据报，传输效率较高，但无法保证数据一定能可靠、有序地到达接收方。</li>
</ul>
</li>
</ul>
<h3 id="网络核心">网络核心
</h3><ul>
<li><strong>网络核心</strong>
<ul>
<li><strong>组成</strong>：网络交换设备，如路由器 + 链路。</li>
<li><strong>功能</strong>：数据交换。</li>
</ul>
</li>
<li><strong>数据交换方式及比较</strong>
<ul>
<li><strong>分组交换</strong>：存储转发方式，统计复用。<code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>理解 <code>&lt;/font&gt;</code>
<ul>
<li>VC（虚电路）</li>
<li>Datagram（数据报）</li>
</ul>
</li>
<li><strong>线路交换</strong>
<ul>
<li>FDM（频分复用）</li>
<li>TDM（时分复用）</li>
<li>WDM（波分复用）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络接入与物理介质">网络接入与物理介质
</h3><ul>
<li>网络接入是指将端系统连接到边缘路由器的链路或网络。</li>
<li>住宅接入采用点到点接入方式，具体包括：
<ul>
<li>ADSL（非对称数字用户线路）</li>
<li>HFC（混合光纤同轴电缆）</li>
<li>Cable Modem（电缆调制解调器）</li>
<li>Home Networks（家庭网络）</li>
</ul>
</li>
<li>机构接入：LAN
<ul>
<li>以太网</li>
<li>WLAN（无线网）</li>
</ul>
</li>
<li>物理链路（第 0 层）
<ul>
<li>导向型介质（有型，光纤等）</li>
<li>非导向型介质（无形，电磁波、光信号等）</li>
</ul>
</li>
<li>常用介质
<ul>
<li>TP 双绞线</li>
<li>同轴电缆</li>
<li>光纤</li>
<li>Radio（电磁波信号）</li>
</ul>
</li>
</ul>
<h3 id="互联网络结构与-isp">互联网络结构与 ISP
</h3><h4 id="近似层次型结构">近似层次型结构
</h4><ul>
<li>T - 1 ISP</li>
<li>T - 2 ISP (Regional ISP)</li>
<li>Local ISP</li>
</ul>
<h4 id="isp-之间的连接">ISP 之间的连接
</h4><ul>
<li>对等连接</li>
<li>IXP（<code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.85);&quot;&gt;</code>互联网交换点 <code>&lt;/font&gt;</code>）</li>
</ul>
<h4 id="内容提供商网络">内容提供商网络
</h4><ul>
<li>在全球部署 DC（数据中心）</li>
<li>内容提供商网络在多处与各个 ISP 相联</li>
<li>内容提供商自己部署网络将全球的 DC 相联
<ul>
<li>内容提供商 DC 自己之间的访问，通过自己部署的专网</li>
<li>用户接入后通过离用户最近的 DC 为之服务</li>
</ul>
</li>
</ul>
<h3 id="分组交换网络中的延迟与丢失">分组交换网络中的延迟与丢失
</h3><h4 id="延迟的-4-个原因计算font-stylecolordf2a3f---掌握-font">延迟的 4 个原因（计算）<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code> - 掌握 <code>&lt;/font&gt;</code>
</h4><ul>
<li>处理延迟</li>
<li>排队延迟</li>
<li>传输延迟</li>
<li>传播延迟</li>
</ul>
<p>例如：n 段，分组 L，R，传播延迟 d 每段如何计算总体延迟；</p>
<h4 id="流量强度0-1与排队延迟正相关lar-font-stylecolordf2a3f--掌握-font">流量强度（0-1，与排队延迟正相关）：La/R <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>- 掌握 <code>&lt;/font&gt;</code>
</h4><ul>
<li>排队延迟   依赖**<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>流量强度的公式 <code>&lt;/font&gt;</code>**；</li>
</ul>
<h4 id="丢失原因">丢失原因：
</h4><ul>
<li>缓冲区溢出 + 出错没通过校验</li>
</ul>
<h4 id="吞吐量-font-stylecolor74b602--了解-font">吞吐量 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> -了解 <code>&lt;/font&gt;</code>
</h4><ul>
<li>瞬间吞吐量</li>
<li>平均吞吐量</li>
</ul>
<p>瓶颈链路决定了主机之间的吞吐量（从每段链路获得的大致带宽是 1/N，瓶颈链路是所有链路段中获得带宽最小的）。</p>
<h3 id="协议层次与服务模型">协议层次与服务模型
</h3><h4 id="为什么要分层">为什么要分层
</h4><h4 id="网络比较复杂分层实现比较容易设计调试实现">网络比较复杂，分层实现比较容易设计、调试、实现。
</h4><ul>
<li>分层：将复杂的网络功能划分成功能明确的层次，<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>上层利用下层提供的服务来实现本层的协议，从而为上层提供更复杂的功能。<code>&lt;/font&gt;</code></li>
</ul>
<h4 id="一些术语和概念-font-stylecolor74b602-理解-font">一些术语和概念 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>-理解 <code>&lt;/font&gt;</code>
</h4><ul>
<li>服务、服务访问原语、服务访问点</li>
<li>面向连接的服务、无连接的服务</li>
<li>协议、协议数据单元 PDU</li>
<li>服务（垂直）和协议（水平）之间的关系（区别与联系）
<ul>
<li>服务利用了下层协议的实现，为上层提供服务</li>
<li>协议的实现依靠下层服务</li>
</ul>
</li>
</ul>
<h4 id="互联网络分层模型及每一层的功能-font-stylecolor74b602-理解-font">互联网络分层模型及每一层的功能 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>-理解 <code>&lt;/font&gt;</code>
</h4><ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层（端到端，路由和转发）</li>
<li>链路层（点到点，帧为单位）</li>
<li>物理层（物理信号）</li>
</ul>
<h4 id="封装和解封">封装和解封
</h4><h3 id="历史-font-stylecolor74b602-了解-font">历史 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>-了解 <code>&lt;/font&gt;</code>
</h3><ul>
<li>ARPANET：美国军方资助的分组交换实验网，由于 TCP/IP 架构的包容性、免费使用、架构便于应用创新吸引更多的用户等原因，用户数量、节点数量和应用数量越来越多。</li>
<li>NSF 建立 ARPANET 的访问网。</li>
<li>民用网络从军用网络脱开，成为现在的互联网。</li>
</ul>
<p>术语：IETF（互联网工程任务组）, ITU(国际电信联盟），IEEE（电气电子工程师协会 ），RFC（请求评论，是一系列关于互联网技术的文件）。</p>
<h2 id="应用层">应用层
</h2><p>原理 + 应用实例 + SOCKET 编程</p>
<p>应用的开发只集中在端系统上，对路由器没有任何改变，这鼓励了互联网架构下的应用创新。</p>
<h3 id="网络应用原理">网络应用原理
</h3><ol>
<li><strong>应用架构</strong>
<ul>
<li>C/S（客户端 / 服务器）</li>
<li>P2P（对等网络）</li>
<li>混合架构</li>
</ul>
</li>
<li><strong>进程间通信</strong>
<ul>
<li>同主机：操作系统定义的通信方法</li>
<li>不同主机：利用网络提供的架构（Socket）交换报文</li>
</ul>
</li>
<li><strong>SOCKET</strong>
<ul>
<li>一个整数，OS 用于标示应用通信关系所采用的本地标示</li>
<li>**TCP：**连接的本地标示</li>
<li>**UDP：**端节点的本地标示</li>
</ul>
</li>
<li><strong>进程编址</strong>
<ul>
<li>I<strong>P + PORT</strong>（本质上在传输层应用了端口号，用于区分应用，TCP 和 UDP 使用端口号的方式不同）</li>
</ul>
</li>
<li><strong>应用所需要的服务需要考虑的因素（网络所提供服务的主要指标）</strong>
<ul>
<li>丢失率可靠性</li>
<li>延迟、延迟差（抖动）</li>
<li>带宽</li>
<li>安全性</li>
</ul>
</li>
<li><strong>传输层协议</strong>
<ul>
<li><strong>TCP 提供的服务特性</strong>：可靠字节流服务，面向连接，流量控制，拥塞控制</li>
<li><strong>UDP 提供的服务特性</strong>：无连接，不可靠的服务</li>
</ul>
</li>
</ol>
<p>都能够提供进程的标示，区分不同的进程</p>
<h3 id="web-和-http">WEB 和 HTTP
</h3><h4 id="web-应用包括">WEB 应用包括
</h4><ul>
<li>HTTP 协议</li>
<li>HTML</li>
<li>CLIENT（客户端），SERVER（服务器）</li>
</ul>
<h4 id="术语">术语
</h4><ul>
<li>网页</li>
<li>对象</li>
<li>引用 URL</li>
</ul>
<h4 id="font-stylecolordf2a3fhttp-协议-font"><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>HTTP 协议 <code>&lt;/font&gt;</code>
</h4><ul>
<li>定义了 C（客户端）和 S（服务器）之间通信的报文格式、解释和时序。</li>
<li>HTTP 连接
<ul>
<li>持续性连接</li>
<li>非持续性连接</li>
</ul>
</li>
<li>往返延迟 RTT 和对象的抓取时间</li>
</ul>
<h4 id="font-stylecolordf2a3fhttp-10-到-http-11-再到-http-20-的演变-font"><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>HTTP 1.0 到 HTTP 1.1 再到 HTTP 2.0 的演变 <code>&lt;/font&gt;</code>
</h4><h5 id="http-10">HTTP 1.0
</h5><ol>
<li><strong>基本特点</strong>
<ul>
<li><strong>无状态协议</strong>：每个请求都是独立的，服务器不会在不同请求之间保留状态信息。</li>
<li><strong>简单的请求 - 响应模型</strong>：客户端发起请求，服务器响应请求，一次请求对应一次响应。</li>
<li><strong>支持多种请求方法</strong>：如 GET、POST、HEAD 等。</li>
</ul>
</li>
<li><strong>局限性</strong>
<ul>
<li><strong>连接管理效率低</strong>：每对请求 - 响应都需要建立一个新的 TCP 连接，这导致了较高的连接建立开销，特别是在请求大量小文件时。</li>
<li><strong>缺乏对缓存的充分支持</strong>：缓存机制比较简单，没有很好地处理资源更新和验证的问题。</li>
</ul>
</li>
</ol>
<h5 id="http-11">HTTP 1.1
</h5><ol>
<li><strong>改进之处</strong>
<ul>
<li><strong>持久连接（Keep - Alive）</strong>
<ul>
<li>允许在一个 TCP 连接上进行多次请求 - 响应交互，减少了建立连接的开销。</li>
<li>客户端和服务器可以通过 <code>Connection: keep - alive</code>头字段来协商保持连接。</li>
</ul>
</li>
<li><strong>管道化（Pipelining）</strong>
<ul>
<li>允许客户端在等待第一个请求的响应时，发送第二个请求，进一步提高了性能。</li>
</ul>
</li>
<li><strong>增强的缓存机制</strong>
<ul>
<li>引入了更多的缓存控制头字段，如 <code>Cache - Control</code>、<code>ETag</code>和 <code>If - Modified - Since</code>等，使得缓存管理更加灵活和高效。</li>
</ul>
</li>
<li><strong>分块传输编码（Chunked Transfer Coding）</strong>
<ul>
<li>允许服务器在不知道内容长度的情况下，分块发送响应内容，适用于动态生成内容的情况。</li>
</ul>
</li>
</ul>
</li>
<li><strong>局限性</strong>
<ul>
<li><strong>头部信息冗余</strong>：每个请求和响应都携带完整的头部信息，在大量请求时，头部数据的传输会造成性能瓶颈。</li>
<li><strong>队首阻塞（Head - of - line Blocking）</strong>：在管道化连接中，如果一个请求被阻塞，后续的请求都要等待，即使后续请求不需要依赖前面被阻塞的请求。</li>
</ul>
</li>
</ol>
<h5 id="http-20">HTTP 2.0
</h5><ol>
<li><strong>主要特性</strong>
<ul>
<li><strong>二进制分帧层（Binary Framing Layer）</strong>
<ul>
<li>HTTP 2.0 将所有传输的信息分割为更小的帧，并对帧进行二进制编码。这使得协议更加紧凑和高效。</li>
<li>通过帧的形式，实现了在一个 TCP 连接上多路复用多个请求和响应，避免了 HTTP 1.1 中的队首阻塞问题。</li>
</ul>
</li>
<li><strong>头部压缩（Header Compression）</strong>
<ul>
<li>使用 HPACK 算法对头部信息进行压缩，减少了头部数据的传输量。</li>
<li>对于重复的头部字段，可以只传输差异部分，进一步提高了压缩效率。</li>
</ul>
</li>
<li><strong>服务器推送（Server Push）</strong>
<ul>
<li>服务器可以在客户端没有请求的情况下，主动向客户端推送资源。例如，当客户端请求 HTML 页面时，服务器可以同时推送页面所需的 CSS 和 JavaScript 文件，减少客户端的等待时间。</li>
</ul>
</li>
</ul>
</li>
<li><strong>性能提升</strong>
<ul>
<li>HTTP 2.0 通过上述特性，在网络性能上有了显著提升，特别是在处理大量小资源和高并发请求时表现出色。</li>
</ul>
</li>
</ol>
<p>从 HTTP 1.0 到 HTTP 1.1 再到 HTTP 2.0，协议不断进化，旨在解决前一版本的性能瓶颈，提高网络传输效率和用户体验。</p>
<h4 id="从-ssl-到-http30基于-udp的安全优化过程">从 SSL 到 HTTP/3.0（基于 UDP）的安全优化过程
</h4><h5 id="sslsecure-sockets-layer安全套接层">SSL（Secure Sockets Layer，安全套接层）
</h5><ol>
<li><strong>基本原理</strong>
<ul>
<li>SSL 是一种早期的网络安全协议，用于在客户端和服务器之间建立加密连接，确保数据在传输过程中的保密性、完整性和身份验证。</li>
<li>它通过握手过程来协商加密算法、密钥交换和身份验证方法。</li>
</ul>
</li>
<li><strong>局限性</strong>
<ul>
<li><strong>性能问题</strong>
<ul>
<li>SSL 的握手过程相对复杂，尤其是在早期版本中，这会导致较高的连接建立延迟。</li>
<li>对于每一个新的连接，都需要重新进行握手，这在高并发场景下会影响性能。</li>
</ul>
</li>
<li><strong>安全性逐渐减弱</strong>
<ul>
<li>随着技术的发展，SSL 的一些加密算法和协议漏洞被发现，安全性逐渐不能满足现代网络安全的需求。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="tlstransport-layer-security传输层安全">TLS（Transport Layer Security，传输层安全）
</h5><ol>
<li><strong>与 SSL 的关系</strong>
<ul>
<li>TLS 是 SSL 的继任者，它在 SSL 的基础上进行了改进和扩展。TLS 的目标与 SSL 相同，即确保网络通信的安全，但在安全性和性能方面有了显著提升。</li>
</ul>
</li>
<li><strong>改进之处</strong>
<ul>
<li><strong>增强的加密算法</strong>
<ul>
<li>TLS 采用了更强大和更安全的加密算法，如 AES（Advanced Encryption Standard）等，以应对不断出现的安全威胁。</li>
</ul>
</li>
<li><strong>优化的握手过程</strong>
<ul>
<li>TLS 对握手过程进行了优化，例如引入了会话恢复机制。当客户端和服务器之前已经建立过连接，在一定条件下可以复用之前的会话参数，减少握手时间。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="http30基于-udp-的-quic-协议">HTTP/3.0（基于 UDP 的 QUIC 协议）
</h5><ol>
<li><strong>QUIC（Quick UDP Internet Connections）协议</strong>
<ul>
<li>HTTP/3.0 是基于 QUIC 协议的，而 QUIC 是基于 UDP 的。QUIC 旨在解决 TCP 和 TLS 在性能和安全性方面的一些问题。</li>
</ul>
</li>
<li><strong>安全特性</strong>
<ul>
<li><strong>集成加密</strong>
<ul>
<li>QUIC 将加密作为协议的核心部分，从一开始就对数据进行加密，避免了像 TCP + TLS 那样分两步进行加密的复杂性。</li>
</ul>
</li>
<li><strong>0 - RTT 连接建立（在某些情况下）</strong>
<ul>
<li>QUIC 允许在某些条件下实现 0 - RTT（Round - Trip Time）连接建立。例如，当客户端和服务器之前已经建立过连接并且缓存了相关的加密参数时，客户端可以立即发送应用数据，无需等待握手过程完成，大大减少了连接建立延迟。</li>
</ul>
</li>
<li><strong>前向纠错（Forward Error Correction，FEC）</strong>
<ul>
<li>QUIC 采用了 FEC 技术，通过在数据中添加冗余信息来恢复在传输过程中丢失的数据，减少了因丢包导致的数据重传，提高了传输效率和安全性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>从 SSL 到 HTTP/3.0（基于 UDP）的演变过程，是一个不断优化安全性能和网络传输效率的过程。HTTP/3.0 通过基于 UDP 的 QUIC 协议，在安全和性能方面都有了显著的提升。</p>
<h4 id="报文格式">报文格式
</h4><p><a class="link" href="https://blog.csdn.net/qq_45951891/article/details/134217064"  target="_blank" rel="noopener"
    >Wireshark——抓包分析_wireshark抓包数据怎么看-CSDN博客</a></p>
<ul>
<li>请求报文
<ul>
<li>方法</li>
</ul>
</li>
<li>响应报文
<ul>
<li>状态码</li>
</ul>
</li>
</ul>
<h4 id="cookieshttp无状态-有状态">COOKIES（HTTP无状态-&gt;有状态）
</h4><h4 id="web-缓存">WEB 缓存
</h4><ul>
<li>作用：通过本地命中，减少这些对象的访问延迟；进一步减少接入链路的流量强度，从而降低派对延迟带来总体平均延迟的减少；减轻服务器的负担。</li>
<li>优点：通过一个实例，计算不要求。</li>
</ul>
<h3 id="ftp-font-stylecolor74b602不要求font">FTP <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（不要求）<code>&lt;/font&gt;</code>
</h3><ul>
<li>作用：在 CS 之间传输文件。</li>
<li>构成：
<ul>
<li>C（客户端）</li>
<li>S（服务器）</li>
<li>FTP</li>
</ul>
</li>
<li>FTP 的连接
<ul>
<li>控制连接（带外传输）</li>
<li>数据连接</li>
</ul>
</li>
<li>命令和响应</li>
</ul>
<h3 id="email">EMAIL
</h3><h4 id="电子邮件应用的构成">电子邮件应用的构成
</h4><ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>SMTP（简单邮件传输协议）</li>
</ul>
<h4 id="邮件报文格式解析">邮件报文格式解析
</h4><ul>
<li>报文头</li>
<li>报文体</li>
<li>MIME（多用途互联网邮件扩展）：邮件多媒体扩展，可以在邮件中编解码多媒体内容。</li>
</ul>
<h4 id="邮件存取协议">邮件存取协议
</h4><ul>
<li>作用</li>
<li>常用
<ul>
<li>IMAP（互联网邮件访问协议）</li>
<li>POP3（邮局协议版本 3）</li>
</ul>
</li>
</ul>
<h3 id="dns">DNS
</h3><h4 id="dns-作用">DNS 作用
</h4><p>完成域名到 IP 地址的转换（还包括别名到正规名字、邮件服务器名字到正规名字转换等），是应用层面的互联网 <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>基础设施 <code>&lt;/font&gt;</code>，其他应用使用。</p>
<h4 id="二dns-的概念">二、DNS 的概念
</h4><ul>
<li>分布式、层次数据库</li>
<li>命名是分层的</li>
<li>域名信息存储和服务是分布式的，每个域名服务器担任一个区域 ZONE 的名字到 IP 地址的权威转换，也缓存名字 - IP 信息的转换。</li>
</ul>
<h4 id="三dns-的构成">三、DNS 的构成
</h4><ul>
<li>解析器：本地应用</li>
<li>域名服务器</li>
<li>DNS 协议
<ul>
<li>报文：请求和应答格式相同</li>
<li>RR：资源记录</li>
</ul>
</li>
</ul>
<h4 id="域名解析的过程">域名解析的过程
</h4><p><strong>(解析器 -&gt; 本地 DNS 服务器 -&gt; 上层域名服务器 -&gt;&hellip;-&gt; 权威名字服务器，返回)</strong></p>
<p><strong>本地域名服务器、权限域名服务器、顶级域名服务器、根域名服务器</strong></p>
<ul>
<li>递归解析：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</li>
<li>迭代解析：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/42840982/1736144525748-a7a35972-1aeb-4e16-acae-ca23c1300d01.png"
	
	
	
	loading="lazy"
	
	
></p>
<h4 id="dns-缓存">DNS 缓存
</h4><ul>
<li>作用</li>
<li>本地缓存 + 服务器缓存</li>
</ul>
<h3 id="p2p-font-stylecolor74b602了解p2p-的概念和优势即可font">P2P <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解P2P 的概念和优势即可）<code>&lt;/font&gt;</code>
</h3><h4 id="p2p-概念">P2P 概念
</h4><p>每个对等体即是客户端又是服务器；P2P 网络是这些 peer 构成的应用层面的逻辑网络。</p>
<h4 id="p2p-网络比-cs-方式分发内容快的原因">P2P 网络比 C/S 方式分发内容快的原因
</h4><p>这些 peer 节点参与到内容的上载，流量和服务都是分布式的，可扩展性。</p>
<h4 id="典型-p2p-应用及其原理-font-stylecolor74b602不要求font">典型 P2P 应用及其原理 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（不要求）<code>&lt;/font&gt;</code>
</h4><ul>
<li>Napster：知道名词</li>
<li>Gnutella：知道名词</li>
<li>KaZaA：知道名词</li>
<li>BT：知道名字</li>
<li>DHT：</li>
</ul>
<h3 id="视频流化服务和-cdn-font-stylecolor74b602了解font">视频流化服务和 CDN <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解）<code>&lt;/font&gt;</code>
</h3><h4 id="服务器向客户端进行视频流化的方式">服务器向客户端进行视频流化的方式
</h4><ul>
<li>UDP 流化</li>
<li>http 流化</li>
<li>DASH（Dynamic, Adaptive Streaming over HTTP）</li>
</ul>
<h4 id="dash-流化的过程">DASH 流化的过程
</h4><ul>
<li>客户端获取告示文件</li>
<li>客户端按照情况，向（可能是不同的）服务器请求不同视频质量的内容块，客户端智能</li>
</ul>
<h4 id="cdn">CDN
</h4><ul>
<li>单个服务器，或者服务器群向客户端提供海量内容并发服务的问题：扩展性差</li>
<li>CDN 原理
<ul>
<li>应用层面的协作服务网络</li>
<li>在全网部署缓存节点，内容预先部署到 CDN 缓存节点上</li>
<li>用户请求通过域名解析重定向向离自己 “最近的节点” 请求内容</li>
</ul>
</li>
<li>缓存节点放置的方式
<ul>
<li>Enter Deep</li>
<li>Bring Home</li>
</ul>
</li>
</ul>
<h3 id="tcp-的-socket-编程-font-stylecolor74b602理解-font">TCP 的 SOCKET 编程 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>理解 <code>&lt;/font&gt;</code>
</h3><h4 id="socket-概念">SOCKET 概念
</h4><ul>
<li>TCP 连接的本地标示示，向这个 SOCKET 写就是发送给对方的进程；从 SOCKET 中读，就是读取对方发送过来的数据。</li>
</ul>
<h4 id="socket-api">SOCKET API
</h4><ul>
<li>创建</li>
<li>使用（读和写）</li>
<li>关闭</li>
</ul>
<h4 id="tcp-socket-数据传输的特点">TCP SOCKET 数据传输的特点
</h4><ul>
<li>面向连接，可靠字节流服务</li>
</ul>
<h4 id="tcp-socket-编程">TCP SOCKET 编程
</h4><ul>
<li><strong>建立 SOCKET</strong>
<ul>
<li>客户端 TCP 实体动作：和服务器端的 TCP 实体握手沟通。</li>
<li>服务器端的动作</li>
<li>三次握手</li>
</ul>
</li>
<li>使用 SOCKET</li>
<li>关闭 SOCKET</li>
</ul>
<h3 id="udp-的-socket-编程-font-stylecolor74b602理解-font">UDP 的 SOCKET 编程 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>理解 <code>&lt;/font&gt;</code>
</h3><ul>
<li>UDP SOCKET数据传输的特点</li>
<li>编程 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> 不要求 <code>&lt;/font&gt;</code>
<ul>
<li>建立SOCKET（之前客户端 UDP 实体和服务器不用握手，不为之后的通信做准备）</li>
<li>使用</li>
<li>关闭</li>
</ul>
</li>
</ul>
<h2 id="传输层">传输层
</h2><h3 id="传输层服务">传输层服务
</h3><h4 id="传输服务">传输服务
</h4><ul>
<li>能够使端系统应用之间进行逻辑通信。</li>
<li>传输协议：运行于端系统的 2 个对等传输层实体相互通信应该遵守的规则集合。</li>
<li>传输服务和网络服务的区别
<ul>
<li>网络服务：主机到主机的通信。</li>
<li>传输服务：进程到进程的通信。</li>
</ul>
</li>
</ul>
<h4 id="互联网络传输层协议">互联网络传输层协议
</h4><ul>
<li>TCP：有连接，可靠保序数传服务。</li>
<li>UDP：无连接，不可靠，不保序的数传服务。</li>
</ul>
<h3 id="复用与解复用">复用与解复用
</h3><h4 id="复用">复用
</h4><ul>
<li>源端多个上层应用收集数据：应用报文，封装报文。</li>
</ul>
<h4 id="解复用">解复用
</h4><ul>
<li>接收端将数据按照端口号（结合 IP 地址）给相应的 SOCKET 对应的应用。</li>
</ul>
<h4 id="复用和解复用的工作原理ip-port">复用和解复用的工作原理：IP PORT
</h4><ul>
<li>TCP 有连接情况：SOCKETS 为 4 元组。</li>
<li>UDP 无连接情况：SOCKETS 为 2 元组。</li>
</ul>
<h3 id="无连接传输层协议-udp">无连接传输层协议 UDP
</h3><ul>
<li><strong>UDP 的必要性</strong>：有些应用对实时性比较在乎，对可靠性要求不高。</li>
<li><strong>UDP 报文（无连接的，因此叫做 UDP 数据报）格式</strong>。（头部 + 载荷）</li>
<li>**UDP 报文校验和的计算（Check Sum）  **<code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>理解 <code>&lt;/font&gt;</code></li>
</ul>
<h3 id="可靠数据传输原理">可靠数据传输原理
</h3><ul>
<li><strong>协议演进的方式讲解如何进行 rdt</strong>
<ul>
<li>加入一些假设，简单的协议可以提供 rdt 服务。</li>
<li>去掉一些假设，需要协议实体做相应的变化从而能够进行 rdt。</li>
</ul>
</li>
<li>**技术机制 ** <strong><code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> <code>&lt;/font&gt;</code></strong><code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>理解 <code>&lt;/font&gt;</code>
<ul>
<li>校验和，正向确认，反向确认。</li>
<li>序号：检查重复。</li>
<li>只有正向确认的机制。</li>
<li>检错重发和超时重发：处理丢失。
<ul>
<li>滑动窗口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="font-stylecolordf2a3frdtreliable-data-transfer可靠数据传输102030-的功能特点-font"><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>RDT（Reliable Data Transfer，可靠数据传输）1.0、2.0、3.0 的功能特点 <code>&lt;/font&gt;</code>
</h4><p><a class="link" href="https://blog.csdn.net/qq_39583450/article/details/113481150"  target="_blank" rel="noopener"
    >计算机网络（14）——可靠数据传输原理_rdt3.0接收方fsm-CSDN博客</a></p>
<h5 id="rdt-10">RDT 1.0
</h5><ol>
<li><strong>解决错误问题</strong>
<ul>
<li><strong>基本原理</strong>
<ul>
<li>RDT 1.0 假设底层信道完全可靠，不会出现比特差错，也不会丢失分组。</li>
<li>在这种理想情况下，发送方只需将数据发送出去，接收方就能无误地接收到数据。</li>
</ul>
</li>
<li><strong>工作机制</strong>
<ul>
<li>发送方：简单地将数据发送给接收方，无需考虑数据是否丢失或损坏。</li>
<li>接收方：接收数据并进行处理，不需要反馈机制来确认数据是否正确接收。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="rdt-20">RDT 2.0
</h5><ol>
<li><strong>解决序号 / 时序问题</strong>
<ul>
<li><strong>基本原理</strong>
<ul>
<li>RDT 2.0 考虑到了底层信道可能出现比特差错的情况，但仍然假设分组不会丢失。</li>
<li>为了检测和纠正错误，引入了差错检测码（如校验和）和确认（ACK）与否认（NAK）机制。</li>
</ul>
</li>
<li><strong>工作机制</strong>
<ul>
<li>发送方：
<ul>
<li>发送带有差错检测码的数据分组。</li>
<li>等待接收方的 ACK 或 NAK 反馈。如果收到 ACK，则继续发送下一个分组；如果收到 NAK，则重发当前分组。</li>
</ul>
</li>
<li>接收方：
<ul>
<li>接收数据分组并检查差错检测码。</li>
<li>如果数据无误，发送 ACK 给发送方；如果检测到错误，发送 NAK 给发送方。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="rdt-30">RDT 3.0
</h5><ol>
<li><strong>解决超时 / 重复问题</strong>
<ul>
<li><strong>基本原理</strong>
<ul>
<li>RDT 3.0 在 RDT 2.0 的基础上，进一步考虑了分组可能丢失的情况。</li>
<li>为了处理分组丢失问题，引入了定时器机制。</li>
</ul>
</li>
<li><strong>工作机制</strong>
<ul>
<li>发送方：
<ul>
<li>发送数据分组后启动定时器。</li>
<li>如果在定时器超时前收到 ACK，则取消定时器并发送下一个分组。</li>
<li>如果定时器超时，无论是否收到 NAK，都重发当前分组。</li>
</ul>
</li>
<li>接收方：
<ul>
<li>与 RDT 2.0 类似，接收数据分组，检查差错检测码，发送 ACK 或 NAK。</li>
<li>如果收到重复的分组（由于发送方超时重发），仍然发送 ACK 给发送方，以避免发送方不断重发。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>RDT 协议从 1.0 到 3.0 不断演进，逐步解决了可靠数据传输过程中的各种实际问题，从假设理想信道到考虑比特差错、分组丢失等情况，通过增加差错检测、确认机制、定时器等手段来确保数据的可靠传输。</p>
<h4 id="利用率计算-font-stylecolor74b602-了解-font">利用率计算 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> 了解 <code>&lt;/font&gt;</code>
</h4><p>停止等待技术：链路带宽延迟积（容量）效率低。
管道技术：在未经对方确认的情况下，可以连续发送多个 PDU。
GBN：发送窗口大于 1，接收窗口 = 1（只能顺序接收；发送方只设置一个超时定时器，一旦出错，返回到出错的那一个 PDU 重发）。
SR：发送窗口大于 1，接收窗口大于 1（能够乱序接收；发送方为每个发送出去的 PDU 设置超时定时器，哪个超时重发哪个）。</p>
<h3 id="有连接传输层协议tcp">有连接传输层协议：TCP
</h3><h4 id="tcp-服务特性">TCP 服务特性
</h4><ul>
<li>点对点：可靠保序字节流；管道（在未加确认情况下一次次传多个未经确认的段）；缓冲；全双工；面向连接；流控制。</li>
</ul>
<h4 id="tcp-段结构">TCP 段结构
</h4><ul>
<li>各个字段的作用。</li>
<li>连接建立时协商好双方的起始序号；</li>
<li>序号是首字节在字节流的偏移量；</li>
<li>确认：是对顺序收到的最后一个字节 + 1。</li>
</ul>
<h4 id="rtt-时间估计和重发超时时间估计">RTT 时间估计和重发超时时间估计
</h4><ol>
<li><strong>移动平均计算</strong>
<ul>
<li>平均往返延迟。</li>
<li>当前往返延迟采样值与平均值的偏差。</li>
<li>平均值 + 4 偏差。</li>
</ul>
</li>
</ol>
<h4 id="tcp-的可靠数据传输原理">TCP 的可靠数据传输原理
</h4><ol>
<li><strong>快速重传</strong>
<ul>
<li>在没有超时情况下，收到对方对于某一个段的重复三次（一共 4 个）ACK。</li>
</ul>
</li>
</ol>
<h4 id="流量控制">流量控制
</h4><ol>
<li><strong>流控目的</strong>
<ul>
<li>防止淹没接收方。</li>
</ul>
</li>
<li><strong>流控手段</strong>
<ul>
<li>将接收窗口大小捎带方式传递给发送端。</li>
</ul>
</li>
</ol>
<h4 id="tcp-连接管理-font-stylecolor74b602-理解-font">TCP 连接管理 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code> 理解 <code>&lt;/font&gt;</code>
</h4><ol>
<li><strong>连接建立</strong>
<ul>
<li>3 次握手技术，对双方选择的初始序号给予确认，准备好缓冲区。</li>
<li>第一次握手：SYN = 1，ACK = 0：发起端的序号。</li>
<li>第二次握手：<code>syn = 1</code>，<code>ack = 1</code>，被呼叫方的序号。</li>
<li>第三次握手：<code>(syn = 0) ack = 1</code>。</li>
</ul>
</li>
<li><strong>连接拆除</strong>
<ul>
<li>存在 2 军问题不完美（也不存在完美释放连接的方案，用定时器凑合解决）。</li>
<li>连接状态及其变迁。</li>
</ul>
</li>
</ol>
<h3 id="拥塞控制原理">拥塞控制原理
</h3><ol>
<li><strong>拥塞的概念</strong>
<ul>
<li>解释什么是拥塞，以及为什么会发生拥塞。</li>
</ul>
</li>
<li><strong>拥塞控制目的</strong></li>
<li><strong>拥塞控制手段</strong>**<code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>  理解 <code>&lt;/font&gt;</code>**
<ul>
<li>端到端的拥塞控制：<strong>TCP</strong> 采用这种方式。</li>
<li>网络辅助的拥塞控制：<strong>ATM</strong> 网络标志和携带拥塞信息，反馈给主机 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（不要求）<code>&lt;/font&gt;</code>。</li>
</ul>
</li>
</ol>
<h3 id="tcp-的拥塞控制原理">TCP 的拥塞控制原理
</h3><h4 id="tcp-拥塞控制原理-font-stylecolordf2a3f需掌握font">TCP 拥塞控制原理 <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>（需掌握）<code>&lt;/font&gt;</code>
</h4><ol>
<li><strong>检测拥塞</strong>
<ul>
<li>超时（拥塞，存在误判的可能性，但概率比较低）。</li>
<li>三个冗余 ACK（轻微拥塞）。</li>
</ul>
</li>
<li><strong>拥塞控制机制</strong>
<ul>
<li>AIMD（加性增 <code>&lt;font style=&quot;color:#F1A2AB;&quot;&gt;</code>1 <code>&lt;/font&gt;</code>、乘性减 <code>&lt;font style=&quot;color:#F1A2AB;&quot;&gt;</code>半 <code>&lt;/font&gt;</code>）、慢启动 <code>&lt;font style=&quot;color:#F1A2AB;&quot;&gt;</code>（加倍）<code>&lt;/font&gt;</code>、超时之后的保守策略。</li>
</ul>
</li>
</ol>
<h4 id="tcp-拥塞控制的-2-种算法">TCP 拥塞控制的 2 种算法
</h4><ol>
<li><strong>Tahoe</strong>
<ul>
<li>超时事件和 3 个冗余 ACK 处理一样的，不要求。</li>
</ul>
</li>
<li><strong>reno 算法</strong> <strong><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>（需掌握）<code>&lt;/font&gt;</code></strong>
<ul>
<li>超时事件发生和 3 个冗余 ACK 处理不一样。</li>
</ul>
</li>
</ol>
<h4 id="平均延迟和超时定时器时间的设置">平均延迟和超时定时器时间的设置
</h4><ol>
<li>**JACSON 算法（具体初始化和迭代算法， ** <strong><code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>不要求 <code>&lt;/font&gt;</code></strong> <strong>）</strong>
<ul>
<li>平均往返延迟公式。</li>
<li>Dev 算法：第一个超时时间 = 延迟的 1/2，初值设置；后面按公式。</li>
<li>超时时间设置：es + 4dev。</li>
</ul>
</li>
</ol>
<h4 id="tcp-公平性font-stylecolor74b602了解-font">TCP 公平性：<code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>了解 <code>&lt;/font&gt;</code>
</h4><h4 id="tcp-的吞吐量计算font-stylecolor74b602不要求-font">TCP 的吞吐量计算：<code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>不要求 <code>&lt;/font&gt;</code>。
</h4><h2 id="网络层之数据平面">网络层之数据平面
</h2><h3 id="简介">简介
</h3><h4 id="网络层的主要服务和功能">网络层的主要服务和功能
</h4><ol>
<li><strong>服务</strong>
<ul>
<li>向传输层提供主机到主机的段传输服务。</li>
</ul>
</li>
<li><strong>功能 1—— 转发，数据平面功能</strong>
<ul>
<li>从路由器的一个端口流入，从另外一个端口流出。</li>
</ul>
</li>
<li><strong>功能 2—— 路由，控制平面的功能</strong>
<ul>
<li>决定从源到目的的路径。</li>
<li>两个功能相互配合将数据报从源传送到目标主机；关联是转发表、流表。</li>
</ul>
</li>
</ol>
<h4 id="实现网络层功能的两种方式">实现网络层功能的两种方式
</h4><ol>
<li><strong>传统方式</strong>
<ul>
<li>控制平面和数据平面功能垂直集成在每个设备上（路由器）。</li>
<li>控制平面功能：路由协议实体分布式地计算路由表。</li>
<li>数据平面的功能：IP 协议按照路由表进行分组的转发。</li>
</ul>
</li>
<li><strong>SDN 通用转发方式</strong>
<ul>
<li>控制平面和数据平面分离，在不同设备上实现。</li>
<li>SDN 控制器集中式计算、下发流表实现控制平面功能。</li>
<li>SDN 分组交换机按照流表对到来的分组进行转发，实现数据平面的功能。</li>
</ul>
</li>
</ol>
<h4 id="网络层提供服务的一些重要指标">网络层提供服务的一些重要指标
</h4><ul>
<li>带宽</li>
<li>延迟、延迟差</li>
<li>丢包与否</li>
<li>丢包率</li>
</ul>
<h3 id="路由器结构和工作原理">路由器结构和工作原理
</h3><h4 id="路由器的-2-大功能-font-stylecolor74b602需理解font">路由器的 2 大功能 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（需理解）<code>&lt;/font&gt;</code>
</h4><ol>
<li><strong>路由协议</strong>
<ul>
<li>结果形成路由表（转发表）。</li>
</ul>
</li>
<li><strong>转发分组</strong>
<ul>
<li>使用转发表转发分组，交换。</li>
</ul>
</li>
</ol>
<h4 id="构成">构成
</h4><ol>
<li><strong>输入端口</strong>
<ul>
<li>线路终端实现物理层功能，链路协议实体实现链路层功能，网络层功能实现分布式分组转发。</li>
<li>最长前缀匹配。</li>
</ul>
</li>
<li><strong>交换结构</strong>
<ul>
<li>基于内存的，基于 bus 的，基于 CROSSBAR 的。</li>
</ul>
</li>
<li><strong>输出端口</strong>
<ul>
<li>网络层可以实现分组的调度：FIFO，RR，WFQ。</li>
<li>调度支持对多媒体分组等优先级分组的传输支持。</li>
</ul>
</li>
<li><strong>路由处理器</strong>
<ul>
<li>控制各部分协调工作。</li>
</ul>
</li>
</ol>
<h3 id="互联网网络层协议">互联网网络层协议
</h3><h4 id="ip-网络提供的服务模型尽力而为">IP 网络提供的服务模型：尽力而为
</h4><ul>
<li>包括含义：丢包、乱序、不可靠、（可能包括重复）。</li>
</ul>
<h4 id="网络层构成">网络层构成
</h4><ol>
<li><strong>协议</strong>
<ul>
<li>IP 协议、路由选择协议、ICMP 协议</li>
<li>转发表</li>
</ul>
</li>
<li><strong>IP 数据报格式</strong>
<ul>
<li>各个字段的作用</li>
<li>分片和重组 <code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>- 掌握 <code>&lt;/font&gt;</code>
<ul>
<li>一个分组的总体大小超过了转发链路的 MTU，因此要切片。</li>
<li><strong>到目标主机重组。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>IP 编址</strong>
<ul>
<li>IP 地址：主机或路由器和网络接口的标识。</li>
<li>子网
<ul>
<li>在一个子网内的设备之间的通信有 2 个特点：1）通信无需借助路由器；2）子网前缀一样。</li>
</ul>
</li>
<li>IP 地址分类：ABC（单步）  D（多步）  E（预留）</li>
<li>特殊 IP 地址（内网、全0、全1）</li>
<li>子网掩码和 CIDR</li>
</ul>
</li>
<li>**NAT ** <strong><code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>不要求 <code>&lt;/font&gt;</code></strong></li>
<li>DHCP 协议：上网主机获得 IP、掩码、默认网关和 local name server。</li>
<li>路由聚集：连续的子网前缀的子网可达信息可以做聚集，减少向外部传输路由的数量，减少路由计算的负担。支持大概的路由聚集，与此对应的是最长前缀匹配的措施。</li>
<li>IPV 6：
<ol>
<li>格式（固定头部长度 40B ），地址：128 bits</li>
<li>变化（32-&gt;128）</li>
<li>IPV4 到 IPV6 的迁移
<ol>
<li>隧道</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="通用转发和-sdn">通用转发和 SDN
</h3><h4 id="sdn-方式控制平面和数据平面分离的优点-font-stylecolor74b602需理解font">SDN 方式控制平面和数据平面分离的优点 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（需理解）<code>&lt;/font&gt;</code>
</h4><ol>
<li>集中在控制器上实现控制逻辑，网络可编程，可以实现各种复杂的网络功能、新功能（一次部署，持续升级）、方便管理。</li>
<li>形成开发生态（控制器、分组交换机、网络应用，在一个开放的框架下协作）。</li>
</ol>
<h4 id="sdn-分组交换机按照计算出的流表进行分组转发通用便于升级">SDN 分组交换机按照计算出的流表进行分组转发、通用、便于升级。
</h4><h5 id="分组交换机工作原理-font-stylecolor74b602需理解font">分组交换机工作原理 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（需理解）<code>&lt;/font&gt;</code>
</h5><ol>
<li>模式匹配 + 行动（不仅仅是转发，还可以组播、泛洪、修改字段和阻塞等）。</li>
<li>进来分组，按照各级字段匹配流表，按照相应的行动动作分组。</li>
<li>按照优先权进行判断；之后，统计计数。</li>
</ol>
<h2 id="网络层之控制平面">网络层之控制平面
</h2><h3 id="概述">概述
</h3><ol>
<li><strong>两种方式实现控制平面功能</strong>
<ul>
<li>传统方式：在每个路由器上分布式实现路由功能。</li>
<li>SDN 方式：在 SDN 控制器上由网络应用集中式计算、生成流表。</li>
</ul>
</li>
</ol>
<h3 id="路由选择算法">路由选择算法
</h3><ol>
<li><strong>路由目标</strong>
<ul>
<li>根据收集到的路由信息（拓扑、链路代价等）计算出源到目标较好的路径，代价比较低的路径。</li>
<li>主机 - 主机的路径 == 路由器到路由器的路径。</li>
<li>路由目标实际上是计算出节点的汇集树。</li>
<li>路由原则：完整正确、简单、健壮、稳定公平、最优（次优）。</li>
</ul>
</li>
<li><strong>路由分类</strong>
<ul>
<li>静态和动态（自适应）。</li>
<li>局部和全局的。</li>
</ul>
</li>
</ol>
<p><a class="link" href="https://blog.csdn.net/qq_53144843/article/details/121254000"  target="_blank" rel="noopener"
    >路由算法(Dijkstra, Bellman-Ford算法)_bellmanford算法和dijkstra-CSDN博客</a></p>
<ol start="3">
<li><strong>LS 算法（链路状态）</strong> <strong>（需掌握）</strong>
<ul>
<li>全局的路由选择算法，工作原理</li>
<li>每个节点收集邻居信息，生成 LS；LS 全网泛洪。</li>
<li>节点收集 LS 状态分组，形成网络拓扑。</li>
<li>按照最短路径算法算出到其他节点的最优路径。</li>
</ul>
</li>
<li><strong>DV 算法（距离矢量）</strong> <strong>（需掌握）</strong>
<ul>
<li>局部的路由选择算法，工作原理</li>
<li>每个节点维护到所有其他节点的下一跳和代价。</li>
<li>邻居节点之间定期交换 DV。</li>
<li>按照 Bellman-Ford 不断迭代生成到所有目标的代价和相应的下一跳</li>
</ul>
</li>
<li>**层次路由 ** <strong>理解</strong>
<ul>
<li>一个平面解决路由的问题：计算、传输和存储路由信息的量太大，不具备可扩展性，也不满足不同网络运营方不同的管理需求</li>
<li>分成 AS, AS 内部之间的节点路由由<strong>内部网关协议</strong>解决：AS 之间的路由，分层解决（路由到网关，由网关路由到目标网关（外部网关协议），到了目标 AS 内部，采用 AS 内部的路由解决）</li>
<li>优势：分层路由，解决了规模性问题，管理性问题</li>
</ul>
</li>
</ol>
<p>路由算法用于确定数据分组从源节点到目的节点的传输路径，其中静态路由与动态路由是两种重要的路由方式：</p>
<ul>
<li><strong>静态路由</strong>
<ul>
<li><strong>定义</strong>：静态路由是由网络管理员手动配置的路由信息。管理员依据网络拓扑结构，明确指定每个目的网络的下一跳路由器或出口接口。例如，在一个小型企业网中，仅有几条固定线路连接不同部门，管理员清楚各部门之间数据该如何流转，就可以手动设置静态路由。</li>
<li><strong>优点</strong>：
<ul>
<li><strong>安全性高</strong>：由于路由表是人工定制，外部攻击者较难篡改路由信息，能保障网络的基本架构安全。</li>
<li><strong>低开销</strong>：不需要额外的路由协议进行路由信息交互，几乎不占用网络带宽与设备资源，适合简单网络拓扑。</li>
<li><strong>可预测性强</strong>：数据传输路径固定，网络管理员能精准预估数据包走向，便于故障排查。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>缺乏灵活性</strong>：网络拓扑一旦变动，像新增节点、链路故障，静态路由无法自动调整，必须人工重新配置，在大型复杂网络里，工作量巨大。</li>
<li><strong>配置繁琐</strong>：在大规模网络中，需要为众多目的网络逐个设置路由，容易出错且管理成本飙升。</li>
</ul>
</li>
</ul>
</li>
<li><strong>动态路由</strong>
<ul>
<li><strong>定义</strong>：动态路由依靠路由协议，让路由器之间自动交换网络拓扑和链路状态等信息，随后各自依据特定算法计算出最佳路由。常见的动态路由协议有 RIP、OSPF、BGP 等。例如，在互联网骨干网中，无数的路由器时刻在交互信息，动态更新路由表。</li>
<li><strong>优点</strong>：
<ul>
<li><strong>自适应网络变化</strong>：链路故障、网络扩容时，路由器能快速重新计算路由，保障网络畅通，无需人工干预。</li>
<li><strong>配置简便</strong>：只需在路由器上启用相关路由协议，后续路由更新依靠协议自动完成，降低了管理员工作量。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>占用资源</strong>：路由协议持续交互信息，消耗网络带宽；路由器计算路由也占用自身的 CPU、内存资源。</li>
<li><strong>存在安全风险</strong>：路由协议传输的信息如果被恶意篡改，会误导网络流量走向，引发网络安全事故。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>静态路由和动态路由适用于不同的网络场景，简单、稳定的网络更适合静态路由，而复杂多变、规模较大的网络则要依靠动态路由来保障高效的数据传输。</p>
<h3 id="互联网的路由协议">互联网的路由协议
</h3><h4 id="路由协议分类">路由协议分类
</h4><ol>
<li><strong>内部网关协议 IGP</strong>
<ul>
<li>RIP</li>
<li>OSPF：AS 内部支持分层路由，同时支持多种代价。</li>
<li>IGRP</li>
</ul>
</li>
<li><strong>外部网关协议 EGP</strong>
<ul>
<li>BGP</li>
</ul>
</li>
</ol>
<h4 id="网关路由器参与-as-内部路由计算收集-as-内部子网可达信息">网关路由器参与 AS 内部路由计算，收集 AS 内部子网可达信息
</h4><ol>
<li>网关路由器通过 AS 间路由向其他 AS 网关通告子网可达信息。</li>
<li>网关路由器还转发 “过手” 子网可达信息，但是 AS 路径要加上它自己 AS 编号（防止形成环路）。</li>
<li>网关路由器通过 i - BGP 向 AS 内部所有路由节点通告收集到的子网可达信息。</li>
<li>内部路由器，通过 AS 内路由和 AS 间路由共同决定向 AS 外部子网的下一跳（内部网关协议决定如何去往网关，外部网关协议决定通过那个网关可到达 AS 外部子网）。</li>
</ol>
<h4 id="内部网关协议和外部网关协议的对比-font-stylecolor74b602了解font">内部网关协议和外部网关协议的对比 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解）<code>&lt;/font&gt;</code>
</h4><ol>
<li>内部网关协议重视效率，性能。</li>
<li>外部网关协议重视策略：经济策略和政治策略</li>
</ol>
<h2 id="sdn-控制平面">SDN 控制平面
</h2><ul>
<li>在控制器上集中实现控制功能。</li>
<li>控制器和 SDN 交换机按照 <code>openflow</code>等南向接口协议等下发流表，上报设备状态。</li>
<li>SDN 控制器按照北向接口和网络应用打交道。</li>
</ul>
<h3 id="icmp-协议-font-stylecolor74b602了解font">ICMP 协议 <code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（了解）<code>&lt;/font&gt;</code>
</h3><ul>
<li>作用：包括错误、<code>echo</code>请求和应答。</li>
<li>报文类型。</li>
</ul>
<h2 id="数据链路层与局域网">数据链路层与局域网
</h2><h3 id="引论">引论
</h3><ol>
<li><strong>链路层提供的服务</strong>
<ul>
<li>成帧、链路存取控制（链路访问控制）。</li>
<li>在相邻节点间进行可靠数据传递。</li>
<li>流量控制。</li>
<li>检错。</li>
<li>纠错。</li>
<li>全双工和半双工服务。</li>
</ul>
</li>
<li><strong>链路层网络节点的连接方式</strong>
<ul>
<li>点到点方式：比较适合广域。</li>
<li>多点连接的方式：比较适合局域、联网方便，但是需要解决 MAC 问题。</li>
</ul>
</li>
</ol>
<h3 id="检错与纠错">检错与纠错
</h3><ol>
<li><strong>检错原理</strong>
<ul>
<li>奇偶校验。</li>
<li>CRC（循环冗余校验）<code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code> - 掌握 <code>&lt;/font&gt;</code>
<ul>
<li>原理。</li>
<li>生成多项式。</li>
<li>冗余位计算方法以及验证方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="多路访问协议">多路访问协议
</h3><ul>
<li><strong>MAC 的必要性</strong></li>
<li><strong>MAP</strong></li>
<li><strong>信道划分</strong>
<ul>
<li><strong>TDMA</strong></li>
<li><strong>FDMA</strong></li>
<li><strong>CDMA</strong>：删掉</li>
</ul>
</li>
<li><strong>RAP：随机访问协议</strong>
<ul>
<li><strong>slotted ALOHA</strong></li>
<li><strong>ALOHA</strong></li>
<li><strong>CSMA</strong>，<strong><code>&lt;font style=&quot;background-color:#FBF5CB;&quot;&gt;</code>CSMA/CD（至少 2t 长度帧），CSMA/CA <code>&lt;/font&gt;</code></strong></li>
</ul>
</li>
<li><strong>轮转协议：不要求</strong></li>
<li><strong>令牌协议</strong></li>
</ul>
<h3 id="链路层编地址">链路层编地址
</h3><ul>
<li><strong>MAC 地址（48位）</strong>
<ul>
<li><strong>格式</strong></li>
<li><strong>分配</strong></li>
</ul>
</li>
<li><strong>MAC 地址和网络层 IP 地址的区别</strong>
<ul>
<li><strong>层次不同</strong></li>
<li><strong>MAC 地址平面的，用于标示一个物理网络的不同站点；IP 是可以聚集的，便于计算路由</strong></li>
</ul>
</li>
<li><strong>ARP 协议</strong>
<ul>
<li><strong>目的：物理网络范围内 IP 地址到 MAC 地址的转换</strong></li>
<li><strong>工作原理：广播查询，单播应答</strong></li>
</ul>
</li>
</ul>
<h3 id="以太网">以太网
</h3><ol>
<li><strong>IEEE802.3 标准，链路层和相应的物理层。</strong></li>
<li><strong>以太网的帧结构。</strong></li>
<li><strong>向上提供服务的特点。</strong>
<ul>
<li>无连接：以太网在传输数据时不需要事先建立连接。</li>
<li>不可靠：数据传输过程中不保证数据的可靠到达。</li>
</ul>
</li>
<li><strong>访问控制技术。</strong>
<ul>
<li><strong>CSMA/CD</strong> <strong><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;</code>（需掌握）<code>&lt;/font&gt;</code></strong>：载波侦听多路访问 / 冲突检测，用于解决以太网中的冲突问题。
<ul>
<li>指数后退：在发生冲突后，设备会采用指数后退算法等待一段时间后再尝试发送。</li>
</ul>
</li>
<li>**CSMA/CA ** <strong><code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（需理解）<code>&lt;/font&gt;</code></strong>：载波侦听多路访问 / 冲突避免，适用于无线网络。</li>
</ul>
</li>
<li><strong>编码。</strong>
<ul>
<li><strong>Manchester 编码</strong>：一种常用的编码方式。</li>
</ul>
</li>
</ol>
<h3 id="hub-和交换机">HUB 和交换机
</h3><ol>
<li><strong>HUB 连接方式的问题。</strong>
<ul>
<li>无法隔离冲突，在一个冲突域之中：使用 HUB 连接设备时，所有连接的设备处于同一个冲突域，容易产生冲突。</li>
</ul>
</li>
<li><strong>交换机的工作原理。</strong>
<ul>
<li>选择性转发：交换机可以根据目的地址有选择地转发数据。</li>
<li>自学习：交换机能够自动学习连接设备的 MAC 地址。</li>
<li>流量隔离：交换机可以隔离不同端口的流量，减少冲突。</li>
<li>专用接入：交换机提供专用的接入端口。</li>
</ul>
</li>
<li><strong>路由器和交换机的区别</strong> <strong><code>&lt;font style=&quot;color:#74B602;&quot;&gt;</code>（需理解）<code>&lt;/font&gt;</code></strong></li>
</ol>
<h2 id="参考">参考
</h2><p><a class="link" href="https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click&amp;vd_source=76a496aa006e07f846fd0bbe5954c92e"  target="_blank" rel="noopener"
    >中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程</a></p>

</section>



    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/Hugo-dev/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
        
    </section>


    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 2025-02-20
        </span>
    </section></footer>



    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="hongyun-yu/Hugo-dev"
    data-repo-id="R_kgDONs2V_A"
    data-category="Announcements"
    data-category-id="DIC_kwDONs2V_M4CmzPf"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector("iframe.giscus-frame");
        if (giscus) {
            giscus.contentWindow.postMessage(
                {
                    giscus: {
                        setConfig: {
                            theme: theme,
                        },
                    },
                },
                "https://giscus.app"
            );
        }
    }

    (function () {
        addEventListener("message", (e) => {
            if (event.origin !== "https://giscus.app") return;
            handler();
        });
        window.addEventListener("onColorSchemeChange", handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('light');
            } else {
                setGiscusTheme('dark_dimmed');
            }
        }
    })();
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 Hongyun
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

    
    <section class="running-time">
    本博客已稳定运行
    <span id="runningdays" class="running-days"></span>
    </section>
    
    
    <section class="totalcount">
    
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
    发表了5篇文章 · 
    总计30.48k字
</section>

</footer>




    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/Hugo-dev/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
 
<script src="https://npm.elemecdn.com/nprogress@0.2.0/nprogress.js" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://npm.elemecdn.com/nprogress@0.2.0/nprogress.css" crossorigin="anonymous" />
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script>


<style>
  #TableOfContents > ul, ol {
      ul, ol {
          display: none;
      }
      .open {
          display: block;
      }
  }
</style>

<script>
  function initTocHide() {
      
      let toc = document.querySelector(".widget--toc");
      if (!toc) {
          return;
      }
      
      window.addEventListener('scroll', function() {
          
          let openUl = document.querySelectorAll(".open");
          if (openUl.length > 0) {
            openUl.forEach((ul) => {
              ul.classList.remove("open")
            })
          }
          
          let currentLi = document.querySelector(".active-class");
          if (!currentLi) {
              return
          }
          
          if (currentLi.children.length > 1) {
              currentLi.children[1].classList.add("open")
          }
          
          let ul = currentLi.parentElement;
          do {
              ul.classList.add("open");
              ul = ul.parentElement.parentElement;
          } while (ul !== undefined && (ul.localName === 'ul' || ul.localName === 'ol'))
      });
  }
  initTocHide()
</script>


<style>
  #backTopBtn {
      display: none;
      position: fixed;
      bottom: 30px;
      z-index: 99;
      cursor: pointer;
      width: 30px;
      height: 30px;
      background-image: url(https://hongyun-yu.github.io/Hugo-dev/icons/backTop.svg);
  }
</style>

<script>
  

  function initScrollTop() {
      let rightSideBar = document.querySelector(".right-sidebar");
      if (!rightSideBar) {
          return;
      }
      
      let btn = document.createElement("div");
      btn.id = "backTopBtn";
      btn.onclick = backToTop
      rightSideBar.appendChild(btn)
      
      window.onscroll = function() {
          
          if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
              btn.style.display = "block";
          } else {
              btn.style.display = "none";
          }
      };
  }

  

  function backToTop(){
      window.scrollTo({ top: 0, behavior: "smooth" })
  }

  initScrollTop();
</script>



<script>
    let s1 = '2025-1-20'; 
    s1 = new Date(s1.replace(/-/g, "/"));
    let s2 = new Date();
    let timeDifference = s2.getTime() - s1.getTime();

    let days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));
    let hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    let minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));

    let result = days + "天" + hours + "小时" + minutes + "分钟";
    document.getElementById('runningdays').innerHTML = result;
</script>





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>


<meting-js
	server="netease"
	type="playlist"
	fixed="true"
    order="random"
    list-max-height="1500px"
	id="13187846602">
</meting-js>

<script>
    ap = null
    Object.defineProperty(document.querySelector('meting-js'),"aplayer",{
        set: function(aplayer) {
            ap = aplayer
            ready();
        }
    });
    isRecover = false;
    function ready(){
        ap.on('canplay', function () {
            if(!isRecover){
                if(localStorage.getItem("musicIndex") != null){
                    musicIndex = localStorage.getItem("musicIndex");
                    musicTime = localStorage.getItem("musicTime");
                    if(ap.list.index != musicIndex){
                        ap.list.switch(musicIndex);
                    }else{
                        ap.seek(musicTime);
                        ap.play();
                        localStorage.clear();
                        isRecover = true;
                    }
                }else{
                    isRecover = true;
                }
            }
        });
    }
    window.onbeforeunload = function(event) {
        if(!ap.audio.paused){
            musicIndex = ap.list.index;
            musicTime = ap.audio.currentTime;
            localStorage.setItem("musicIndex",musicIndex);
            localStorage.setItem("musicTime",musicTime);
        }
    };
</script>


<script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script>
<script>
	var pjax = new Pjax({
	  selectors: [
	    ".main-container"
	  ]
	})

	
	pjax._handleResponse = pjax.handleResponse;
    pjax.handleResponse = function(responseText, request, href, options) {
        if (request.responseText.match("<html")) {
            
            let newDom = new DOMParser().parseFromString(responseText, 'text/html');
            
            let bodyClass = newDom.body.className;
            document.body.setAttribute("class", bodyClass)
            
            pjax._handleResponse(responseText, request, href, options);
        } else {
            
        }
    }

	
	document.addEventListener('pjax:complete', () => {
        
        window.Stack.init();
    })

</script>




<div id="particles-js"></div>
<script src=https://hongyun-yu.github.io/Hugo-dev/background/particles.min.js></script>
<script>
  particlesJS.load('particles-js', "https://hongyun-yu.github.io/Hugo-dev/background/particlesjs-config.json", function() {
    console.log('particles.js loaded - callback');
  });
</script>

<style>
  #particles-js {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
</style>




<style>
    @font-face {
      font-family: 'LXGWWenKai';
      src: url(https://hongyun-yu.github.io/Hugo-dev/font/LXGWWenKai-Medium.ttf) format('truetype');
    }
  
    :root {
      --base-font-family: 'LXGWWenKai';
      --code-font-family: 'LXGWWenKai';
    }
  </style>
  
    </body>
</html>

<body>
    <button class="btn" onclick="smoothScrollTop()" id="goTopBtn" title="Go to top">TOP</button>
  </body>